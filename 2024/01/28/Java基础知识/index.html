

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.JPG">
  <link rel="icon" href="/img/icon.JPG">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#3f4a6e">
  <meta name="author" content="Rey">
  <meta name="keywords" content="">
  
    <meta name="description" content="Java基础知识🤔 面向对象期末考试前三天速成Java大师">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识">
<meta property="og:url" content="http://jerrycc.cn/2024/01/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Rey&#39;s blog">
<meta property="og:description" content="Java基础知识🤔 面向对象期末考试前三天速成Java大师">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://jerrycc.cn/img/java1.png">
<meta property="article:published_time" content="2024-01-28T14:56:46.000Z">
<meta property="article:modified_time" content="2024-02-10T13:02:06.468Z">
<meta property="article:author" content="Rey">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://jerrycc.cn/img/java1.png">
  
  
  
  <title>Java基础知识 - Rey&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jerrycc.cn","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"k4MoKUoxJSHvqT6e3JwRqB5i-gzGzoHsz","app_key":"Osktw6Tpa3b2OsHj3mgpbdWP","server_url":"https://k4mokuox.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Rey</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java基础知识"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-28 22:56" pubdate>
          2024年1月28日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          76 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> times
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java基础知识</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><p>🤔 面向对象期末考试前三天速成Java大师</p>
<span id="more"></span>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><strong>局部变量</strong>  方法 语句块中</li>
<li><strong>成员变量</strong> 类中  方法外</li>
<li><strong>类变量&#x2F;静态变量</strong><ul>
<li>类中 方法外 </li>
<li>static</li>
<li>与类相关 不与实例相关</li>
</ul>
</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在Java中，修饰符是用来修饰类、方法、变量以及其他数据类型的关键字。它们提供了额外的信息，用于控制访问级别、继承性、特定行为等。以下是一些常见的Java修饰符：</p>
<ol>
<li><p><strong>访问修饰符（Access Modifiers）：</strong></p>
<ul>
<li><code>public</code>: 公共的，可以被任何类访问。</li>
<li><code>protected</code>: 受保护的，可以被同一包内的类及其子类访问。</li>
<li><code>default</code> (包级别): 如果没有指定修饰符，默认为包级别，可以被同一包内的类访问。</li>
<li><code>private</code>: 私有的，只能在声明它的类内部访问。</li>
</ul>
</li>
<li><p><strong>非访问修饰符：</strong></p>
<ul>
<li><code>final</code>: 表示最终的，不可更改的。用于修饰类、方法、变量。</li>
<li><code>abstract</code>: 用于声明抽象类和抽象方法。</li>
<li><code>static</code>: 表示静态的，属于类而不是实例。用于方法、变量、代码块。</li>
<li><code>transient</code>: 用于标记不希望序列化的字段。</li>
<li><code>volatile</code>: 用于多线程编程，确保变量的可见性。</li>
</ul>
</li>
<li><p><strong>其他修饰符：</strong></p>
<ul>
<li><code>synchronized</code>: 用于多线程同步，修饰方法或代码块。</li>
<li><code>native</code>: 表示一个方法用其他编程语言（如C、C++）实现，通常与<code>JNI</code>（Java Native Interface）一起使用。</li>
<li><code>strictfp</code>: 用于确保浮点运算在不同平台上产生相同的结果。</li>
<li><code>default</code> (接口中): 用于指定接口中的默认方法实现。</li>
</ul>
</li>
<li><p><strong>注解修饰符：</strong></p>
<ul>
<li><code>@Override</code>: 表示该方法覆盖了父类的方法。</li>
<li><code>@Deprecated</code>: 表示该元素（类、方法等）已过时，不推荐使用。</li>
<li><code>@SuppressWarnings</code>: 抑制编译器警告。</li>
<li>其他自定义注解。</li>
</ul>
</li>
</ol>
<p>这些修饰符可以根据需要进行组合使用，以满足特定的编程需求。例如，一个方法可以同时使用<code>public</code>、<code>static</code>和<code>final</code>修饰符。</p>
<ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li>
</ul>
<h3 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h3><h4 id="character类"><a href="#character类" class="headerlink" title="character类"></a>character类</h4><p>Java中的<code>Character</code>类是一个包装类，用于表示字符类型数据（Unicode字符）。它提供了许多用于处理字符的方法和常量。</p>
<p>以下是一些<code>Character</code>类的常用方法和常量：</p>
<ol>
<li><p>静态方法：</p>
<ul>
<li><code>isDigit(char ch)</code>：检查字符是否为数字字符。</li>
<li><code>isLetter(char ch)</code>：检查字符是否为字母字符。</li>
<li><code>isLetterOrDigit(char ch)</code>：检查字符是否为字母或数字字符。</li>
<li><code>isUpperCase(char ch)</code>：检查字符是否为大写字母。</li>
<li><code>isLowerCase(char ch)</code>：检查字符是否为小写字母。</li>
<li><code>toUpperCase(char ch)</code>：将字符转换为大写。</li>
<li><code>toLowerCase(char ch)</code>：将字符转换为小写。</li>
</ul>
</li>
<li><p>常量：</p>
<ul>
<li><code>MIN_VALUE</code>：<code>char</code>类型的最小值，即 <code>\u0000</code>。</li>
<li><code>MAX_VALUE</code>：<code>char</code>类型的最大值，即 <code>\uffff</code>。</li>
<li><code>MIN_RADIX</code>：进制的最小值，即 2。</li>
<li><code>MAX_RADIX</code>：进制的最大值，即 36。</li>
<li><code>SIZE</code>：<code>char</code>类型的位数，通常为 16。</li>
</ul>
</li>
</ol>
<p>下面是一个示例代码，演示了如何使用<code>Character</code>类的一些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>        System.out.println(Character.isDigit(ch));  <span class="hljs-comment">// false</span><br>        System.out.println(Character.isLetter(ch));  <span class="hljs-comment">// true</span><br>        System.out.println(Character.isLetterOrDigit(ch));  <span class="hljs-comment">// true</span><br>        System.out.println(Character.isUpperCase(ch));  <span class="hljs-comment">// true</span><br>        System.out.println(Character.isLowerCase(ch));  <span class="hljs-comment">// false</span><br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">lowercaseCh</span> <span class="hljs-operator">=</span> Character.toLowerCase(ch);<br>        System.out.println(lowercaseCh);  <span class="hljs-comment">// &#x27;a&#x27;</span><br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">uppercaseCh</span> <span class="hljs-operator">=</span> Character.toUpperCase(ch);<br>        System.out.println(uppercaseCh);  <span class="hljs-comment">// &#x27;A&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h4><p>在Java中，<code>String</code>类是一个非常常用的类，用于表示和操作字符串。它是<strong>不可变（immutable）</strong>的，意味着一旦创建，就不能更改其内容。<code>String</code>类提供了许多方法来处理字符串，如下所示：</p>
<ol>
<li><p>创建字符串：</p>
<ul>
<li>使用双引号：<code>String str = &quot;Hello, World!&quot;;</code></li>
<li>使用<code>new</code>关键字：<code>String str = new String(&quot;Hello, World!&quot;);</code></li>
</ul>
</li>
<li><p>字符串长度：</p>
<ul>
<li><code>int length()</code>: 返回字符串的长度。</li>
</ul>
</li>
<li><p>字符串连接：</p>
<ul>
<li><code>String concat(String str)</code>: 将指定的字符串连接到原始字符串的末尾。</li>
<li>使用加号（+）运算符：<code>String result = str1 + str2;</code></li>
</ul>
</li>
<li><p>字符串提取：</p>
<ul>
<li><code>char charAt(int index)</code>: 返回指定索引位置的字符。</li>
<li><code>String substring(int beginIndex)</code>: 返回从指定索引开始到字符串末尾的子字符串。</li>
<li><code>String substring(int beginIndex, int endIndex)</code>: 返回从指定的开始索引到结束索引之间的子字符串（不包括结束索引）。</li>
</ul>
</li>
<li><p>字符串查找：</p>
<ul>
<li><code>int indexOf(String str)</code>: 返回指定字符串在原始字符串中第一次出现的索引。</li>
<li><code>int lastIndexOf(String str)</code>: 返回指定字符串在原始字符串中最后一次出现的索引。</li>
<li><code>boolean contains(CharSequence sequence)</code>: 检查原始字符串是否包含指定的字符序列。</li>
</ul>
</li>
<li><p>字符串替换：</p>
<ul>
<li><code>String replace(char oldChar, char newChar)</code>: 将原始字符串中的所有旧字符替换为新字符。</li>
<li><code>String replace(CharSequence target, CharSequence replacement)</code>: 将原始字符串中的所有目标字符序列替换为指定的替换字符序列。</li>
</ul>
</li>
<li><p>字符串拆分：</p>
<ul>
<li><code>String[] split(String regex)</code>: 使用给定的正则表达式将字符串拆分为子字符串数组。</li>
</ul>
</li>
<li><p>字符串转换：</p>
<ul>
<li><code>char[] toCharArray()</code>: 将字符串转换为字符数组。</li>
<li><code>byte[] getBytes()</code>: 将字符串转换为字节数组。</li>
<li><code>int parseInt(String str)</code>: 将字符串解析为整数。</li>
</ul>
</li>
<li><p>字符串比较：</p>
<ul>
<li><code>boolean equals(Object obj)</code>: 检查字符串是否与指定对象相等。</li>
<li><code>boolean equalsIgnoreCase(String anotherString)</code>: 检查字符串是否与指定字符串相等，忽略大小写。</li>
<li><code>int compareTo(String anotherString)</code>: 按字典顺序比较两个字符串。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        System.out.println(<span class="hljs-string">&quot;Length: &quot;</span> + length);  <span class="hljs-comment">// 13</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">concatStr</span> <span class="hljs-operator">=</span> str.concat(<span class="hljs-string">&quot; Welcome!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Concatenated String: &quot;</span> + concatStr);  <span class="hljs-comment">// Hello, World! Welcome!</span><br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">charAtIndex</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">4</span>);<br>        System.out.println(<span class="hljs-string">&quot;Character at index 4: &quot;</span> + charAtIndex);  <span class="hljs-comment">// o</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">subString</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">7</span>);<br>        System.out.println(<span class="hljs-string">&quot;Substring from index 7: &quot;</span> + subString);  <span class="hljs-comment">// World!</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">indexOf</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-string">&quot;o&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;First index of &#x27;o&#x27;: &quot;</span> + indexOf);  <span class="hljs-comment">// 4</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">replacedStr</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Replaced String: &quot;</span> + replacedStr);  <span class="hljs-comment">// Hellx, Wxrld!</span><br><br>        String[] splitArray = str.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Split String:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : splitArray) &#123;<br>            System.out.println(s);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Output:</span><br><span class="hljs-comment">        Split String:</span><br><span class="hljs-comment">        Hello</span><br><span class="hljs-comment">         World!</span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-type">char</span>[] charArray = str.toCharArray();<br>        System.out.println(<span class="hljs-string">&quot;Character Array:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : charArray) &#123;<br>            System.out.println(c);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Output:</span><br><span class="hljs-comment">        Character Array:</span><br><span class="hljs-comment">        H</span><br><span class="hljs-comment">        e</span><br><span class="hljs-comment">        l</span><br><span class="hljs-comment">        l</span><br><span class="hljs-comment">        o</span><br><span class="hljs-comment">        ,</span><br><span class="hljs-comment">         </span><br><span class="hljs-comment">        W</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure>



<h4 id="stringBuffer"><a href="#stringBuffer" class="headerlink" title="stringBuffer"></a>stringBuffer</h4><p>在Java中，<code>StringBuffer</code>类是一个<strong>可变的字符串类</strong>，用于处理可变字符串。与<code>String</code>类不同，<code>StringBuffer</code>类的内容可以修改。<code>StringBuffer</code>类提供了许多方法来对字符串进行修改和操作。</p>
<p>以下是<code>StringBuffer</code>类的一些常用方法：</p>
<ol>
<li><p>创建<code>StringBuffer</code>对象：</p>
<ul>
<li><code>StringBuffer sb = new StringBuffer();</code>：创建一个空的<code>StringBuffer</code>对象。</li>
<li><code>StringBuffer sb = new StringBuffer(&quot;Hello&quot;);</code>：使用指定的字符串创建一个<code>StringBuffer</code>对象。</li>
</ul>
</li>
<li><p>追加和插入操作：</p>
<ul>
<li><code>StringBuffer append(String str)</code>：在当前字符串的末尾追加指定的字符串。</li>
<li><code>StringBuffer insert(int offset, String str)</code>：在指定的偏移量位置插入指定的字符串。</li>
</ul>
</li>
<li><p>删除操作：</p>
<ul>
<li><code>StringBuffer delete(int start, int end)</code>：删除指定索引范围内的字符。</li>
<li><code>StringBuffer deleteCharAt(int index)</code>：删除指定索引位置的字符。</li>
</ul>
</li>
<li><p>修改操作：</p>
<ul>
<li><code>void setCharAt(int index, char ch)</code>：将指定索引位置的字符设置为给定字符。</li>
<li><code>void replace(int start, int end, String str)</code>：将指定索引范围内的字符替换为给定字符串。</li>
</ul>
</li>
<li><p>反转字符串：</p>
<ul>
<li><code>StringBuffer reverse()</code>：反转当前字符串。</li>
</ul>
</li>
<li><p>获取字符串长度：</p>
<ul>
<li><code>int length()</code>：返回当前字符串的长度。</li>
</ul>
</li>
<li><p>转换为字符串：</p>
<ul>
<li><code>String toString()</code>：将当前字符串缓冲区转换为<code>String</code>对象。</li>
</ul>
</li>
</ol>
<p>下面是一个示例代码，演示了如何使用<code>StringBuffer</code>类的一些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBufferExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><br>        sb.append(<span class="hljs-string">&quot;, World!&quot;</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello, World!</span><br><br>        sb.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot; Java&quot;</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello Java, World!</span><br><br>        sb.delete(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello, World!</span><br><br>        sb.setCharAt(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;J&#x27;</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello, Jorld!</span><br><br>        sb.reverse();<br>        System.out.println(sb.toString());  <span class="hljs-comment">// !dlroJ ,olleH</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> sb.length();<br>        System.out.println(<span class="hljs-string">&quot;Length: &quot;</span> + length);  <span class="hljs-comment">// 13</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码中，我们首先创建了一个<code>StringBuffer</code>对象<code>sb</code>，并使用其方法进行追加、插入、删除、修改和反转操作。最后，我们获取了字符串的长度并输出结果。</p>
<p>需要注意的是，<code>StringBuffer</code>类是线程安全的，适用于多线程环境。如果在单线程环境下使用，建议使用效率更高但线程不安全的<code>StringBuilder</code>类。</p>
<h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        name = myName; <br>        id = myid;<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123; <br>        System.out.println(name+<span class="hljs-string">&quot;正在吃&quot;</span>); <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;正在睡&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">introduction</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;大家好！我是&quot;</span>         + id + <span class="hljs-string">&quot;号&quot;</span> + name + <span class="hljs-string">&quot;.&quot;</span>); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Penguin</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        <span class="hljs-built_in">super</span>(myName, myid); <br>        <span class="hljs-comment">//可以用super()通过父类的公有方法（public 方法）来访问和设置 private 成员</span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>Java 不支持多继承，但支持多重继承。</p>
</li>
<li><p>子类拥有父类非 private 的属性、方法。</p>
</li>
<li><p><strong>extends</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">private</span> String name;   <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        <span class="hljs-comment">//初始化属性值</span><br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//吃东西方法的具体实现  &#125; </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//睡觉方法的具体实现  &#125; </span><br>&#125; <br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Animal</span>&#123; <br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><strong>implements</strong></li>
</ul>
<p>使用 implements 关键字可以<strong>变相</strong>的使java具有<strong>多继承</strong>的特性，使用范围为类继承接口的情况，可以<strong>同时继承多个接口</strong>（接口跟接口之间采用逗号分隔）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B &#123;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><strong>super 和 this</strong><ul>
<li><strong>super</strong>关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</li>
<li><strong>this</strong>关键字：指向自己的引用。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;animal : eat&quot;</span>);<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;dog : eat&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.eat();   <span class="hljs-comment">// this 调用自己的方法</span><br>    <span class="hljs-built_in">super</span>.eat();  <span class="hljs-comment">// super 调用父类方法</span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>    a.eat();<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    d.eatTest();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li><p><strong>final</strong></p>
<ul>
<li>使用 final 关键字声明类，就是把类定义定义为<strong>最终类</strong>，<strong>不能被继承</strong></li>
<li>或者用于<strong>修饰方法</strong>，该方法<strong>不能被子类重写</strong></li>
</ul>
</li>
<li><p><strong>构造器</strong></p>
<ul>
<li>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</li>
<li>如果父类的构造器<strong>带有参数</strong>，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</li>
<li>如果父类构造器<strong>没有参数</strong>，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会<strong>自动调用父类的无参构造器</strong>。</li>
</ul>
</li>
</ul>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>在Java中，方法的重写是指子类定义了一个与其父类中方法<strong>签名相同</strong>（<strong>方法名、参数列表、返回类型相同</strong>）的方法。<strong>重写（Override）发生在继承关系中</strong>，子类通过<strong>重写父类的方法</strong>来提供自己的实现。这样做的主要目的是为了在子类中修改或扩展父类的行为。</p>
<p>以下是方法重写的基本规则：</p>
<ol>
<li><p><strong>方法签名：</strong> 重写的方法与父类方法具有相同的方法签名，包括方法名、参数列表和返回类型。</p>
</li>
<li><p><strong>访问修饰符：</strong> 重写的方法的访问修饰符不能比父类中被重写的方法的访问修饰符更严格。例如，如果父类中的方法是<code>public</code>，那么子类中的重写方法也必须是<code>public</code>。</p>
</li>
<li><p><strong>返回类型：</strong> 重写的方法的返回类型必须与被重写方法的返回类型相同或是其子类。</p>
</li>
<li><p><strong>抛出异常：</strong> 如果被重写的方法在父类中声明了异常，那么子类中重写的方法的声明异常不能超出父类方法声明的异常。子类可以不抛出异常或者只抛出父类方法声明的异常的子类。</p>
</li>
</ol>
<p>下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal makes a sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 子类重写父类方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 子类可以新增其他方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fetch</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog fetches a ball&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        animal.makeSound();  <span class="hljs-comment">// 调用的是Dog类的makeSound()方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>Dog</code> 类继承了 <code>Animal</code> 类，并重写了 <code>makeSound</code> 方法。在 <code>Main</code> 类中，创建了一个 <code>Dog</code> 对象，并通过 <code>Animal</code> 类型的引用调用了 <code>makeSound</code> 方法。这样的调用会执行 <code>Dog</code> 类中重写的方法，而不是 <code>Animal</code> 类中的原始方法。这就是多态的一种体现。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>方法的<strong>重载（Overloading）</strong>是指在一个类中可以定义多个方法，这些方法具有<strong>相同的名字</strong>但具有<strong>不同的参数列表</strong>。在方法重载中，方法名相同，但<strong>参数类型、参数个数或者参数顺序不同</strong>。</p>
<p>重载的目的是提高代码的灵活性和可读性，使得开发者可以用一致的方式来命名不同版本的同一种操作。</p>
<p>以下是方法重载的基本规则：</p>
<ol>
<li>方法名必须相同。</li>
<li>参数列表必须不同，包括参数类型、参数个数或者参数顺序。</li>
<li>返回类型可以相同也可以不同。</li>
<li>可以有不同的访问修饰符。</li>
<li>重载方法可以声明新的或更广泛的检查异常。</li>
</ol>
<p>下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-comment">// 两个整数相加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-comment">// 三个整数相加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b + c;<br>    &#125;<br><br>    <span class="hljs-comment">// 两个浮点数相加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-comment">// 字符串连接</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">concatenate</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-keyword">return</span> str1 + str2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>Calculator</code> 类定义了多个名为 <code>add</code> 的方法，它们的参数列表分别为两个整数、三个整数和两个浮点数。这就是方法的重载。同样，还有一个 <code>concatenate</code> 方法，用于字符串连接，也是方法重载的一种形式。</p>
<p>调用这些方法时，编译器会根据实际参数的数量和类型来确定调用哪个版本的方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);          <span class="hljs-comment">// 调用两个整数相加的方法</span><br><span class="hljs-type">int</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>);      <span class="hljs-comment">// 调用三个整数相加的方法</span><br><span class="hljs-type">double</span> <span class="hljs-variable">result3</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">5.5</span>, <span class="hljs-number">10.5</span>);   <span class="hljs-comment">// 调用两个浮点数相加的方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result4</span> <span class="hljs-operator">=</span> calculator.concatenate(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot; World&quot;</span>); <span class="hljs-comment">// 调用字符串连接的方法</span><br></code></pre></td></tr></table></figure>





<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作</p>
<ul>
<li><p><strong>必要条件</strong></p>
<ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象：<strong>Parent p &#x3D; new Child();</strong></li>
</ul>
</li>
<li><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，<strong>再去调用子类的同名方法</strong>。</p>
</li>
<li><p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在Java中，抽象类（Abstract Class）是一种特殊的类，<strong>它不能被实例化</strong>，用于提供其他类的共同抽象和部分实现，所以抽象类<strong>必须被继承，才能被使用</strong>。抽象类可以包含抽象方法和非抽象方法。</p>
<p>关键点和特征：</p>
<ol>
<li><p><strong>关键字 <code>abstract</code>：</strong> 抽象类使用关键字 <code>abstract</code> 声明。在抽象类中可以包含抽象方法和非抽象方法。抽象方法是没有具体实现的方法，需要在<strong>具体的子类中被实现</strong>。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal sleeps&quot;</span>);  <span class="hljs-comment">// 非抽象方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>不能实例化：</strong> 由于抽象类包含抽象方法，不能被直接实例化。可以通过<strong>继承抽象类并提供抽象方法的实现来创建具体的子类</strong>。</p>
</li>
<li><p><strong>继承和实现：</strong> 子类继承自抽象类，可以选择性地实现抽象方法。如果子类是非抽象类，它必须提供所有抽象方法的具体实现；如果子类也是抽象类，可以选择性地实现抽象方法，或者继续将它标记为抽象。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>可以有构造方法：</strong> 抽象类可以有构造方法，用于初始化抽象类的成员变量或执行其他初始化操作。子类在实例化时，会先调用父类的构造方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-type">int</span> age;<br><br>    Animal(<span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>可以包含成员变量和非抽象方法：</strong> 除了抽象方法外，抽象类可以包含成员变量、非抽象方法、静态方法等。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-type">int</span> sides;<br><br>    Shape(<span class="hljs-type">int</span> sides) &#123;<br>        <span class="hljs-built_in">this</span>.sides = sides;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayInfo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a shape with &quot;</span> + sides + <span class="hljs-string">&quot; sides.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>抽象类用于建模一些通用的特征和行为，并要求具体的子类提供实际的实现。在继承层次结构中，抽象类为多态性提供了基础。</p>
<ul>
<li>\1. 抽象类不能被实例化(初学者很容易犯的错)，<strong>如果被实例化，就会报错</strong>，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>\2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>\3. 抽象类中的抽象方法只是声明，不包含方法体，就是<strong>不给出方法的具体实现</strong>也就是方法的具体功能。</li>
<li>\4. <strong>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</strong>。</li>
<li>\5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li><strong>修改属性的可见性</strong>来限制对属性的访问（一般限制为<strong>private</strong>）</li>
<li>对每个值属性提供对外的<strong>公共方法</strong>访问，也就是创建一对赋取值方法，用于<strong>对私有属性的访问</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 文件名: EncapTest.java */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncapTest</span>&#123;<br> <br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> String idNum;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> age;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> name;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIdNum</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> idNum;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">( <span class="hljs-type">int</span> newAge)</span>&#123;<br>      age = newAge;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String newName)</span>&#123;<br>      name = newName;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIdNum</span><span class="hljs-params">( String newId)</span>&#123;<br>      idNum = newId;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在Java中，接口（Interface）是一种抽象类型，用于定义一组抽象方法的集合，而不包含具体的实现。接口提供了一种将类与类之间以及类与接口之间进行关联的机制，支持多继承和规范化的设计。</p>
<p>以下是Java接口的主要特点和用法：</p>
<ol>
<li><p><strong>定义接口：</strong> 使用 <code>interface</code> 关键字来声明接口。接口中的方法<strong>默认是抽象的，不包含方法体</strong>。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>实现接口：</strong> 通过 <code>implements</code> 关键字，<strong>一个类可以实现一个或多个接口</strong>。<strong>实现接口的类必须提供接口中所有抽象方法的具体实现</strong>。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing MyInterface&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>多继承：</strong> 一个类可以实现多个接口，从而达到<strong>多继承</strong>的效果。这是Java中实现多继承的一种方式。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceB</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span>, InterfaceB &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing InterfaceA&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing InterfaceB&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>接口的默认方法和静态方法：</strong> Java 8 引入了接口的默认方法和静态方法，使得接口可以包含具体的方法实现。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Default method in interface&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static method in interface&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 在实现类中，<strong>可以选择性地重写抽象方法</strong>，并可以直接使用默认方法和静态方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing MyInterface&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 不重写 defaultMethod，使用默认实现</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        myObject.myMethod();<br>        myObject.defaultMethod();<br>        MyInterface.staticMethod();<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>接口的继承：</strong> 一个接口可以继承另一个接口，通过 <strong><code>extends</code></strong> 关键字。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在Java中，枚举（Enum）是一种特殊的数据类型，用于定义包含固定常量值的有限集合。枚举类型在Java中是一种引用数据类型，它可以包含字段、方法和构造方法。</p>
<p>以下是Java中枚举的基本用法和特点：</p>
<ol>
<li><p><strong>定义枚举：</strong> 使用 <code>enum</code> 关键字来定义枚举类型。枚举中的每个值都是枚举类型的一个实例。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 在上面的例子中，<code>Day</code> 枚举包含七个实例，分别代表星期的每一天。</p>
</li>
<li><p><strong>枚举常量：</strong> 枚举的每个值被称为枚举常量。在上面的例子中，<code>SUNDAY</code>、<code>MONDAY</code> 等就是枚举常量。</p>
</li>
<li><p><strong>访问枚举常量：</strong> 枚举常量可以通过枚举类型的名称访问。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> Day.MONDAY;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>枚举可以有字段、方法和构造方法：</strong> 与普通类一样，枚举可以包含字段、方法和构造方法。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    SUNDAY(<span class="hljs-string">&quot;Sun&quot;</span>), MONDAY(<span class="hljs-string">&quot;Mon&quot;</span>), TUESDAY(<span class="hljs-string">&quot;Tue&quot;</span>), WEDNESDAY(<span class="hljs-string">&quot;Wed&quot;</span>),<br>    THURSDAY(<span class="hljs-string">&quot;Thu&quot;</span>), FRIDAY(<span class="hljs-string">&quot;Fri&quot;</span>), SATURDAY(<span class="hljs-string">&quot;Sat&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String abbreviation;<br><br>    Day(String abbreviation) &#123;<br>        <span class="hljs-built_in">this</span>.abbreviation = abbreviation;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAbbreviation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> abbreviation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 在这个例子中，<code>Day</code> 枚举包含了一个字段 <code>abbreviation</code>，一个构造方法和一个获取缩写的方法。</p>
</li>
<li><p><strong>枚举的比较：</strong> 枚举常量之间可以使用 <code>==</code> 运算符进行比较。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">day1</span> <span class="hljs-operator">=</span> Day.MONDAY;<br><span class="hljs-type">Day</span> <span class="hljs-variable">day2</span> <span class="hljs-operator">=</span> Day.MONDAY;<br><br><span class="hljs-keyword">if</span> (day1 == day2) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Both are the same day&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>switch语句和枚举：</strong> 枚举类型特别适合在 <code>switch</code> 语句中使用，因为它可以列举所有可能的情况。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> Day.MONDAY;<br><br><span class="hljs-keyword">switch</span> (day) &#123;<br>    <span class="hljs-keyword">case</span> MONDAY:<br>        System.out.println(<span class="hljs-string">&quot;It&#x27;s Monday&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TUESDAY:<br>        System.out.println(<span class="hljs-string">&quot;It&#x27;s Tuesday&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// 其他情况...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型（Generics）是Java语言中的一个重要特性，它允许<strong>在类、接口和方法的定义中使用一个或多个类型参数</strong>，以实现代码的重用和类型安全性。</p>
<p>通过使用泛型，可以编写通用的代码，可以在不指定具体类型的情况下定义类、接口或方法。这使得代码可以<strong>适用于不同类型的数据</strong>，提高了代码的灵活性和可重用性。</p>
<p>泛型的主要目的是在<strong>编译时执行类型检查，以避免在运行时出现类型转换错误</strong>。它提供了类型安全性，可以在编译时捕获和修复类型错误，而不是在运行时抛出异常。</p>
<p>使用泛型的常见场景包括：</p>
<ol>
<li><p><strong>泛型类（Generic Class）</strong>：定义一个类时，可以使用泛型来表示其中的一个或多个类型参数。例如，<code>ArrayList&lt;T&gt;</code> 是一个泛型类，可以在创建对象时指定具体的类型参数，如 <code>ArrayList&lt;String&gt;</code>。</p>
</li>
<li><p><strong>泛型接口（Generic Interface）</strong>：类似于泛型类，泛型接口允许在接口中使用类型参数。例如，<code>List&lt;T&gt;</code> 是一个泛型接口，可以在实现接口时指定具体的类型参数。</p>
</li>
<li><p><strong>泛型方法（Generic Method）</strong>：在方法的定义中使用泛型类型参数。这允许方法在调用时接受不同类型的参数，并且可以在方法内部使用泛型类型进行操作。例如，<code>&lt;T&gt; T getFirst(List&lt;T&gt; list)</code> 是一个泛型方法，可以返回列表中的第一个元素，并且可以适用于不同类型的列表。</p>
</li>
</ol>
<p>泛型的好处包括：</p>
<ol>
<li><p><strong>类型安全性</strong>：泛型提供了编译时的类型检查，可以在编译时捕获类型错误，避免在运行时出现类型转换错误。</p>
</li>
<li><p><strong>代码重用</strong>：通过使用泛型，可以编写通用的代码，可以适用于不同类型的数据，提高了代码的灵活性和可重用性。</p>
</li>
<li><p><strong>代码简洁性</strong>：使用泛型可以减少手动的类型转换代码，使代码更加简洁和易读。</p>
</li>
</ol>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>一个包内的类可以互相访问，即它们之间的访问级别是包级别（默认级别）。在Java中，默认情况下，如果没有明确指定访问修饰符，类、方法和变量的访问级别就是包级别。</p>
<p>这意味着同一包内的类可以相互访问彼此的包级别成员。下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 com.example.myapp 包中的 MyClass.java 文件</span><br><span class="hljs-keyword">package</span> com.example.myapp;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 包级别的成员变量</span><br>    <span class="hljs-type">int</span> packageLevelVariable;<br><br>    <span class="hljs-comment">// 包级别的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">packageLevelMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 可以访问同一包内的其他类的包级别成员</span><br>        <span class="hljs-type">AnotherClass</span> <span class="hljs-variable">anotherClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnotherClass</span>();<br>        anotherClass.anotherClassMethod();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 com.example.myapp 包中的 AnotherClass.java 文件</span><br><span class="hljs-keyword">package</span> com.example.myapp;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-comment">// 包级别的成员变量</span><br>    <span class="hljs-type">int</span> anotherClassVariable;<br><br>    <span class="hljs-comment">// 包级别的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">anotherClassMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 可以访问同一包内的其他类的包级别成员</span><br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        System.out.println(myClass.packageLevelVariable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述例子中，<code>MyClass</code>和<code>AnotherClass</code>都位于<code>com.example.myapp</code>包内，因此它们可以访问对方的包级别成员。</p>
<h2 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h2><p>Java提供了丰富的数据结构和集合类库，这些类库位于<code>java.util</code>包下。以下是Java中一些常用的数据结构和集合：</p>
<ol>
<li><p><strong>ArrayList：</strong> 动态数组，可以根据需要动态增长或缩小的数组。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>LinkedList：</strong> 双向链表，支持快速的插入和删除操作。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br>LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>linkedList.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>HashMap：</strong> 键值对的散列表实现，提供快速的查找和插入。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><br>HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>HashSet：</strong> 基于HashMap的集合，不允许重复元素。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><br>HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>set.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>TreeMap：</strong> 基于红黑树的有序映射，按照键的自然顺序或自定义顺序排序。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br>TreeMap&lt;String, Integer&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>treeMap.put(<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">1</span>);<br>treeMap.put(<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>TreeSet：</strong> 基于TreeMap的有序集合，不允许重复元素。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br>TreeSet&lt;String&gt; treeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>treeSet.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>treeSet.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Queue接口和LinkedList：</strong> 队列的实现，通常用于先进先出（FIFO）的场景。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>queue.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Stack：</strong> 栈的实现，通常用于后进先出（LIFO）的场景。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br>Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>stack.push(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>stack.push(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>PriorityQueue：</strong> 优先队列，基于堆实现，可以按照元素的优先级进行排序。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br>PriorityQueue&lt;Integer&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>priorityQueue.add(<span class="hljs-number">3</span>);<br>priorityQueue.add(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p>Java集合框架提供了一套强大且灵活的数据结构和算法，用于存储、检索、操作和处理集合数据。这个框架包含了一系列的接口、实现类和算法，主要位于<code>java.util</code>包中。以下是Java集合框架的主要部分：</p>
<ul>
<li><strong>接口（Interfaces）：</strong></li>
</ul>
<ol>
<li><strong>Collection接口：</strong> 是集合框架的根接口，表示<strong>一组对象的集合</strong>。<code>List</code>、<code>Set</code> 和 <code>Queue</code> 都继承自 <code>Collection</code> 接口。</li>
</ol>
<ul>
<li><code>List</code>：有序的集合，允许重复元素。常用实现类有 <code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>。<ul>
<li><code>Set</code>：不允许重复元素的集合。常用实现类有 <code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code>。</li>
<li><code>Queue</code>：代表一组元素的队列，通常用于实现先进先出（FIFO）的数据结构。常用实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Map接口：</strong> 表示<strong>键值对的集合</strong>，每个键都映射到一个值。常用实现类有 <code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>。</li>
</ol>
<ul>
<li><strong>实现类（Classes）：</strong></li>
</ul>
<ol>
<li><p><strong>List接口的实现类：</strong></p>
<ul>
<li><code>ArrayList</code>：动态数组实现，支持随机访问，适用于快速查找和遍历。</li>
<li><code>LinkedList</code>：双向链表实现，支持快速插入和删除，适用于频繁操作集合元素的场景。</li>
<li><code>Vector</code>：类似于 <code>ArrayList</code>，但是是线程安全的。</li>
</ul>
</li>
<li><p><strong>Set接口的实现类：</strong></p>
<ul>
<li><code>HashSet</code>：基于哈希表实现，不保证顺序。</li>
<li><code>LinkedHashSet</code>：基于哈希表和链表实现，按照元素插入顺序保证顺序。</li>
<li><code>TreeSet</code>：基于红黑树实现，按照元素的自然顺序或自定义顺序排序。</li>
</ul>
</li>
<li><p><strong>Queue接口的实现类：</strong></p>
<ul>
<li><code>LinkedList</code>：实现了 <code>Queue</code> 接口，可用于实现队列。</li>
</ul>
</li>
<li><p><strong>Map接口的实现类：</strong></p>
<ul>
<li><code>HashMap</code>：基于哈希表实现，键值对无序。</li>
<li><code>LinkedHashMap</code>：基于哈希表和链表实现，按照键值对插入顺序保证顺序。</li>
<li><code>TreeMap</code>：基于红黑树实现，按照键的自然顺序或自定义顺序排序。</li>
</ul>
</li>
<li><p><strong>其他常用类：</strong></p>
<ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code> 等都实现了 <code>Set</code> 接口。</li>
<li><code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code> 等都实现了 <code>Map</code> 接口。</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>工具类（Utilities）：</strong></p>
<ul>
<li><strong>Collections类：</strong> 提供了一系列静态方法，用于对集合进行操作和算法处理，如排序、反转、洗牌等。</li>
<li><strong>Arrays类：</strong> 提供了一系列静态方法，用于操作数组，如排序、二分查找等。</li>
</ul>
</li>
<li><p><strong>并发集合（Concurrent Collections）：</strong></p>
<ul>
<li><code>ConcurrentHashMap</code>：线程安全的哈希表实现。</li>
<li><code>CopyOnWriteArrayList</code>：线程安全的动态数组实现，适用于读多写少的场景。</li>
<li><code>CopyOnWriteArraySet</code>：线程安全的集合，基于 <code>CopyOnWriteArrayList</code> 实现。</li>
</ul>
</li>
</ul>
<h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><p>在Java中，线程相关的操作和指令主要涉及到以下方面：</p>
<ol>
<li><p><strong>创建线程：</strong></p>
<ul>
<li><p>使用 <code>Thread</code> 类或实现 <code>Runnable</code> 接口创建线程。</p>
</li>
<li><p>例如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>线程调度和控制：</strong></p>
<ul>
<li><code>Thread.sleep(long millis)</code>：使当前线程休眠指定的毫秒数。</li>
<li><code>Thread.yield()</code>：暂停当前正在执行的线程，允许其他线程执行。</li>
<li><code>join()</code>：等待一个线程终止。</li>
<li><code>interrupt()</code>：中断线程的执行。</li>
</ul>
</li>
<li><p><strong>同步和互斥：</strong></p>
<ul>
<li><code>synchronized</code> 关键字：用于同步代码块或方法，确保在同一时刻只有一个线程可以访问。</li>
<li><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>：在对象上进行等待和唤醒其他线程的操作，通常与<code>synchronized</code>一起使用。</li>
</ul>
</li>
<li><p><strong>线程状态控制：</strong></p>
<ul>
<li><code>getState()</code>：获取线程的状态。</li>
<li><code>isAlive()</code>：判断线程是否处于活动状态。</li>
</ul>
</li>
<li><p><strong>并发集合和工具类：</strong></p>
</li>
</ol>
<ul>
<li><code>java.util.concurrent</code> 包提供了一些并发集合和工具类，如 <code>ConcurrentHashMap</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code> 等，用于更方便地进行多线程编程。</li>
</ul>
<ol start="6">
<li><strong>线程池：</strong></li>
</ol>
<ul>
<li><code>ExecutorService</code> 和 <code>ThreadPoolExecutor</code> 等类用于管理线程池，提高线程的复用性和效率。</li>
</ul>
<ol start="7">
<li><strong>原子操作和CAS（Compare and Swap）：</strong></li>
</ol>
<ul>
<li><code>java.util.concurrent.atomic</code> 包提供了一系列原子操作类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等，用于在多线程环境中执行原子操作。</li>
</ul>
<ol start="8">
<li><p><strong>并行流：</strong></p>
<ul>
<li>Java 8 引入的并行流框架允许在多个线程上同时处理流的元素。</li>
</ul>
</li>
</ol>
<p>这些指令和类库提供了Java中进行多线程编程的基本工具和机制。在编写多线程代码时，要注意线程安全性、死锁和性能等问题，以确保程序的正确性和效率。</p>
<p>这几个方法的具体用法如下：</p>
<ol>
<li><p><strong>Thread.sleep(long millis)：</strong></p>
<ul>
<li><p>使当前线程休眠指定的毫秒数，进入阻塞状态。</p>
</li>
<li><p>用法示例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 休眠1秒</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Thread.yield()：</strong></p>
<ul>
<li><p>暂停当前正在执行的线程，允许其他线程执行。</p>
</li>
<li><p><code>yield</code> 是一个静态方法，通过调用 <code>Thread.yield()</code> 可以提示调度器当前线程愿意让出CPU资源。</p>
</li>
<li><p>用法示例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// 暂停当前线程，让出CPU资源</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>join()：</strong></p>
<ul>
<li><p>等待一个线程终止，即等待被调用 <code>join</code> 方法的线程执行完毕。</p>
</li>
<li><p>用法示例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 线程执行的逻辑</span><br>&#125;);<br>thread.start();<br><span class="hljs-keyword">try</span> &#123;<br>    thread.join(); <span class="hljs-comment">// 主线程等待 thread 线程执行完毕</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>interrupt()：</strong></p>
<ul>
<li><p>中断线程的执行，给线程发送中断信号。</p>
</li>
<li><p>被中断的线程需要通过检查 <code>Thread.interrupted()</code> 或 <code>isInterrupted()</code> 方法来判断是否被中断，并做相应处理。</p>
</li>
<li><p>用法示例：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>        <span class="hljs-comment">// 线程执行的逻辑</span><br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;线程被中断&quot;</span>);<br>&#125;);<br>myThread.start();<br><br><span class="hljs-comment">// 在其他地方中断线程</span><br>myThread.interrupt();<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>一些关键字和方法主要用于实现线程之间的协调和同步，确保多个线程能够安全地共享资源。以下是它们的具体用法：</p>
<ol>
<li><p><strong>synchronized 关键字：</strong></p>
<ul>
<li><p>用于同步代码块或方法，确保在同一时刻只有一个线程可以访问被 synchronized 修饰的代码块或方法。</p>
</li>
<li><p>对象级别的同步：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步的代码块或方法</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>代码块级别的同步：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>        <span class="hljs-comment">// 同步的代码块</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>wait()、notify()、notifyAll()：</strong></p>
<ul>
<li><p>这些方法通常与 synchronized 一起使用，用于实现线程之间的协调和通信。</p>
</li>
<li><p><code>wait()</code>：使当前线程进入等待状态，并释放对象锁，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lockObject.wait(); <span class="hljs-comment">// 等待其他线程唤醒</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>notify()</code>：唤醒在相同对象上等待的一个线程。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    lockObject.notify(); <span class="hljs-comment">// 唤醒一个等待线程</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>notifyAll()</code>：唤醒在相同对象上等待的所有线程。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    lockObject.notifyAll(); <span class="hljs-comment">// 唤醒所有等待线程</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>这些机制可以帮助线程之间进行协同工作，避免竞争条件和确保资源的正确共享。需要注意的是，使用 wait()、notify()、notifyAll() 时，必须在同步块或同步方法中调用，否则会抛出 <code>IllegalMonitorStateException</code> 异常。</p>
<h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I&#x2F;O"></a>Java I&#x2F;O</h2><p>在Java中，流（Stream）是用于处理输入和输出（I&#x2F;O）操作的重要概念。流主要分为输入流和输出流，它们分别用于从外部数据源读取数据和将数据写入到外部目标。</p>
<p>以下是Java流的一些关键概念和总结：</p>
<ol>
<li><p><strong>输入流和输出流：</strong></p>
<ul>
<li><strong>输入流（InputStream）：</strong> 用于从外部数据源（例如文件、网络、内存等）读取数据。</li>
<li><strong>输出流（OutputStream）：</strong> 用于向外部目标（例如文件、网络、内存等）写入数据。</li>
</ul>
</li>
<li><p><strong>字节流和字符流：</strong></p>
<ul>
<li><strong>字节流：</strong> 处理字节数据，主要用于处理二进制文件。例如，<code>FileInputStream</code>和<code>FileOutputStream</code>。</li>
<li><strong>字符流：</strong> 处理字符数据，适用于文本文件。例如，<code>FileReader</code>和<code>FileWriter</code>。字符流使用了字符集，可以更好地处理文本文件中的字符编码。</li>
</ul>
</li>
<li><p><strong>节点流和包装流：</strong></p>
<ul>
<li><strong>节点流：</strong> 直接连接到数据源或目标的流。例如，<code>FileInputStream</code>和<code>FileOutputStream</code>。</li>
<li><strong>包装流（或处理流）：</strong> 对节点流进行包装，提供额外的功能，如缓冲、压缩、解压等。例如，<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>。</li>
</ul>
</li>
<li><p><strong>字符集和编码：</strong></p>
<ul>
<li>字符流使用字符集来处理字符编码，以确保正确的字符转换。</li>
<li>常见的字符集包括UTF-8、UTF-16、ISO-8859-1等。</li>
</ul>
</li>
<li><p><strong>处理流的装饰器模式：</strong></p>
<ul>
<li>处理流通常通过装饰器模式实现。你可以通过组合多个处理流，以获得更丰富的功能。</li>
</ul>
</li>
<li><p><strong>对象流：</strong></p>
<ul>
<li><code>ObjectInputStream</code>和<code>ObjectOutputStream</code>允许直接读写Java对象。这对于序列化和反序列化对象很有用。</li>
</ul>
</li>
<li><p><strong>标准I&#x2F;O：</strong></p>
<ul>
<li><code>System.in</code>、<code>System.out</code>和<code>System.err</code>分别代表标准输入、标准输出和标准错误输出。这些流通常用于从控制台读取输入和输出结果。</li>
</ul>
</li>
<li><p><strong>try-with-resources：</strong></p>
<ul>
<li>Java 7引入了<code>try-with-resources</code>语句，使得资源的管理更加简便。可以在<code>try</code>语句中自动关闭实现<code>AutoCloseable</code>接口的资源。</li>
</ul>
</li>
</ol>
<h2 id="Java错误和异常"><a href="#Java错误和异常" class="headerlink" title="Java错误和异常"></a>Java错误和异常</h2><p>在 Java 中，错误（Errors）和异常（Exceptions）是用于处理程序运行期间出现的问题的机制。它们都是从 <code>Throwable</code> 类派生的，但在处理方式和用途上有所区别。下面是对 Java 错误和异常的总结：</p>
<ol>
<li><p><strong>错误（Errors）</strong>：</p>
<ul>
<li>错误表示严重的问题，通常是无法恢复的情况，例如虚拟机错误、系统错误、内存溢出等。</li>
<li>错误由 JVM 抛出，并且一般<strong>不应该被程序捕获和处理</strong>。</li>
<li><code>Error</code> 类及其子类是用于表示错误的类型，例如 <code>OutOfMemoryError</code>、<code>StackOverflowError</code> 等。</li>
</ul>
</li>
<li><p><strong>异常（Exceptions）</strong>：</p>
<ul>
<li>异常是程序在运行过程中遇到的非正常情况，<strong>可以被捕获和处理</strong>，以便程序继续执行。</li>
<li>异常分为两种类型：<strong>已检查异常</strong>（Checked Exceptions）和<strong>运行时异常</strong>（Unchecked Exceptions）。</li>
<li>已检查异常是在编译时强制要求处理的异常，例如 <code>IOException</code>、<code>SQLException</code> 等。对于已检查异常，要么在方法中使用 <code>throws</code> 声明抛出，要么使用 <code>try-catch</code> 块进行捕获和处理。</li>
<li>运行时异常是指那些可以在运行时检测到的异常，不需要在编译时进行处理。例如，<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code> 等。通常情况下，运行时异常是由程序错误导致的，应该尽量避免发生，但并不强制要求捕获和处理。</li>
</ul>
</li>
</ol>
<p>在处理异常时，可以使用以下几种关键字和机制：</p>
<ul>
<li><code>try-catch</code> 块：用于捕获和处理异常。<code>try</code> 块中放置可能抛出异常的代码，而 <code>catch</code> 块用于捕获和处理对应的异常类型。</li>
<li><code>throws</code> 关键字：用于在方法签名中声明可能抛出的异常类型，将异常传递给调用者处理。</li>
<li><code>finally</code> 块：在 <code>try-catch</code> 块之后使用，用于执行无论是否发生异常都需要执行的代码块，例如资源的释放。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/" class="print-no-link">#笔记</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/28/%E4%BC%A0%E6%92%AD%E7%9A%84%E6%99%BA%E6%85%A7/" title="对话：传播的智慧">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">对话：传播的智慧</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/28/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="Linux基础知识">
                        <span class="hidden-mobile">Linux基础知识</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"b7QF8DOJ3LwBHcove2JrX53N-gzGzoHsz","appKey":"I0gLTGyRnzTDjejPdPuhWozv","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicRibbon.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/runtime.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/snowflake.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
