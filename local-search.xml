<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>🫨INFP恋爱指南 —— 小H同学</title>
    <link href="/2024/11/04/%E6%81%8B%E7%88%B1%E6%8C%87%E5%8D%97%E4%B9%8BINFP/"/>
    <url>/2024/11/04/%E6%81%8B%E7%88%B1%E6%8C%87%E5%8D%97%E4%B9%8BINFP/</url>
    
    <content type="html"><![CDATA[<h2 id="一条龙指导之如何谈到甜甜的恋爱——以INFP为例🤔"><a href="#一条龙指导之如何谈到甜甜的恋爱——以INFP为例🤔" class="headerlink" title="&gt;&gt;&gt; 一条龙指导之如何谈到甜甜的恋爱——以INFP为例🤔"></a>&gt;&gt;&gt; 一条龙指导之如何谈到甜甜的恋爱——以INFP为例🤔</h2><span id="more"></span><h1 id="💡MBTI-概览"><a href="#💡MBTI-概览" class="headerlink" title="💡MBTI 概览"></a>💡MBTI 概览</h1><ul><li>精力支配：外向 E — 内向 I　</li><li>认识世界：实感 S — 直觉 N</li><li>判断事物：思维 T — 情感 F</li><li>生活态度：判断 J — 知觉 P</li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104010303515.png" alt="what is your mbti"></p><h1 id="⭐结合日常表现分析人格特点"><a href="#⭐结合日常表现分析人格特点" class="headerlink" title="⭐结合日常表现分析人格特点"></a>⭐结合日常表现分析人格特点</h1><blockquote><p>以下场景均基于同一前提：小 C 是一位典型的 INFP，或者说具有代表大部分 INFPs 的特性</p></blockquote><ul><li><strong>慢热（Slow to Warm Up）</strong>：INFP通常是内向的，他们需要时间来建立信任和亲密感。他们可能需要更多的时间来了解潜在的伴侣，这使得他们很难迅速进入一段恋爱关系。</li></ul><blockquote><p>小 H 和 小 C 认识一年了，小 H 心里已经认为 小 C 是很熟很熟的朋友了，但 小 C 其实觉得 <em><strong>不熟</strong></em></p></blockquote><ul><li><strong>深度连接的需求（Need for Deep Connection）</strong>：INFP寻求深度的情感和精神连接。他们希望找到一个能够理解他们内心世界的人，这种高标准可能使得他们很难找到合适的伴侣。</li><li><strong>敏感性（Sensitivity）</strong>：INFP对批评和拒绝非常敏感，这种敏感性可能让他们在恋爱关系中感到脆弱，因此他们可能会因为害怕受伤而避免开始新的关系。</li><li><strong>理想化（Idealism）</strong>：INFP倾向于理想化爱情和伴侣，这可能导致他们对潜在伴侣有不切实际的期望，当现实与期望不符时，他们可能会选择不开始这段关系。</li></ul><blockquote><p>类似的，小 C 不仅对伴侣有较理想化的期待，有时还可能会对自己也有较理想化的期待，TA 会因为对自己不自信而害怕开启一段关系。</p></blockquote><ul><li><strong>独立性（Independence）</strong>：INFP重视他们的独立性和个人空间，他们可能会担心恋爱关系会限制他们的自由，这种担忧可能会阻碍他们开始一段关系。</li><li><strong>难以表达需求（Difficulty Expressing Needs）</strong>：INFP可能在表达自己的需求和愿望时遇到困难，这可能导致潜在的伴侣难以理解他们，从而阻碍关系的进展。</li></ul><blockquote><p>小 C 不是不会表达，但是 TA 喜欢自己在脑子里大量演算，然后往往会得出一些不利于关系发展的结论</p></blockquote><ul><li><strong>对和谐的需求（Need for Harmony）</strong>：INFP非常重视和谐和平衡，他们可能会为了避免不和谐而推迟表达自己的感情，这可能会让他们错过开始一段关系的机会。</li><li><strong>情感波动（Emotional Intensity）</strong>：INFP可能会经历强烈的情感波动，这可能会让潜在的伴侣感到不知所措，从而影响关系的开始。</li></ul><blockquote><p>需要提到的是，小 C 只会在 TA 认为的<strong>熟人</strong>面前发疯</p></blockquote><ul><li><strong>自我牺牲（Self-Sacrifice）</strong>：INFP可能会在关系中过度牺牲自己以保持和谐，这可能会让他们在开始新关系之前就感到疲惫和不安。</li></ul><p>总结一下 INFP 感情路上的内在阻碍： <code>#慢热</code> <code>#矛盾</code> <code>#偶尔发疯</code> <code>#内耗</code></p><h1 id="🌙结合人格特性分析自我处境"><a href="#🌙结合人格特性分析自我处境" class="headerlink" title="🌙结合人格特性分析自我处境"></a>🌙结合人格特性分析自我处境</h1><blockquote><p>INFP 在开始关系前会经历什么？</p></blockquote><blockquote><p>INFPs 经常会感到孤独和抑郁。我们经常因为看待世界的方式而感到孤独和隔离。我们的主导Fi使我们保持我们深刻持有的价值观和感受私密且不可见。这是因为Fi是个体化的，我们的主观体验与世界其他部分脱节。我们经常在我们的思想和内心世界中感到孤立，并且努力表达它们并使它们为人所知。有时，我的孤独和抑郁也源于感到完全迷失；我经历了存在危机，与我与世界的关系失去了联系。其他时候，当我被误解我的人包围时，我感到孤立，并且对我内心最深处的想法和感受漠不关心。</p></blockquote><h2 id="在个人方面"><a href="#在个人方面" class="headerlink" title="在个人方面"></a>在个人方面</h2><p>一位 INFP 朋友：我觉得我现在做的事情都特别没有意义，我会提不起兴趣去做，虽然如果我努力的话可以 hold 住，但我就是会觉得很无聊。</p><p>From Internet：我经常在开始着手做某一件事之前充分考虑它本身的意义，如果我找不到一个很好的理由（比如达成目标之后对自己的推进作用），我就几乎永远不会开始。</p><h2 id="与外界关系方面"><a href="#与外界关系方面" class="headerlink" title="与外界关系方面"></a>与外界关系方面</h2><p>INFP 渴望知己，但 TA 的心流决定了 TA 难以感受到与其他人的共鸣。因为 INFP 过多地倾向于在主观体验层面思考，即使是两个 INFP 也不一定能知道彼此心里到底在想什么。</p><p>一旦 INFP 对某些事物形成了自己的判断，一般就不会轻易发生改变，因为这一切都仅仅发生在 INFP 心里，只要 TA 不说，nobody knows，nothing changes。</p><blockquote><p>INFPs 可能发现自己在两种陷阱之间挣扎：我们很难找到我们的灰姑娘或白马王子，或者最终陷入有毒的关系。因为我们高度理想化，我们可能对约会有不切实际的期望。同时，我们是斗士，想要拯救他人。在这样做的过程中，我们可能最终陷入不健康的关系，吸引自恋者和其他有毒个体，他们利用我们无条件的同理心。</p></blockquote><p>总结一下 INFP 在面对亲密关系时的处境： <code>#从不主动</code> <code>#孤独</code> <code>#矜持</code> <code>#挣扎</code>;</p><h1 id="🔍寻找潜在的发展对象"><a href="#🔍寻找潜在的发展对象" class="headerlink" title="🔍寻找潜在的发展对象"></a>🔍寻找潜在的发展对象</h1><ul><li><strong>David Keirsey‘s Opposites Attract 模型</strong></li></ul><blockquote><ul><li><strong>对立吸引模型</strong>：每种性格类型的理想伴侣是其 <em><strong>完全相反</strong></em> 的类型</li></ul><blockquote><p>In this update, Keirsey seemed to highlight the importance of matching couples on their perceiving preferences, perhaps so they would see things in the same way, but it mismatches them in some areas to create attraction and interest.</p></blockquote><ul><li><strong>修正版匹配模型</strong>：建议匹配第二字母，错配第三和第四字母</li></ul></blockquote><ul><li><strong>Terence Duniho’s 兼容性模型</strong>：匹配类型代码的前两个字母，并在最后两个字母上进行不匹配</li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104011503244.png"></p><ul><li><strong>John Beebe’s 匹配模型</strong></li></ul><blockquote><p><strong>Inverse Relationships 模型</strong>：Beebe将没有共同字母的配对称为“逆向关系”，因为这些配对的意识偏好顺序相同，但是顺序相反。<br><strong>“1 + 5” 吸引力模型</strong>：Beebe提出，当一个人遇到另一个人的主导功能恰好是自己的第五功能时，可能会产生强烈的吸引力。这种配对在功能堆栈中的位置形成了一种特定的动态，其中两个个体在彼此的主导和第五功能之间形成了一种互补的关系。eg：INFP &amp; INFJ<br><strong>辅助功能支持模型</strong>：Beebe还提到，我们使用辅助功能来支持他人，这可能导致我们陷入共依赖的关系。INFP的辅助功能是外倾直觉（Ne），能够支持他们辅助功能的人为 ENFP 或 ENTP。</p></blockquote><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104011429727.png"></p><blockquote><p><strong>🖊 Carl Jung 的心理类型理论</strong><br>荣格的理论后来被伊莎贝尔·布里格斯·迈尔斯（Isabel Briggs Myers）进一步发展，形成了MBTI（迈尔斯-布里格斯类型指标）人格类型理论。这些“过程”或“功能”是指人们如何接收和处理信息，以及如何做决定的内在心理机制。</p><ul><li><strong>四个基本功能（Four Basic Functions）</strong>：<ul><li><strong>Thinking（思考）</strong>：逻辑判断，基于客观标准做决策。</li><li><strong>Feeling（情感）</strong>：价值判断，基于个人价值和情感做决策。</li><li><strong>Sensing（感知）</strong>：通过五官接收信息，关注现实和细节。</li><li><strong>Intuition（直觉）</strong>：通过第六感接收信息，关注可能性和潜在意义。</li></ul></li><li><strong>八个功能态度（Eight Function-Attitudes）</strong>： 荣格和迈尔斯的理论进一步细分了这些基本功能，考虑了它们是内向（Introverted）还是外向（Extraverted）的态度，从而形成了八个不同的功能态度：<ul><li><strong>Extraverted Sensing（外向感知） - Se</strong></li><li><strong>Introverted Sensing（内向感知） - Si</strong></li><li><strong>Extraverted Intuition（外向直觉） - Ne</strong></li><li><strong>Introverted Intuition（内向直觉） - Ni</strong></li><li><strong>Extraverted Thinking（外向思考） - Te</strong></li><li><strong>Introverted Thinking（内向思考） - Ti</strong></li><li><strong>Extraverted Feeling（外向情感） - Fe</strong></li><li><strong>Introverted Feeling（内向情感） - Fi</strong></li></ul></li></ul><p>这些功能态度在每个人格类型中都以特定的顺序出现，形成了一个认知功能堆栈。每个人格类型都有一个主导功能，其次是辅助功能，然后是第三和第四功能，以及更不发达的第五到第八功能。这些功能的不同组合和顺序影响个体如何与世界互动，以及他们倾向于关注什么和如何做决策。</p></blockquote><ul><li><strong>McAlpine’s 匹配模型</strong></li></ul><blockquote><ul><li><strong>Opposing Personality 模型</strong>：在这个模型中，一个 INFP（Fi-Ne-Si-Te）的对立个性将是 ENFJ（Fe-Ni-Se-Ti）模式，这两个模式的所有八个过程都完全不匹配。</li><li><strong>Dynamic Opposite 模型</strong>：在这个配对中，INFP的动态对立将是ISTP（Ti-Se-Ni-Fe）。</li></ul></blockquote><h1 id="🏃‍对症下药追寻爱情"><a href="#🏃‍对症下药追寻爱情" class="headerlink" title="🏃‍对症下药追寻爱情"></a>🏃‍对症下药追寻爱情</h1><p>你已经完全理解自己谈不到甜甜的恋爱的原因了，而且你还知道了自己的理想型应该是什么样的，那么就开始实战吧！！</p><ul><li><strong>主动一点</strong>：克服内心的犹豫和恐惧，尝试更加主动地表达自己的感受和兴趣。这可能意味着需要鼓起勇气去发起对话或邀请潜在的伴侣进行约会。</li><li><strong>寻找共同点</strong>：识别和潜在伴侣之间的共同兴趣和价值观，这有助于建立初步的联系和共鸣。</li><li><strong>深度对话</strong>：与他人进行深入的、有意义的对话，这是INFP建立情感联系的重要方式。</li><li><strong>诚实和开放</strong>：在关系中保持诚实和开放，尤其是在表达自己的需求和感受时。这有助于建立信任和理解。</li><li><strong>慢慢来</strong>：一步一步逐渐建立关系，而不是急于求成。这有助于INFP感到更舒适，同时也给对方足够的时间去了解和欣赏INFP的独特性。</li><li><strong>自我反思</strong>：在开始关系之前，花时间进行自我反思，了解自己真正想要的是什么，以及自己在关系中的需求和期望。</li><li><strong>接受不完美</strong>：理解并接受没有完美的关系或伴侣，学会欣赏伴侣的独特性和不完美之处。</li><li><strong>平衡理想与现实</strong>：虽然INFP倾向于理想化关系，但也需要学会在现实世界中寻找和培养关系，这意味着要接受现实中的妥协和挑战。</li><li><strong>处理冲突</strong>：学习如何以健康的方式处理冲突，而不是回避。这对于维持长久的关系至关重要。</li></ul><h1 id="🥂维系与发展关系"><a href="#🥂维系与发展关系" class="headerlink" title="🥂维系与发展关系"></a>🥂维系与发展关系</h1><p>看完分享之后，你茅塞顿开，当天晚上就鼓起勇气向 crush 表白，结果人家居然真的答应了！！可是激动过后，你作为典型 INFP，开启了焦虑的一晚……</p><p><del>你突然想起 HX 说他提供的是一条龙指导，你再次打开他的分享，小贺文档，为你的爱情保驾护航！！！</del></p><p>以下表述均基于同一前提：你们之间的感情纯粹、炽热且忠诚</p><p>首先你需要相信，你们之所以走到了一起，抛开命中注定不谈，一定是有很多相互吸引的地方，不要总是想，不要总是想，不要总是遇到事情就想对方是不是不喜欢自己了！！！</p><p>你更需要关注的是你们之间某些不容易磨合的矛盾，请务必注重<strong>解决问题</strong>而不是干其他任何对解决问题没有实质性帮助的事情（比如争论问题的性质，或者自己在脑子里想一些有的没的然后得出一个肯定让你自己不开心的结论）</p><p>沟通！沟通！！沟通！！！只要你们积极沟通，这个世界上就没有东西可以把你们分开！！！不要！不要！！不要！！！把问题留到不可弥合之际再去处理，今日事今日毕，不要吵隔夜架。</p><h1 id="💞谈谈恋爱"><a href="#💞谈谈恋爱" class="headerlink" title="💞谈谈恋爱"></a>💞谈谈恋爱</h1><blockquote><p>中国教育三大缺口：关于生死，关于爱，关于性</p></blockquote><p>当你心中浮现对恋爱的向往和表白的冲动时，你到底在想些什么？</p><ul><li>牡丹太久，饥渴难耐</li><li>crush 让你辗转反侧彻夜难眠</li></ul><p>你为什么会纠结要不要表白？</p><ul><li>害怕被拒绝</li><li><del>爱情不是占有</del></li><li>还没有想好我们是否般配</li></ul><p>我以为，爱情的主基调其实是 &#x3D;&#x3D;<em><strong>迫不得已</strong></em>&#x3D;&#x3D;</p><p>祝愿大家都能谈到甜甜的恋爱，长生不老，永远不死🥳</p><h1 id="📕参考文献"><a href="#📕参考文献" class="headerlink" title="📕参考文献"></a>📕参考文献</h1><p><a href="https://not.exist.page/HXavier">The Research of INFP&#x2F;J Friends</a></p><p><a href="https://books.google.com.sg/books?hl=zh-CN&lr=&id=RFnTEAAAQBAJ&oi=fnd&pg=PA5&dq=infp+love+relationships&ots=S58spag1Mz&sig=DUGKYJmFn94IRDAlME-MeEKBefE&redir_esc=y#v=onepage&q=infp%20love%20relationships&f=false">The INFP Book: The Perks, Challenges, and Self-Discovery of an INFP</a></p><p><a href="https://d1wqtxts1xzle7.cloudfront.net/16063494/relationships-libre.pdf?1390864694=&response-content-disposition=inline;+filename=Relationship_Type_Combinations.pdf&Expires=1730450307&Signature=VvbgWTjOz26Seyr4ZnMJ0MNKz0KAeu4VKVhX-VXK1UrPCjQaCUnu~32OX15JpySPRceHOOJM-OrmAP6OG-VLt5xH1F0eACUZ-591YBj70WcdmNzoIzNv89ZJ~rLdB6Kim~YxvvoUF6KVhiYLvQZCkfaGGy93KmztRbY6z6g6fTP5MDbNKSryUKVLftrC1ySBJoWuX~JBE1pEQspXgGed67aP6LiR-cX2~BdqG9iK7eSzvk4LqMB3DEr8VTKLyl9OSslFGWWmFPyYtglOsmXq-QEirdeVnjBlxIPQ5ubkkTJJzYmbUAphoBstiagRkl0TbX-aKfq4ekQiCkM6KyVktw__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA">Relationship Type Combinations</a></p><p><a href="https://books.google.com.sg/books?hl=zh-CN&lr=&id=d6i_CwAAQBAJ&oi=fnd&pg=PT5&dq=infp+love+relationships&ots=MIGTIn701K&sig=bNKiBMVHo2RDjdF3aVt_AmWwGgE&redir_esc=y#v=onepage&q=infp%20love%20relationships&f=false">The Idealist: Your Guide to the INFP Personality Type</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>repoCodeGen🤖</title>
    <link href="/2024/10/20/repoCodeGen%20papers/"/>
    <url>/2024/10/20/repoCodeGen%20papers/</url>
    
    <content type="html"><![CDATA[<h1 id="repoCodeGen"><a href="#repoCodeGen" class="headerlink" title="repoCodeGen"></a>repoCodeGen</h1><h3 id="Code-Generation-at-Repository-Level-💻"><a href="#Code-Generation-at-Repository-Level-💻" class="headerlink" title="&gt;&gt;&gt;  Code Generation at Repository-Level 💻"></a>&gt;&gt;&gt;  Code Generation at Repository-Level 💻</h3><span id="more"></span><h3 id="Repository-Level-Prompt-Generation-for-Large-Language-Models-of-Code"><a href="#Repository-Level-Prompt-Generation-for-Large-Language-Models-of-Code" class="headerlink" title="Repository-Level Prompt Generation for Large Language Models of Code"></a>Repository-Level Prompt Generation for Large Language Models of Code</h3><h4 id="RLPG"><a href="#RLPG" class="headerlink" title="RLPG"></a>RLPG</h4><blockquote><p> 核心理念是，用代码库中其他部分<strong>替换</strong>默认上下文的一部分。选取什么代码以及从哪里选取是由<strong>提示提案</strong>管理的</p></blockquote><ul><li><strong>提示源</strong>：从何处获取提示提案的上下文代码<ul><li>有十种不同的提示源（父类、导入、兄弟类、相似名称、子类、导入父类、导入兄弟类、导入类似名称、导入子类）</li></ul></li><li><strong>提示上下文类型</strong>：决定从提示源获取何种代码<ul><li>有七种不同的提示上下文类型（所有行、类型标识符、字段声明、字符串字面量、方法名称、方法名和主体）</li></ul></li></ul><h4 id="Prompt-Proposal-Classifier-PPC"><a href="#Prompt-Proposal-Classifier-PPC" class="headerlink" title="Prompt Proposal Classifier (PPC)"></a>Prompt Proposal Classifier (PPC)</h4><blockquote><p>PPC 的目标是预测出能够成功生成目标代码片段的<strong>最佳提示提案</strong>（prompt proposal）</p></blockquote><ul><li><strong>训练过程</strong>：如果某个提示提案能够成功生成目标代码片段，则对应的向量位置为1，否则为 0，通过二元交叉熵损失优化模型参数、</li><li><strong>模型变体</strong>：<ul><li><strong>RLPG-H</strong>：使用预训练模型的表示来预测最有可能成功的提示提案。</li><li><strong>RLPG-R</strong>：使用多头注意力机制来评估洞窗口与提示提案上下文的相似性，从而选择最佳提示。</li></ul></li></ul><h4 id="Prompt-Composer"><a href="#Prompt-Composer" class="headerlink" title="Prompt Composer"></a>Prompt Composer</h4><blockquote><p>作用是组合 最佳提示提案 和 codex 默认上下文 (空白位置之前的代码)</p></blockquote><ul><li><strong>上下文分配</strong>：</li><li><strong>上下文组合</strong></li><li><strong>截断策略</strong></li></ul><h3 id="RepoCoder-–-Repository-Level-Code-Completion-Through-Iterative-Retrieval-and-Generation"><a href="#RepoCoder-–-Repository-Level-Code-Completion-Through-Iterative-Retrieval-and-Generation" class="headerlink" title="RepoCoder – Repository-Level Code Completion Through Iterative Retrieval and Generation"></a>RepoCoder – Repository-Level Code Completion Through Iterative Retrieval and Generation</h3><h4 id="RepoCoder-框架"><a href="#RepoCoder-框架" class="headerlink" title="RepoCoder 框架"></a>RepoCoder 框架</h4><p>一个针对仓库级代码完成任务的新型迭代检索生成框架</p><p><strong>原始 RAG</strong></p><ul><li>使用检索模型 R，使用未完成的代码 X 作为检索查询，从代码片段 C 中提取最相关的信息 **$C &#x3D; R (C, X)$**，再利用语言模型 M 补全代码 <strong>$Y &#x3D; M (C, X)$</strong></li></ul><p><strong>优化后的 RepoCoder</strong></p><ul><li>检索查询不只是未完成的代码 X，还包括**上一次迭代生成的预测代码 $Y^{i-1}$**，即$Y^i &#x3D;M (C, X, Y^{i-1})$</li></ul><h4 id="代码检索"><a href="#代码检索" class="headerlink" title="代码检索"></a>代码检索</h4><ul><li>滑动窗口，每次提取 $S_w$ 行代码，每次滑动固定行数 $S_s$ (滑动大小)</li><li>初始检索过程使用未完成代码最后几行作为查询</li><li>后续迭代都引入上一次迭代生成的代码 $Y^{i-1}$ 作为查询，原代码片段提取 $(S_w-S_s)$ 行，从$Y^{i-1}$ 中提取 $S_s$ 行</li></ul><h4 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h4><ul><li>仓库中检索最相关的代码 $C_{ret}$，并于待补充的代码 $X$ 进行拼接</li><li>有一个提示模板，将 $C_{ret}$ 和 $X$ 无缝拼接</li><li>检索到的代码按照相似度排序，用于提示的代码片段有最大数量 $K$</li></ul><h4 id="基准构建"><a href="#基准构建" class="headerlink" title="基准构建"></a>基准构建</h4><p>一种新的 <strong>RepoEval 基准</strong>，使用从 Github 获取的最新高质量仓库，评估涵盖代码完成度的<strong>三个层次</strong>：</p><ul><li><strong>行</strong></li><li><strong>API 调用</strong></li><li><strong>函数体完成</strong></li></ul><h4 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h4><blockquote><p>这些分析不仅帮助理解了RepoCoder的工作原理，也为未来的研究方向提供了指导</p></blockquote><p><strong>代码质量</strong></p><ul><li>包含与目标补全相似的代码语句或展示目标API调用示例的代码片段通常最有用</li></ul><p><strong>检索代码位置</strong></p><ul><li>“相似导入”、“相似名称”或“当前目录”位置的文件提取代码效果良好</li></ul><h3 id="Guiding-Language-Models-of-Code-with-Global-Context-using-Monitors"><a href="#Guiding-Language-Models-of-Code-with-Global-Context-using-Monitors" class="headerlink" title="Guiding Language Models of Code with Global Context using Monitors"></a>Guiding Language Models of Code with Global Context using Monitors</h3><h4 id="LMs-常出现的错误："><a href="#LMs-常出现的错误：" class="headerlink" title="LMs 常出现的错误："></a><strong>LMs 常出现的错误：</strong></h4><p>如果需要引用在训练过程中<strong>未见过的类型或API</strong>，会出现错误</p><p>缺乏对上下文的理解，无法正确处理<strong>跨文件或跨模块</strong>的代码依赖</p><ul><li><code>symbol not found</code>没有相关信息，LMs 会出现臆想和幻觉</li><li><code>complile-time-errors</code>    编译时错误，例如使用错误数量的参数时“实际和形式参数列表长度不符”</li><li><code>runtime errors</code>    运行时错误，例如违反 API 协议</li></ul><h4 id="语言服务器协议-LSP"><a href="#语言服务器协议-LSP" class="headerlink" title="语言服务器协议 LSP"></a><strong>语言服务器协议 LSP</strong></h4><ul><li><p>LSP 旨在提供特定于语言的智能，并通过支持进程间通信的协议与开发工具进行通信，这样单个 LSP 可以在多个开发工具中使用</p></li><li><p>LSP 相当于在中间层做一个抽象，让语言的「静态分析服务」和「编辑器 &#x2F; IDE」分离开来</p></li><li><p>本文就是专注通过 LSP 以<strong>语言无关</strong>的方式提供的类型导向代码完成分析</p></li></ul><h4 id="监视引导解码"><a href="#监视引导解码" class="headerlink" title="监视引导解码"></a>监视引导解码</h4><ul><li>集成开发环境 IDEs 主要是在开发的<strong>不完整代码上应用静态分析</strong>，使用增量解析和语义分析算法对部分代码进行解析</li><li><strong>部分抽象语法树</strong>：带有特殊节点（表示代码不完整部分）的不完整抽象语法树</li><li><strong>监视器（Monitor）</strong>：LMs 和静态分析之间的接口，观察 LM 生成的代码并在预定义的触发点查询静态分析。<ul><li>触发条件</li><li>状态更新函数</li><li>掩码生成函数</li><li>静态分析</li></ul></li><li><strong>解码过程</strong>：一般解码过程是根据 LM 生成的 logits 概率分布进行 token 采样，如果 monitor 处于非等待状态，静态分析生成的掩码会调整 logits 从而影响采样</li><li><strong>掩码生成</strong>：识别与当前静态分析建议一致的 token。当一个 token 被采样，监视器会更新状态和建议</li></ul><h4 id="总体性研究"><a href="#总体性研究" class="headerlink" title="总体性研究"></a>总体性研究</h4><ul><li>MGD 中的监控器可以围绕 LSP 的特定语言实例化，不需要更改静态分析接口，支持新语言很容易</li><li>MGD 会在特定情况下触发，这里就需要判定<strong>触发静态分析的情况</strong>，如下情况可以予以考虑：<ul><li><strong>变量和符号</strong><ul><li>跟踪局部和全局变量的定义和使用</li><li>识别变量的作用域和生命周期</li></ul></li><li><strong>函数和方法</strong><ul><li>分析函数签名，包括参数列表和返回类型（文中就提到了基于堆栈的监视器，指导生成正确数量的参数）</li><li>检查函数调用的正确性和参数匹配</li></ul></li><li><strong>类和对象</strong><ul><li>分析类的结构，包括属性、方法和继承关系</li><li>检查对象的实例化</li></ul></li><li><strong>模块和导入</strong><ul><li>追踪导入的模块和符号</li><li>分析模块依赖关系</li></ul></li></ul></li></ul><h3 id="RepoFusion-Training-Code-Models-to-Understand-Your-Repository"><a href="#RepoFusion-Training-Code-Models-to-Understand-Your-Repository" class="headerlink" title="RepoFusion-Training Code Models to Understand Your Repository"></a>RepoFusion-Training Code Models to Understand Your Repository</h3><h4 id="Fusion-in-Decoder"><a href="#Fusion-in-Decoder" class="headerlink" title="Fusion-in-Decoder"></a>Fusion-in-Decoder</h4><ul><li>将周围上下文附加到仓库上下文，分别编码并组合以生成目标空缺的预测</li></ul><h4 id="Repository-Contexts"><a href="#Repository-Contexts" class="headerlink" title="Repository Contexts"></a>Repository Contexts</h4><blockquote><p>该部分和第一篇论文 Repository-Level Prompt Generation for Large Language Models of Code 思想大致相同</p></blockquote><ul><li><strong>提示提案上下文 (PPC)</strong><ul><li>提示提案上下文是通过提取来自特定类别的相关源文件的特定类型的上下文创建</li><li>它是由一个提示提案函数生成的</li><li>提示上下文类型的示例包括目标孔后面的行、方法名称和主体、标识符、字符串文字等</li><li>包括 prior PPC 和 post PPC</li></ul></li><li><strong>提示源</strong><ul><li>提示源的示例包括当前文件、导入到当前文件的文件、与当前文件同名的文件等</li></ul></li></ul><h4 id="RepoFusion"><a href="#RepoFusion" class="headerlink" title="RepoFusion"></a>RepoFusion</h4><blockquote><p>核心理念是训练一个代码模型，使其能够识别仓库中的上下文，帮助目标空缺的代码生成</p></blockquote><ul><li>从提示提案 (PPC) 生成 仓库上下文 (PC)，然后某种顺序拼接</li><li>有四种策略 T-Rank、T-Rand、NT-Rank、NT-Prior-Last</li></ul><h3 id="REPOEXEC-Evaluate-Code-Generation-with-a-Repository-Level-Executable-Benchmark"><a href="#REPOEXEC-Evaluate-Code-Generation-with-a-Repository-Level-Executable-Benchmark" class="headerlink" title="REPOEXEC-Evaluate Code Generation with a Repository-Level Executable Benchmark"></a>REPOEXEC-Evaluate Code Generation with a Repository-Level Executable Benchmark</h3><p><strong>关于LMs 代码生成能力的评估</strong></p><p>​作者提出了一个评估代码生成模型能力的方法，主要侧重于<strong>生成可执行和功能正确的代码的能力</strong>，这也是评估方法的两个难点，也是推动开发更强大可靠的代码生成模型的灵感来源。</p><p>​可执行的代码，即能够在实际环境中运行的代码，评估可执行性需要评估代码生成模型是否能识别和映射代码中的依赖项，并且确保依赖项被正确整合到生成的代码中。</p><p>​正确性，就是代码按照预期功能正确执行。这需要高覆盖率的测试用例来测试代码的正确性，检查其是否通过测试用例，衡量其是否可以完成各种预定任务。</p><p>​这虽然是评估生成代码模型能力的方法需要考虑的因素，其实也给代码生成模型的后续优化提供了思路。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>UIDP</category>
      
      <category>repoCodeGen</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UIDP🔍</title>
    <link href="/2024/10/20/UIDP%20papers/"/>
    <url>/2024/10/20/UIDP%20papers/</url>
    
    <content type="html"><![CDATA[<h1 id="UIDP"><a href="#UIDP" class="headerlink" title="UIDP"></a>UIDP</h1><h3 id="Dark-Patterns-of-UI-📱"><a href="#Dark-Patterns-of-UI-📱" class="headerlink" title="&gt;&gt;&gt; Dark Patterns of UI 📱"></a>&gt;&gt;&gt; Dark Patterns of UI 📱</h3><span id="more"></span><h2 id="The-Dark-Patterns-Side-of-UXDesign"><a href="#The-Dark-Patterns-Side-of-UXDesign" class="headerlink" title="The Dark (Patterns) Side of UXDesign."></a>The Dark (Patterns) Side of UXDesign.</h2><blockquote><p>这一篇应该是暗模式领域的奠基之作，第一作者是后续文章会多次引用到的提出五种策略的 Gray，他提出五种主要的暗模式，提出了许多亟待思考的问题</p></blockquote><h3 id="论文贡献"><a href="#论文贡献" class="headerlink" title="论文贡献"></a>论文贡献</h3><ul><li>描述并分析了暗模式的实例，为学术界定义这一个由日常生活实践者界定的现象</li><li>进一步研究了用户体验中可能存在的道德问题，比如操纵、欺骗等不正常现象</li><li>识别暗模式的含义和用户体验实践者的道德责任之间的关系</li></ul><h3 id="设计用户体验中的伦理学"><a href="#设计用户体验中的伦理学" class="headerlink" title="设计用户体验中的伦理学"></a>设计用户体验中的伦理学</h3><p>设计师在设计用户体验时，应该更多地考虑到伦理道德的问题，并且要找到一些实际可行的方法，把这些伦理道德的考虑融入到设计中去。这样，我们在使用各种应用和服务的时候，就能有更好的体验，不会被那些不太诚实的设计所困扰。</p><h3 id="我们的实验方法"><a href="#我们的实验方法" class="headerlink" title="我们的实验方法"></a>我们的实验方法</h3><p><strong>语料库生成</strong></p><ul><li>之前已有 Brignull 收集的众多例子，构成基础语料库并且提供基本的分类方法</li><li>本实验的研究人员还迭代地扩大了互联网搜索的关键词集，找到更多未标记的暗模式可能存在的案例</li></ul><p><strong>分析</strong></p><ul><li>使用 Brignull 分类法有一些策略和动机的重叠，并且有的类别不直接平行</li><li>需要对语料库的所有示例进行第二次分析，采用开放式编码方法，以 <strong>Brignull 分类法</strong>为基准，同时强调互动质量、上下文、目标用户群体等方面，把重点转向了<strong>设计师的策略和潜在设计动机</strong></li></ul><h3 id="五种主要的暗模式"><a href="#五种主要的暗模式" class="headerlink" title="五种主要的暗模式"></a><img src="/../img/UIDP.png">五种主要的暗模式</h3><p><strong>NAGGING</strong></p><ul><li>正常交互过程的反复干扰</li><li>遮挡界面的弹出窗口、分散用户注意力的音频通知等</li></ul><p><strong>OBSTRUCTION</strong></p><ul><li>阻碍用户完成特定的任务</li><li>不付费无法使用特定功能、阻碍用户关闭广告通知</li></ul><p><strong>SNEAKING</strong></p><ul><li>隐藏一些对用户有害的行为</li><li>声明中隐藏有侵犯隐私的条款、购物车添加用户未选择的商品</li></ul><p><strong>INTERFACE INTERFERENCE</strong></p><ul><li>特定界面设计干扰用户的重要操作</li><li>隐藏信息（将相关信息隐藏成无关信息）、预选（用户交互之前选项默认被选择）、美学操作（转移用户注意力而忽视功能）</li></ul><p><strong>FORCED ACTION</strong></p><ul><li>用户为了访问特定功能被要求执行特定动作</li><li>windows 强制更新、</li></ul><h3 id="更多思考"><a href="#更多思考" class="headerlink" title="更多思考"></a>更多思考</h3><ul><li>虽然有些暗模式初衷并非黑暗，但给用户带来的实际效果的确是黑暗的</li><li>使用者可能并不能正确识别暗模式，一些正常设计会因为自身疏忽被贬低为暗模式</li><li>“暗”的边界不好界定，因为设计师和用户之间的视角权衡会存在差异</li><li>需要提供用户反馈，让实践者参与设计过程中，用体验说话</li><li>潜在发展方向：<ul><li>用户体验实践者需要有更统一的决策界限</li><li>人机交互领域需要更多考虑实践者的需要、限制和愿望</li></ul></li></ul><blockquote><p>这个领域应该是一个交叉领域，需要有社会学伦理学等人文领域的技术加持，需要研究者同时具有人机交互知识和道德伦理思想</p><p>对于这种涉及社科方面的领域，我认为需要更多的社会调研、用户反馈，更广泛的暗模式案例</p><p>个人感觉这个领域没有什么明确的暗模式划分和明显的技术突破，就是需要逐步完善，逐步调整，在大基数用户中获得一个比较能接受的利益和道德的折衷评价，把学术社区和用户体验实践者更好地联系起来</p></blockquote><h2 id="Ul-Dark-Patterns-and-Where-to-Find-Them-A-Study-on-Mobile-Applicationsand-User-Perception"><a href="#Ul-Dark-Patterns-and-Where-to-Find-Them-A-Study-on-Mobile-Applicationsand-User-Perception" class="headerlink" title="Ul Dark Patterns and Where to Find Them-A Study on Mobile Applicationsand User Perception."></a>Ul Dark Patterns and Where to Find Them-A Study on Mobile Applicationsand User Perception.</h2><blockquote><p>本文结合以前的暗模式分类工作，进一步结合了用户的感知能力进行实验</p></blockquote><h3 id="实验方法"><a href="#实验方法" class="headerlink" title="实验方法"></a>实验方法</h3><ul><li><p><strong>分析了流行应用中的黑暗模式</strong>：研究者们检查了240个在Google Play商店中流行的移动应用，看看这些应用中有多少使用了故意误导用户的黑暗模式。</p></li><li><p><strong>进行了用户感知实验</strong>：一个在线实验，邀请了589个用户来看应用的操作视频，然后询问他们是否能识别出视频中的黑暗模式，帮助研究者们了解了用户对这些黑暗模式的感知能力。</p></li><li><p><strong>提供了数据集</strong>：一个公开的数据集，里面包含了他们分析的每个应用和黑暗模式的分类信息</p></li></ul><h3 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h3><ol><li><strong>提高用户意识</strong>：可以通过教育和宣传活动，提高用户对黑暗模式的认识，让他们在使用应用时更加警觉。</li><li><strong>开发识别工具</strong>：可以开发自动化的工具，帮助用户识别出应用中的黑暗模式，或者在应用商店中筛选出那些使用黑暗模式的应用。</li><li><strong>进一步研究黑暗模式的影响</strong>：可以更深入地研究不同类型的黑暗模式对用户行为的影响，以及它们可能带来的长期后果。</li><li><strong>进一步细化暗模式分类法：</strong>五种分类并不一定完善，可以考虑更多因素，比如地域和文化背景</li><li><strong>改进设计伦理教育</strong>：在设计和计算机科学教育中加入更多关于伦理设计的内容，帮助未来的设计师避免使用黑暗模式。</li><li><strong>继续研究用户感知</strong>：可以进一步研究用户对黑暗模式的感知能力，了解在不同情况下用户如何识别和应对这些模式。</li><li><strong>扩展研究范围</strong>：可以将研究扩展到其他类型的应用或平台，比如付费应用、网站或其他类型的数字服务。</li></ol><h2 id="AidUl-Toward-Automated-Recognition-of-Dark-Patterns-in-User-Interfaces"><a href="#AidUl-Toward-Automated-Recognition-of-Dark-Patterns-in-User-Interfaces" class="headerlink" title="AidUl- Toward Automated Recognition of Dark Patterns in User Interfaces."></a>AidUl- Toward Automated Recognition of Dark Patterns in User Interfaces.</h2><blockquote><p>本文在此前研究成果基础上（暗模式分类、用户意识），开发了一个自动化识别工具，自动化检测用户界面的暗模式</p></blockquote><h3 id="AidUI"><a href="#AidUI" class="headerlink" title="AidUI"></a>AidUI</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul><li>论文提出了<strong>AidUI</strong>，这是一个<strong>自动化方法</strong>，它结合了计算机视觉和自然语言处理技术来识别应用程序截图中的视觉和文本线索</li><li><strong>核心思想</strong>是：存在一些<strong>视觉和文本线索</strong>，当它们共同出现时，表明存在各种暗模式，通过检测这些单独的线索并分析它们的出现，可以克服暗模式的变体给检测带来的挑战</li></ul><h4 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h4><ul><li><p><strong>视觉线索检测</strong>：使用深度学习的对象检测模型如 Faster R-CNN 识别UI中的图标</p><ul><li>图标检测：使用 RICO 数据集，包含大量 Android 设计资源</li><li>映射图标到 DPs：使用预定义的规则将检测的图标映射到 DPs</li></ul></li><li><p><strong>UI及文本内容检测</strong>：提取包含文本和非文本内容的UI段</p><ul><li>对于<strong>文本</strong>检测和提取，使用EAST文本检测模型</li><li>对于<strong>图形</strong> UI，使用无监督边缘检测算法和 CNN</li></ul></li><li><p><strong>DP分析</strong>：应用文本、颜色和空间分析技术来分析提取的UI段，以预测潜在的暗模式</p><ul><li>对于<strong>文本分析</strong>，使用定义的启发式模式匹配规则</li><li>对于<strong>颜色分析</strong>，使用颜色直方图技术</li><li>对于<strong>空间分析</strong>，分析邻域距离、大小、坐标等因素</li></ul></li><li><p><strong>DP解析</strong>：结合视觉线索检测和DP分析阶段的结果，预测给定UI中的底层暗模式，并使用边界框进行定位</p><ul><li><strong>段级别决议</strong>：在邻接段落之间使用投票机制，考虑文本、颜色、空间等因素</li><li><strong>UI级别决议</strong>：考虑段级别决议和视觉线索检测的结果，做出最终预测</li></ul></li></ul><blockquote><p>仅仅基于 UI 屏幕截图的像素数据运行，适用于不同的软件领域</p></blockquote><h2 id="Unveiling-the-Tricks-Automated-Detection-of-Dark-Patterns-in-Mobile-Applications"><a href="#Unveiling-the-Tricks-Automated-Detection-of-Dark-Patterns-in-Mobile-Applications" class="headerlink" title="Unveiling the Tricks- Automated Detection of Dark Patterns in Mobile Applications"></a>Unveiling the Tricks- Automated Detection of Dark Patterns in Mobile Applications</h2><blockquote><p>本文也开发了一个自动检测移动应用暗模式的知识驱动系统，不需要为每个应用手动创建规则，能覆盖更多类型的暗模式</p></blockquote><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ul><li>论文讨论了移动应用中“暗模式”（Dark Patterns）的问题，即通过恶意设计（例如通过预设选项或隐藏信息）来诱骗用户做出违背最佳利益决定的界面元素。</li><li>作者提出了一个名为UIGuard的知识驱动系统，该系统使用计算机视觉和自然语言处理技术来自动检测移动应用中的暗模式。</li><li>UIGuard系统不需要为每个新的应用手动创建规则，能够覆盖更多类型的暗模式，并具有更好的性能。</li></ul><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="已有工作的局限性"><a href="#已有工作的局限性" class="headerlink" title="已有工作的局限性"></a>已有工作的局限性</h4><ul><li>已有的暗模式的策略和类型的识别<strong>存在异质性</strong>和<strong>缺乏一致性</strong></li><li>研究人员的解决暗模式的方案存在局限性<ul><li>众包技术（crowd-sourcing）<ul><li>耗时难以泛化，或者仅限于某些模式</li><li>开发者需要重新打包程序，可能难以扩展</li></ul></li><li>基于文本的分类技术（text-based）<ul><li>需要大量标注数据集来训练模型</li><li>由于仅仅依赖文本很可能产生错误</li></ul></li></ul></li></ul><h4 id="论文工作的先进性"><a href="#论文工作的先进性" class="headerlink" title="论文工作的先进性"></a>论文工作的先进性</h4><ul><li>工作步骤<ul><li>分析并合并了移动平台上现有的暗模式分类，形成一致分类</li><li>对统一的分类进行特征分析，识别关键属性</li></ul></li><li>UIGuard 的组成<ul><li>属性提取器</li><li>知识驱动的暗模式检查器</li></ul></li></ul><h4 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h4><ul><li><strong>暗模式分类</strong><ul><li>2010 Harry Brignull <ul><li>暗模式网站</li></ul></li><li>Gray <ul><li>五种策略：<strong>nagging, obstruction, sneaking, interface interference and forced action</strong></li></ul></li><li>Mathur <ul><li>实证研究购物网站</li><li>五种暗模式特征，六种认知偏差</li></ul></li><li>Di Geronimo<ul><li>16种类型和31个案例</li></ul></li><li>Gunawan<ul><li>研究使用过程的不同阶段</li></ul></li><li><strong>我们</strong><ul><li>研究现有的分类体系，整合成单一且统一的系统</li></ul></li></ul></li><li><strong>暗模式检测</strong><ul><li><strong>手动探索</strong><ul><li>耗时，需要用户具有暗模式知识</li><li>无法捕捉新应用程序的变化</li></ul></li><li><strong>基于半自动聚类的方法</strong><ul><li>模拟用户行为在购物网站识别暗模式</li><li>采用聚类技术将相关UI模式分组</li><li>手动评估聚类</li><li>仍然耗时且难以应用新的UI</li></ul></li><li><strong>基于文本的简单分类方法</strong><ul><li>基于朴素贝叶斯的分类器</li><li>梯度增强树分类器</li><li>基于文本容易出现错误</li></ul></li><li><strong>我们</strong><ul><li>可扩展性：可以用于分析大量应用中的暗模式</li><li>监控新发布的用户界面，移动应用发生变化仍然有效</li><li>轻松集成新的规则和属性识别模块</li></ul></li></ul></li><li><strong>UI理解</strong><ul><li>首次实现对移动UI中的暗模式进行自动化检测</li></ul></li></ul><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><h4 id="Gray-的五种策略"><a href="#Gray-的五种策略" class="headerlink" title="Gray 的五种策略"></a>Gray 的五种策略</h4><ul><li><strong>Nagging</strong><ul><li>重复的中断应用程序操作</li><li>比如弹出不相关的广告或评级</li></ul></li><li><strong>Obstruction</strong><ul><li>让一些事情变得困难来满足公司的利益</li><li>Three Types<ul><li><em>Roach Motel</em>: 容易进，难得出</li><li><em>Price Comparison Prevention：在其他平台无法比较</em></li><li><em>Intermediate</em> <em>Currency</em>：阻止用户通过虚拟货币获得真实货币</li></ul></li></ul></li><li><strong>Sneaking</strong><ul><li>隐藏、欺骗或者延迟和用户有关的信息</li><li>Four Types<ul><li><em>Forced Continuity：</em>购买到期时强迫用户继续购买</li><li><em>Hidden Costs：</em>延迟告知高税收或者运送费等信息</li><li><em>Sneak into Basket：未经用户许可添加一些附加项目</em></li><li><em>Bait and</em> <em>Switch**：给出错误的预期来误导用户</em></li></ul></li></ul></li><li><strong>Interface Inference</strong><ul><li>某些选项置于上方来隐藏信息迷惑用户</li><li>Four Types<ul><li><em>Hidden Information</em>：降低与用户有关信息的可见性</li><li><em>Preselection：默认选择不利的选项</em></li><li><em>Aesthetic Manipulation：</em>利用视觉效果分散用户注意力</li></ul></li></ul></li><li><strong>Forced Action</strong><ul><li>强迫用户执行一些操作</li></ul></li></ul><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="屏幕级别的视角"><a href="#屏幕级别的视角" class="headerlink" title="屏幕级别的视角"></a>屏幕级别的视角</h4><ul><li><strong>静态暗模式</strong><ul><li>仅针对单一用户界面，不依赖于用户的上下文或交互历史</li><li>如坐标、类型、颜色、文本内容和图标语义</li></ul></li><li><strong>动态暗模式</strong><ul><li>依赖于上下文，需要超出当前用户界面的额外信息来识别</li><li>包括之前的UI，触发当前页面或动画效果的元素，以及用户的意图</li></ul></li></ul><h4 id="元素级视角"><a href="#元素级视角" class="headerlink" title="元素级视角"></a>元素级视角</h4><ul><li>识别单一元素的暗色图案<ul><li>单独评估每个元素的属性，如其坐标、包含的文本、颜色、图标语义和元素类型</li></ul></li><li>多元素暗模式<ul><li>分析多个元素的属性</li><li>分析用户界面元素之间的关系</li></ul></li></ul><h4 id="特性识别"><a href="#特性识别" class="headerlink" title="特性识别"></a>特性识别</h4><ul><li>关键特征<ul><li>元素元信息<ul><li>坐标、元素类型</li><li>帮助识别元素的形状和关系</li></ul></li><li>元素的文本内容<ul><li>确定模式的语义</li></ul></li><li>某些类型元素的状态<ul><li>复选框、图标</li><li>识别UI页面的整体含义</li></ul></li><li>背景和文本颜色<ul><li>与视觉模式有关</li></ul></li><li>更高级别的信息<ul><li>相似元素的分组、元素之间的关系</li></ul></li></ul></li></ul><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><h4 id="UI元素属性提取"><a href="#UI元素属性提取" class="headerlink" title="UI元素属性提取"></a>UI元素属性提取</h4><ul><li><strong>UI元素检测</strong><ul><li>使用 Faster-RCNN 来定位和识别UI元素</li></ul></li><li><strong>文本内容提取</strong><ul><li>使用 PaddleOCR 从UI中提取文本</li><li>结果合并，匹配UI元素和文本内容</li></ul></li><li><strong>图标语义</strong><ul><li>使用 Res-18 模型将图标分类为更精细的语义类别</li></ul></li><li><strong>元素状态识别</strong></li><li><strong>颜色提取</strong><ul><li>影响视觉突出性，操纵用户感知</li></ul></li><li><strong>UI元素分组</strong><ul><li>使用基于密度的空间聚类算法 DBSCAN</li><li>比较相关UI元素的视觉显著性</li></ul></li></ul><h4 id="知识驱动的暗模式检查器"><a href="#知识驱动的暗模式检查器" class="headerlink" title="知识驱动的暗模式检查器"></a>知识驱动的暗模式检查器</h4><ul><li>利用常识关联识别</li><li>文本内容、图标含义</li></ul><h3 id="DATASETS-AND-IMPLEMENTATION"><a href="#DATASETS-AND-IMPLEMENTATION" class="headerlink" title="DATASETS AND IMPLEMENTATION"></a><strong>DATASETS AND IMPLEMENTATION</strong></h3><h4 id="深度学习数据集和模型训练"><a href="#深度学习数据集和模型训练" class="headerlink" title="深度学习数据集和模型训练"></a>深度学习数据集和模型训练</h4><ul><li><strong>Rico数据集</strong>：实验的基础数据集，提供了UI的视图层次结构信息，如布局和元素属性</li><li><strong>元素定位数据集</strong>：使用Rico数据集来训练元素定位模型（FasterRCNN），选择了15种Android GUI元素类型作为目标对象，并进行了数据增强以提高模型的鲁棒性</li><li><strong>图标识别数据集</strong>：基于Liu等人的标注，识别了135种图标类型，并进行了数据清洗和增强，以提高图标识别的准确性</li><li><strong>状态识别数据集</strong>：从Rico数据集中提取了特定类型的UI元素（如复选框），并手动标注了它们的状态，用于训练状态识别模型</li></ul><h4 id="暗模式数据集"><a href="#暗模式数据集" class="headerlink" title="暗模式数据集"></a>暗模式数据集</h4><ul><li><strong>数据集构建</strong>：手动标注的一个包含暗模式的UI数据集</li><li><strong>注释过程</strong><ul><li>首先标注UI中存在的暗模式类型</li><li>然后标注这些模式在UI中的具体位置</li></ul></li></ul><h4 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h4><ul><li><strong>模型训练</strong>：使用了多种深度学习模型，包括 FasterRCNN 和 ResNet-18，并对这些模型进行了细致的调整和优化，以适应不同的任务需求</li><li><strong>性能评估</strong>：通过精确度、召回率和F1分数等指标来评估模型的性能</li></ul><h4 id="用户研究"><a href="#用户研究" class="headerlink" title="用户研究"></a>用户研究</h4><ul><li>设计了包括不同背景的58名参与者的用户研究</li><li>通过比较用户自身对暗模式的识别和UIGuard的检测结果，来评估工具的有效性。</li></ul><h3 id="Accuracy"><a href="#Accuracy" class="headerlink" title="Accuracy"></a>Accuracy</h3><h4 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h4><ul><li><strong>RQ1</strong>: 评估UIGuard系统中每个深度学习（DL）模块的准确性。</li><li><strong>RQ2</strong>: 评估UIGuard系统在检测暗模式方面的整体准确性。</li></ul><h4 id="深度学习模块的准确性"><a href="#深度学习模块的准确性" class="headerlink" title="深度学习模块的准确性"></a>深度学习模块的准确性</h4><ul><li><strong>元素定位和分类</strong>：比较了不同的 baseline，包括UIED、FRCNN（非文本）、FRCNN（非文本）结合 PaddleOCR，以及UIGuard模型。使用了精确度、召回率和F1分数作为评估指标。UIGuard在非文本元素检测、文本元素检测和所有元素检测中均表现出较好的性能。</li><li><strong>图标语义理解</strong>：评估了图标识别模块的准确性，发现UIGuard能够以较高的准确率识别图标。</li><li><strong>状态识别</strong>：评估了UI元素状态识别模块的准确性，同样发现UIGuard在这一任务上达到了高精度。</li></ul><h4 id="检测暗模式的准确性"><a href="#检测暗模式的准确性" class="headerlink" title="检测暗模式的准确性"></a>检测暗模式的准确性</h4><ul><li><strong>整体性能</strong>：UIGuard在检测暗模式方面达到了0.93的准确率，能够正确识别大部分包含暗模式的用户界面。</li><li><strong>详细性能</strong>：对于每种暗模式类型，UIGuard在7种类型中F1分数达到或超过0.80，显示出在检测特定暗模式方面的高效性。</li><li><strong>消融实验</strong>：通过逐步添加UIGuard的不同组件，如图标语义、模板匹配、状态识别和颜色分组，展示了每个组件对系统性能的贡献。</li></ul><h3 id="Usefulness"><a href="#Usefulness" class="headerlink" title="Usefulness"></a>Usefulness</h3><ul><li>研究招募了58名背景多样的参与者，让他们评估UI界面中的暗模式，并与UIGuard的检测结果进行比较。</li><li>结果显示，参与者在使用UIGuard后，对暗模式的识别能力显著提高，表明系统能有效辅助用户识别和避免暗模式。</li><li>此外，研究还表明，参与者知识水平的提高是显著的，UIGuard可以作为教育工具，帮助用户学习如何识别暗模式。</li></ul><h3 id="Discussion-and-future-work"><a href="#Discussion-and-future-work" class="headerlink" title="Discussion and future work"></a>Discussion and future work</h3><h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><ol><li><strong>利益相关者受益</strong>：UIGuard工具可以为多种利益相关者提供帮助，包括最终用户、应用开发者和监管机构。</li><li><strong>教育和意识提升</strong>：UIGuard不仅可以检测暗模式，还可以作为教育工具，提高用户对这些不道德设计实践的认识。</li><li><strong>监管支持</strong>：UIGuard可以辅助监管机构监督和执行移动应用市场中的道德实践，帮助他们更有效地检查和评估应用程序。</li></ol><h4 id="未来工作"><a href="#未来工作" class="headerlink" title="未来工作"></a>未来工作</h4><ol><li><strong>暗模式边界</strong>：探讨暗模式与个性化设计的边界，为用户提供可调节的警告级别，以便他们可以选择哪些暗模式对他们更重要。</li><li><strong>设计权衡</strong>：研究如何在保护用户免受暗模式影响的同时，允许一定程度的个性化和定制化设计。</li><li><strong>检测范围扩展</strong>：将UIGuard的应用范围扩展到更多类型的暗模式，特别是那些动态变化的模式。</li><li><strong>工具自动化和进化</strong>：研究如何使UIGuard能够自动适应暗模式分类的变化，以及如何整合用户界面修改工作，以直接阻止恶意设计。</li><li><strong>用户行为影响</strong>：研究UIGuard对用户行为的影响，例如它是否改变了用户使用应用程序的习惯，以及如何平衡直接修改和提示方式。</li><li><strong>法律方面</strong>：进一步明确暗模式的法律含义，为监管机构提供更清晰的指导。</li></ol>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>UIDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器底层梳理</title>
    <link href="/2024/10/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BA%95%E5%B1%82%E6%A2%B3%E7%90%86/"/>
    <url>/2024/10/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BA%95%E5%B1%82%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="🔑浏览器原理-多进程架构-渲染引擎-JS-引擎"><a href="#🔑浏览器原理-多进程架构-渲染引擎-JS-引擎" class="headerlink" title="🔑浏览器原理 | 多进程架构 | 渲染引擎 | JS 引擎"></a>🔑浏览器原理 | 多进程架构 | 渲染引擎 | JS 引擎</h1><span id="more"></span><h1 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h1><ul><li>浏览器的主要功能是向服务器请求并在浏览器窗口中显示选择的网络资源。</li><li>该资源通常是 HTML 文档，也可能是 PDF、图像或某种其他类型的内容。</li><li>资源的位置由用户使用 <strong>URI</strong>（统一资源标识符）指定。</li></ul><blockquote><ul><li><p>URI &#x3D; Uniform Resource Identifier 统一资源标志符</p></li><li><p>URL &#x3D; Uniform Resource Locator 统一资源定位符（<strong>用地址定位</strong>）</p></li><li><p>URN &#x3D; Uniform Resource Name 统一资源名称（<strong>用名称定位</strong>）</p></li></ul><p>如来自 <a href="https://datatracker.ietf.org/doc/html/rfc3986.txt">RFC3986</a> 的示例：<code>urn:oasis:names:specification:docbook:dtd:xml:4.1.2</code></p></blockquote><h1 id="浏览器的主要组件"><a href="#浏览器的主要组件" class="headerlink" title="浏览器的主要组件"></a>浏览器的主要组件</h1><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104003319328.png"></p><ul><li><strong>用户界面</strong>：包括地址栏、前进&#x2F;后退按钮、书签菜单等</li><li><strong>浏览器引擎</strong>：用户界面（UI）和渲染引擎之间的协调和传递</li><li><strong>渲染引擎</strong>：显示请求的资源内容。如请求 HTML 则解析 HTML 和 CSS</li><li><strong>网络</strong>：如HTTP请求之类的网络调用</li><li><strong>UI 后端</strong>：用于绘制基本的小部件，如组合框和窗口</li><li><strong>JavaScript 解释器</strong>：用于解析并执行 JavaScript 代码</li><li><strong>数据存储</strong>：这是一个持久层。浏览器可能需要在本地保存各种数据，例如cookie。浏览器还支持 localStorage、IndexedDB 等存储机制</li></ul><h1 id="浏览器的多进程架构"><a href="#浏览器的多进程架构" class="headerlink" title="浏览器的多进程架构"></a>浏览器的多进程架构</h1><p>在Chrome中，主要的进程有4个：</p><ul><li><strong>浏览器进程 (Browser Process)</strong> ：负责浏览器的TAB的前进、后退、地址栏、书签栏的工作和处理浏览器的一些不可见的底层操作，比如网络请求和文件访问。</li><li><strong>渲染进程 (Renderer Process)</strong> ：负责一个Tab内的显示相关的工作，也称渲染引擎。</li><li><strong>插件进程 (Plugin Process)</strong> ：负责控制网页使用到的插件</li><li><strong>GPU进程 (GPU Process)</strong> ：负责处理整个应用程序的GPU任务</li></ul><h2 id="多进程架构优化"><a href="#多进程架构优化" class="headerlink" title="多进程架构优化"></a>多进程架构优化</h2><p><code>Renderer Process</code>作用是负责一个 tab 的显示相关工作，不同的 tab 进程之间的内存无法共享，但是时常是需要共享的</p><h3 id="四种进程模式"><a href="#四种进程模式" class="headerlink" title="四种进程模式"></a>四种进程模式</h3><p>所以为了节省内存，Chrome提供了四种进程模式（Process Models）：</p><ul><li><strong>Process-per-site-instance</strong> (default) - 同一个 <strong>site-instance</strong> 使用一个进程</li><li><strong>Process-per-site -</strong> 同一个 <strong>site</strong> 使用一个进程</li><li><strong>Process-per-tab -</strong> 每个 tab 使用一个进程</li><li><strong>Single process -</strong> 所有 tab 共用一个进程</li></ul><blockquote><ul><li><strong>site</strong> 指的是相同的 registered domain name 和 scheme</li><li><strong>site-instance</strong> 指的是一组 connected pages from the same site<ul><li>用户通过<code>&lt;a target=&quot;_blank&quot;&gt;</code>这种方式点击打开的新页面</li><li>JS代码打开的新页面（比如 <code>window.open</code>)、</li></ul></li></ul></blockquote><h3 id="默认模式选择"><a href="#默认模式选择" class="headerlink" title="默认模式选择"></a>默认模式选择</h3><p><code>Process-per-site-instance</code>兼容了性能与易用性：</p><ul><li>相较于 Process-per-tab，能够少开很多进程，就意味着更少的内存占用</li><li>相较于 Process-per-site，能够更好的隔离相同域名下毫无关联的 tab，更加安全</li></ul><h1 id="浏览器内核和-JS-引擎"><a href="#浏览器内核和-JS-引擎" class="headerlink" title="浏览器内核和 JS 引擎"></a>浏览器内核和 JS 引擎</h1><ul><li>以前人们常把浏览器内核分为渲染引擎和 Javascript 引擎。后面有了更明确的区分，浏览器内核单指渲染引擎，Javascript 引擎独立了出来</li><li><strong>浏览器内核</strong>也就是渲染引擎, 是浏览器最核心的部分, 负责对网页语法的解释并渲染(显示)网页</li><li><strong>Javascript 引擎</strong>的主要工作是将Javascript代码转换为快速优化的机器码，以便浏览器或服务器能够解释和执行。另外它还负责执行代码、分配内存以及垃圾回收</li></ul><h1 id="浏览器会经历什么"><a href="#浏览器会经历什么" class="headerlink" title="浏览器会经历什么"></a>浏览器会经历什么</h1><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104003428109.png"></p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>导航是加载网页的第一步，指的是当用户通过点击一个链接、在浏览器地址栏写下一个网址、提交一个表单等方式请求一个网页时发生的过程</p><blockquote><p>Browser Process 可以划分出不同的工作线程：</p><ul><li>UI thread：控制浏览器上的按钮及输入框；</li><li>network thread：处理网络请求，从网上获取数据；</li><li>storage thread： 控制文件等的访问；</li></ul></blockquote><h3 id="DNS-查询"><a href="#DNS-查询" class="headerlink" title="DNS 查询"></a>DNS 查询</h3><ul><li>导航到网页的第一步是查找该页面的资源所在位置（HTML、CSS、Javascript 和其他类型的文件）</li><li>实际上所做的是询问其中一台服务器并要求找出哪个<code>IP address</code>与<code>https://example.com</code>名称相对应</li><li>如果此前从未访问过该站点，必须进行 DNS 查询；初次查找后，IP 地址可能会被缓存一段时间，多次访问同一网站会更快</li></ul><h3 id="TCP-握手"><a href="#TCP-握手" class="headerlink" title="TCP 握手"></a>TCP 握手</h3><blockquote><p>通过三次握手建立可靠的 TCP 连接</p></blockquote><h3 id="TLS-协商"><a href="#TLS-协商" class="headerlink" title="TLS 协商"></a>TLS 协商</h3><blockquote><p>在已建立的 TCP 连接上协商加密参数和交换密钥，建立安全的加密通信通道</p></blockquote><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104003508876.png"></p><h3 id="读取响应"><a href="#读取响应" class="headerlink" title="读取响应"></a><strong>读取响应</strong></h3><p>可以打开控制台的 Network 选项卡看看响应头包含的内容，初始请求的响应包含收到的第一个字节的数据。</p><ul><li><code>network thread</code>接收到服务器的响应后，开始解析HTTP响应报文，然后根据响应头中的<code>Content-Type</code>字段来确定响应主体的媒体类型（MIME Type）</li><li>同时浏览器会进行安全检查，如果域名或请求内容匹配到恶意站点，，<code>network thread</code>会提示一个警告页</li></ul><blockquote><p><strong>第一个字节的时间（TTFB）</strong></p><p>是指从用户提出请求（在地址栏中输入网站名称）到收到第一个 HTML 数据包（通常为14kb）的时间</p></blockquote><blockquote><p><strong>TCP 慢启动和拥塞算法</strong></p><ul><li>一种平衡网络连接速度的算法，作用是确定流量的最佳速率并创建稳定的流量流</li><li>第一个数据包将是 14kb（或更小），其工作方式是逐渐增加传输的数据量，直到达到预定的阈值</li><li>客户端从服务器接收到每个数据包后，会以<code>ACK消息</code>响应，如果服务器发送数据包太多太快，将会被丢弃，客户端也不会发送任何消息</li></ul></blockquote><h2 id="渲染引擎的工作"><a href="#渲染引擎的工作" class="headerlink" title="渲染引擎的工作"></a>渲染引擎的工作</h2><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104003529357.png"></p><blockquote><p>渲染进程中，包含以下线程：</p><ul><li>一个主线程（main thread）</li><li>多个工作线程（work thread）</li><li>一个合成器线程（compositor thread）</li><li>多个光栅化线程（raster thread）</li></ul></blockquote><p><strong>一些常见的浏览器引擎</strong></p><ul><li><strong>Blink</strong><ul><li>开发者: Google</li><li>使用者: Google Chrome, Microsoft Edge (基于Chromium的版本), Opera, Vivaldi, Brave</li></ul></li><li><strong>WebKit</strong><ul><li>开发者: Apple</li><li>使用者: Apple Safari, 早期版本的Google Chrome, 早期版本的Opera</li></ul></li><li><strong>Gecko</strong><ul><li>开发者: Mozilla Foundation</li><li>使用者: Mozilla Firefox, Thunderbird</li></ul></li></ul><h3 id="HTML-解析"><a href="#HTML-解析" class="headerlink" title="HTML 解析"></a>HTML 解析</h3><blockquote><p><strong>解析</strong>是指将程序分析并转换为运行时环境实际可以运行的内部格式</p><p><strong>HTML 解析</strong>是指浏览器内核的 HTML Parse 将 HTML 转化为DOM树（DOM Tree）</p></blockquote><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a><strong>词法分析</strong></h4><blockquote><p>将一些输入转换为<strong>标签</strong>(源代码的基本组件)</p></blockquote><p>词法分析过程结束时的结果是一系列 0 个或多个以下标签：DOCTYPE、开始标签 (<tag>)、结束标签(</tag>)、自闭合标签 (<tag/>) 、属性名称、值、注释、字符、文件结尾或元素中的纯文本内容</p><h4 id="构建-DOM"><a href="#构建-DOM" class="headerlink" title="构建 DOM"></a><strong>构建 DOM</strong></h4><blockquote><p>创建 token 后, 基于先前解析的标签创建<strong>树状结构 DOM</strong> (Document Object Model)</p></blockquote><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104003654110.png"></p><ul><li>解析器从上到下逐行工作</li><li>如果遇到<strong>非阻塞资源</strong>(如图像、音频、字体)时, 浏览器会向服务器请求这些图像并继续解析</li><li>如果遇到<strong>阻塞资源</strong>（CSS 样式表、在 HTML 的 <code>&lt;head&gt;</code> 部分添加的 Javascrpt 文件或从 CDN 添加的字体），解析器将停止执行，直到所有这些阻塞资源都被下载 (所以建议在 HTML 文件末尾添加<code>&lt;script&gt;</code>标签, 如果保留在<code>&lt;head&gt;</code>中, 应该添加<code>defer</code>或<code>async</code>属性)</li></ul><h4 id="预加载器"><a href="#预加载器" class="headerlink" title="预加载器"></a><strong>预加载器</strong></h4><blockquote><p>预加载器的工作原理是在浏览器解析 HTML 的同时，<strong>预测并提前加载可能需要的资源</strong>，如 CSS、JavaScript、图片、字体等</p></blockquote><ul><li>较轻的解析器会扫描 HTML 以查看需要检索的资源(样式表、脚本), 然后预加载器在后台检索这些资源</li><li>预加载器可以并行加载资源, 会根据资源的优先级进行下载</li></ul><h3 id="CSS-解析"><a href="#CSS-解析" class="headerlink" title="CSS 解析"></a>CSS 解析</h3><blockquote><p><strong>CSS 解析</strong>是指 CSS Parse 将 CSS 转化为 <strong>CSSOM Tree</strong>（Style Rules）,可以用 <code>document.styleSheets</code> 查看除了内联和默认样式之外的所有内部和外部样式表</p></blockquote><h4 id="词法分析和构建-CSSOM"><a href="#词法分析和构建-CSSOM" class="headerlink" title="词法分析和构建 CSSOM"></a>词法分析和构建 CSSOM</h4><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104003718604.png"></p><ul><li>CSS 解析器获取<strong>字节</strong>并将它们转换为<strong>字符</strong>，然后是<strong>标签</strong>，然后是节<strong>点</strong>，最后它们被<strong>链接</strong>到 <strong>CSSOM</strong> 中</li><li>浏览器会执行一些称为<strong>选择器匹配</strong>的操作，这意味着每组样式都将与页面上的所有节点（元素）匹配。</li><li>浏览器决定多个 CSS 来源的节点采用哪种规则会根据<strong>优先级</strong>判断</li></ul><h3 id="渲染树"><a href="#渲染树" class="headerlink" title="渲染树"></a>渲染树</h3><blockquote><p><strong>DOM树</strong>（DOM Tree）和 <strong>CSS规则</strong>（Style Rules）通过<strong>附加</strong>（Attachment）生成<strong>渲染树</strong>（Render Tree）</p></blockquote><ul><li>渲染树的目的是确保页面内容以正确的顺序绘制元素, 它将作为在屏幕上显示像素的绘画过程的输入</li><li>浏览器会从 DOM 树的根部遍历每个可见节点, 一些节点(如脚本或者元标记)是不可见的, 还有一些节点会被 CSS 隐藏(例如<code>display:&quot;none&quot;</code>属性)</li></ul><h4 id="布局和回流"><a href="#布局和回流" class="headerlink" title="布局和回流"></a>布局和回流</h4><blockquote><p>计算DOM树中可见元素的几何位置（例如节点的宽高、相对包含块的位置），生成<strong>布局树</strong></p></blockquote><ul><li>计算节点在设备视口内的确切位置和大小</li><li>每次更改页面中影响布局的 DOM 元素时, 都会触发<strong>回流</strong><ul><li>在 DOM 中添加或删除元素</li><li>调整浏览器窗口大小</li><li>更改元素的大小、位置</li></ul></li></ul><h4 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h4><ul><li>生成布局树之后, 渲染主线程会根据布局树的特点将其转换为<strong>层树</strong> (LayerTree)。一般滚动条、a标签、<code>transform</code>、<code>will-change</code>等样式都会影响分层效果，另外，像<code>opacity</code>、<code>filter</code>等属性也能影响分层</li><li>层树中的每个节点对应着一个图层, 合成操作在<strong>合成器线程</strong>这个单独线程上执行, 所以在执行合成操作时, 是不会影响主线程执行的</li></ul><h4 id="绘制和重绘"><a href="#绘制和重绘" class="headerlink" title="绘制和重绘"></a>绘制和重绘</h4><blockquote><p>渲染引擎将将页面内容绘制到<code>帧缓冲区</code>（Framebuffer）中，帧缓冲区是一个内存区域，用于存储图像数据，这些图像数据最终会被 GPU 渲染到屏幕上</p></blockquote><ul><li>决定哪些元素可见以及确定位置之后, 就可以把布局阶段计算的盒子转换为屏幕上渲染的像素, 这个阶段也叫做<strong>光栅化</strong></li><li>改变屏幕上元素的外观时, 都会触发<strong>重绘</strong><ul><li>改变元素轮廓</li><li>改变元素背景</li><li>改变可见性和不透明度</li></ul></li></ul><h2 id="JS-引擎的工作"><a href="#JS-引擎的工作" class="headerlink" title="JS 引擎的工作"></a>JS 引擎的工作</h2><p><strong>一些常见的 JS 引擎</strong></p><ul><li><strong>V8</strong><ul><li><strong>开发者</strong>: Google</li><li><strong>主要用途</strong>: Chrome浏览器、Node.js</li></ul></li><li><strong>JavaScriptCore (Nitro)</strong><ul><li><strong>开发者</strong>: Apple</li><li><strong>主要用途</strong>: Safari浏览器、WebKit</li></ul></li><li><strong>Chakra</strong><ul><li><strong>开发者</strong>: Microsoft</li><li><strong>主要用途</strong>: 旧版Edge浏览器</li></ul></li></ul><h3 id="JavaScript-代码是如何处理的"><a href="#JavaScript-代码是如何处理的" class="headerlink" title="JavaScript 代码是如何处理的"></a>JavaScript 代码是如何处理的</h3><h4 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h4><p>JavaScript 代码被转换为<strong>抽象语法树(AST)</strong>, 包括两个子阶段:</p><ul><li><strong>词法分析</strong>: 将源代码分解为一个个的词法单元（tokens）</li><li><strong>语法分析:</strong> 将词法单元按照语法规则组合成抽象语法树（AST）</li></ul><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><ul><li>构建 AST 后, 会被翻译成字节码或机器代码, 现代 JavaScript 引擎使用<strong>即时编译</strong></li><li>对编译后的代码进行<strong>优化</strong>， 然后<strong>执行</strong>字节码或机器码</li><li>执行后会自动<strong>回收</strong>不再使用的内存，并处理<strong>异步任务</strong></li></ul><h3 id="How-JavaScript-is-run-in-the-browser"><a href="#How-JavaScript-is-run-in-the-browser" class="headerlink" title="How JavaScript is run in the browser"></a>How JavaScript is run in the browser</h3><h4 id="解释器-Interpreter"><a href="#解释器-Interpreter" class="headerlink" title="解释器 (Interpreter)"></a>解释器 (Interpreter)</h4><ul><li>在开始运行代码之前，不必执行整个编译步骤，只需开始翻译第一行并运行</li><li>多次运行相同的代码，必须一遍又一遍做同样的翻译</li><li>浏览器最初使用 JavaScript 解释器</li></ul><h4 id="编译器-Compiler"><a href="#编译器-Compiler" class="headerlink" title="编译器 (Compiler)"></a>编译器 (Compiler)</h4><ul><li>必须在开始时经历编译步骤，启动时间更长</li><li>循环的代码不需要重复翻译，运行更快</li><li>有更多时间查看并编辑代码使之运行更快，这个编辑称为<strong>优化</strong></li></ul><h4 id="JIT-Just-In-Time-即时编译"><a href="#JIT-Just-In-Time-即时编译" class="headerlink" title="JIT (Just-In-Time) 即时编译"></a>JIT (Just-In-Time) 即时编译</h4><p><strong>基本思想</strong></p><ul><li>向 JavaScript 引擎添加了一个新部分，称为<strong>监视器</strong>（又名分析器）。该监视器在代码运行时监视代码，并记录代码运行的<strong>次数</strong>以及使用的<strong>类型</strong>。</li><li>起初监视器通过解释器运行所有内容。如果相同代码运行次数较少，该代码段称为<strong>暖代码</strong>；代码运行次数很多称为<strong>热代码。</strong></li></ul><p><strong>基线编译器 (Baseline compiler)</strong></p><ul><li><strong>当函数开始变热</strong>，监视器会将其发送出去进行编译，并存储编译结果</li><li>函数的每一行都被编译为“<strong>存根</strong>”。存根按<strong>行号</strong>和<strong>变量类型</strong>进行索引</li><li>基线编译器只进行一些优化，执行时间不会耗费太久</li></ul><p><strong>优化编译器(Optimizing compiler)</strong></p><ul><li><strong>当某个代码块非常热</strong>，监视器会将其发送给优化编译器，创建一个更快的版本</li><li>假设由特定函数创建的所有对象都具有<strong>相同的属性名称</strong>，并且属性以<strong>相同的顺序</strong>添加</li><li>使用监视器观察代码执行收集的信息来做出这些判断。但是判断的假设不一定准确，需要在<strong>运行之前进行检查是否有效</strong><ul><li>若有效，编译的代码将运行</li><li>若无效，JIT 会废弃优化的代码，执行返回到解释器或基线编译版本，这个过程称为<strong>去优化</strong>（退出）</li></ul></li><li>如果代码不断优化然后取消优化，那么它最终会比仅执行基线编译版本慢，所以浏览器都添加了限制，以便在发生优化 &#x2F; 去优化循环的时候中断</li></ul><p><strong>一个优化示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">arraySum</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    sum += arr[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>JIT 处理<strong>不同变量类型编译生成不同机器代码</strong>的问题的方式是<strong>编译多个基线存根</strong><ul><li>如果一段代码是单态的，将获得一个存根</li><li>如果是多态的，每个类型组合获得一个存根</li></ul></li></ul><blockquote><p>所以 JIT 在每次执行该行代码的时候需要不断检查类型，循环中的每次迭代都要提出相同的问题</p></blockquote><ul><li>在优化编译器中<strong>整个函数被一起编译</strong>，共用的类型检查移动到循环之前，加快执行速度</li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20241104003801233.png"></p><p>简单来说，JIT 就是通过<strong>监控正在运行的代码并发送要优化的热代码路径</strong>，使 JavaScript 运行得更快。这使得大多数 JavaScript 应用程序的性能提高了许多倍。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://web.dev/articles/howbrowserswork#Layered_representation">How browsers work</a></li><li><a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/">A crash course in just-in-time (JIT) compilers</a></li><li><a href="https://dev.to/arikaturika/how-web-browsers-work-part-1-with-illustrations-1nid">How web browsers work</a></li><li><a href="https://blog.poetries.top/browser-working-principle/guide/part5/lesson24.html#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F">分层和合成机制</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Whistle</title>
    <link href="/2024/08/25/whistle/"/>
    <url>/2024/08/25/whistle/</url>
    
    <content type="html"><![CDATA[<p>Whistle 代理小记录</p><p>Whistle 代理小记录 📣</p><span id="more"></span><h2 id="关于代理"><a href="#关于代理" class="headerlink" title="关于代理"></a>关于代理</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><p><strong>抓包</strong>：包，是指网络数据包，包括客户端发送的请求和服务端返回的数据。PC 端，可以通过 chrome 直观的看到网络状态，但是 App 抓包则需要专门的抓包工具了。</p></li><li><p><strong>代理</strong>：是指一个中间角色，它可以在本地调试时不需要经过鉴权或者其他限制的情况下，直接代理 url 请求，可以代理请求，也可以代理响应</p></li></ul><h3 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h3><blockquote><p>客户端到服务端的中转服务</p></blockquote><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/728b192bf71ceecba4e5898c545b459c93416.png" alt="img"></p><ul><li><p>不经过代理的请求：客户端和服务端直接建立连接后，即可开始交换数据。</p></li><li><p>经过代理的请求：客户端不与服务端直接建立连接，而是<strong>客户端先跟代理建立连接后，将目标服务器的地址发送给代理，通过代理再跟服务端建立连接</strong>，这里如果代理服务为 HTTP Server，则称为 HTTP 代理。</p></li></ul><h2 id="whistle使用"><a href="#whistle使用" class="headerlink" title="whistle使用"></a>whistle使用</h2><h3 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h3><ul><li><p><strong>安装node</strong></p></li><li><p><strong>安装whistle</strong></p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pnpm <span class="hljs-keyword">install</span> -g whistle<br></code></pre></td></tr></table></figure></li><li><p><strong>启动whistle</strong></p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">w2 <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure></li><li><p><strong>配置代理</strong></p><p>  我用的浏览器插件<a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif">SwitchyOmega</a></p><p>  <img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/switchyomega.jpg" alt="img"></p></li><li><p><strong>访问配置页面</strong></p><ul><li>方式1：域名访问 <a href="http://local.whistlejs.com/">http://local.whistlejs.com/</a></li><li>方式2：通过ip+端口来访问，形式如  e.g. <a href="http://127.0.0.1:8899/">http://127.0.0.1:8899</a></li><li>方式2：通过命令行参数 <code>-P xxxx</code> 自定义webui的端口(<code>xxxx</code>表示要设置的端口号)，自定义端口支持上述两种方式访问，也支持 <a href="http://127.0.0.1:xxxx/">http://127.0.0.1:xxxx</a></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240825235716213.png" alt="image-20240825235716213"></p><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><ul><li><p><strong>请求转发1</strong></p><p>  把后端接口替换成本地文件，模拟数据（不用等待后端接口开发）</p>  <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">http:<span class="hljs-string">//example.com</span> file:<span class="hljs-string">//</span>****<span class="hljs-string">.json</span><br></code></pre></td></tr></table></figure></li><li><p><strong>请求转发2</strong></p><p>  把线上出错文件替换成本地文件debug</p></li><li><p><strong>请求转发3</strong></p><p>  把url替换成另一个线上网址</p></li><li><p><strong>注入html, css, js</strong></p><p>  也是替换成本地文件</p><p>  还可以注入源码</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> jsPrepend:<span class="hljs-comment">//&#123;vConsole.min.js&#125;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>使用log功能打印日志</strong></p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> log:<span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shading着色 | 图形学 | OpenGL</title>
    <link href="/2024/07/09/Shading/"/>
    <url>/2024/07/09/Shading/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="👨‍🎨2024-NUS-SOC-Graphics-Rendering-self-learning-with-games101😙"><a href="#👨‍🎨2024-NUS-SOC-Graphics-Rendering-self-learning-with-games101😙" class="headerlink" title="👨‍🎨2024 NUS_SOC  Graphics Rendering  (self-learning with games101😙)"></a>👨‍🎨2024 NUS_SOC  Graphics Rendering  (self-learning with games101😙)</h2><span id="more"></span><h2 id="不同Shading"><a href="#不同Shading" class="headerlink" title="不同Shading"></a>不同Shading</h2><ul><li>应用在平面上 —— <strong>Flat Shading</strong></li><li>应用在顶点上 —— <strong>Gouraud Shading</strong></li><li>应用在像素上 —— <strong>Phong Shading</strong></li><li>半角向量代替反射向量 —— <strong>Blinn-Phong Shading</strong></li></ul><h2 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h2><blockquote><p><strong>三角形内部插值</strong></p><ul><li>为了根据三角形顶点平滑过渡</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240711215957663.png"></p><blockquote><p> 在三维空间做插值，再投影到二维</p></blockquote><h2 id="纹理放大"><a href="#纹理放大" class="headerlink" title="纹理放大"></a>纹理放大</h2><p><strong>Texture Magnification</strong></p><blockquote><p><strong>纹理过小</strong></p></blockquote><ul><li>A pixel on a texture —— a <strong>texel</strong> (纹理元素)</li></ul><blockquote><p>在一个很高分辨率的屏幕上铺很低分辨率的texture，相当于一些接近的pixel映射到同样的texel，于是会出现放大模糊的感觉</p></blockquote><h3 id="双重线性插值"><a href="#双重线性插值" class="headerlink" title="双重线性插值"></a>双重线性插值</h3><p><strong>考虑周围的texel，平滑过渡的颜色</strong></p><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240711220052287.png"></p><h2 id="纹理走样"><a href="#纹理走样" class="headerlink" title="纹理走样"></a>纹理走样</h2><blockquote><p><strong>纹理过大</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240711220113036.png"></p><ul><li>屏幕的一个pixel覆盖的纹理过大</li><li>信号变化过快，采样速度跟不上</li><li>所以不采样，先设计好mipmap</li></ul><h3 id="Mipmap"><a href="#Mipmap" class="headerlink" title="Mipmap"></a>Mipmap</h3><p><strong>范围查询 range queries</strong></p><ul><li><p>提前计算，提前生成</p></li><li><p>只能做近似的正方形的范围查询</p></li><li><p>根据等比数列计算，存储量只比原本多了三分之一</p></li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240711220154655.png"></p><blockquote><p>把屏幕上的一个pixel近似成一个正方形</p></blockquote><p>如何查询？</p><blockquote><p>根据映射的texture大小尺寸查询mipmap，求出在第几个level</p></blockquote><h4 id="三线性插值"><a href="#三线性插值" class="headerlink" title="三线性插值"></a>三线性插值</h4><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240711220225392.png"></p><h4 id="各向异性过滤"><a href="#各向异性过滤" class="headerlink" title="各向异性过滤"></a>各向异性过滤</h4><ul><li>考虑不同的方向性</li><li>不只是方形</li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240711220237856.png"></p>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华科操作系统 | OS实验&amp;课设 | Ubuntu</title>
    <link href="/2024/05/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/05/31/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统-实验-课设-Ubuntu"><a href="#操作系统-实验-课设-Ubuntu" class="headerlink" title="操作系统 | 实验 | 课设| Ubuntu"></a>操作系统 | 实验 | 课设| Ubuntu</h1><span id="more"></span><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a><strong>实验内容</strong></h3><ul><li>在Linux（建议麒麟版本）下裁剪和编译Linux内核，并启用新内核。（其他发行版本也可以）</li><li>在Linux（建议麒麟版本）内核中增加3个新的系统调用，并启用新的内核，并编写应用程序测试。（其他发行版本也可以）</li><li>在Windows下，编写“算命大师.bat”批处理程序，输入出生年月日，输出属相和星座。</li><li>在Linux下，编写“算命大师”脚本程序，输入出生年月日，输出属相和星座</li></ul><h3 id="实验记录和答案"><a href="#实验记录和答案" class="headerlink" title="实验记录和答案"></a>实验记录和答案</h3><p><a href="https://gvqnmru1asr.feishu.cn/wiki/MncGwdbeHilzIkkwHoVc2g16nob?from=from_copylink">https://gvqnmru1asr.feishu.cn/wiki/MncGwdbeHilzIkkwHoVc2g16nob?from=from_copylink</a></p><h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a><strong>实验内容</strong></h3><ul><li>在Linux&#x2F;Windows下创建2个线程A和B，循环输出数据或字符串。 </li><li>在Liunx下创建（fork）一个子进程，实验wait&#x2F;exit函数 </li><li>在Windows&#x2F;Linux下，利用线程实现并发画圆画方。 </li><li>在Windows或Linux下利用线程实现“生产者-消费者”同步控制 </li><li>在Linux下利用信号机制(signal)实现进程通信 </li><li>在Windows或Linux下模拟哲学家就餐，提供死锁和非死锁解法。</li></ul><h3 id="实验记录和答案-1"><a href="#实验记录和答案-1" class="headerlink" title="实验记录和答案"></a>实验记录和答案</h3><p><a href="https://gvqnmru1asr.feishu.cn/wiki/JvAew81TSi7LabkM7tFcTxXznpc?from=from_copylink">https://gvqnmru1asr.feishu.cn/wiki/JvAew81TSi7LabkM7tFcTxXznpc?from=from_copylink</a></p><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><h3 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a><strong>实验内容</strong></h3><ul><li>Windows&#x2F;Linux模拟实现FIFO或LRU页面淘汰算法。</li><li>Linux下利用&#x2F;proc&#x2F;pid&#x2F;pagemap计算某个变量或函数虚拟地址对应的 物理地址等信息。建议优麒麟或麒麟系统。</li><li>研读并修改Linux内核的缺页处理函数do_no_page 或页框分配函数 get_free_page，并用printk打印调试信息。<ul><li>注意：需要编译内核。建议优麒 麟或麒麟系统。</li></ul></li></ul><h3 id="实验记录和答案-2"><a href="#实验记录和答案-2" class="headerlink" title="实验记录和答案"></a>实验记录和答案</h3><p><a href="https://gvqnmru1asr.feishu.cn/wiki/VKiQwKeNTiKoDukiX3RcMD2Znlb?from=from_copylink">https://gvqnmru1asr.feishu.cn/wiki/VKiQwKeNTiKoDukiX3RcMD2Znlb?from=from_copylink</a></p><h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><h3 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a><strong>实验内容</strong></h3><ul><li>编写一个Linux内核模块，并完成模块的安装&#x2F;卸载等操作。 </li><li>在Linux平台编写一个字符设备的驱动程序和测试用的应用程序。<ul><li>驱动程序的功能：可以接收应用程序调用write输入的整数，并用read输出 最近输入的两个整数的和或最大值。</li></ul></li><li>在Linux平台编写一个字符设备的驱动程序和测试用的应用程序。<ul><li>驱动程序的功能：内部维护一个32字节的缓冲区，应用程序可以多次调用 read或write函数读写该缓冲区。</li><li>read或write操作相互之间无关联，但要 求每次read或write要接着上操作的位置继续。如果读写失败返回错误。</li></ul></li></ul><h3 id="实验记录和答案-3"><a href="#实验记录和答案-3" class="headerlink" title="实验记录和答案"></a>实验记录和答案</h3><p><a href="https://gvqnmru1asr.feishu.cn/wiki/TUIKwX2jqiju0ik5pU6c5pXnnlf?from=from_copylink">https://gvqnmru1asr.feishu.cn/wiki/TUIKwX2jqiju0ik5pU6c5pXnnlf?from=from_copylink</a></p><h1 id="课设"><a href="#课设" class="headerlink" title="课设"></a>课设</h1><h2 id="课设内容"><a href="#课设内容" class="headerlink" title="课设内容"></a>课设内容</h2><ol><li><p><strong>编写设备(含缓冲区)驱动程序，并支持应用程序对其缓冲区的读写</strong></p><ol><li>设备的缓冲区大小可调(例32字节)，缓冲区逻辑上是环形缓冲区； </li><li>缓冲区按序读&#x2F;写，每个字节读&#x2F;写过程中不重复且不遗漏； </li><li><strong>编写若干个应用程序读或写设备缓冲区(读&#x2F;写数目不定且程序乱序运行)</strong> <ul><li>应用程序读缓冲区时：有新数据读就读，否则就被阻塞，直到有可读数据才被唤醒应用程序写缓冲区时：</li><li>有空位写就写，否则就被阻塞，直到有空位时才被唤醒；</li></ul></li><li>驱动程序内部维护缓冲区的读&#x2F;写，确保适时阻塞或唤醒相应进程 </li><li>实验现象：观察缓冲区的变化与读&#x2F;写进程的阻塞&#x2F;唤醒的实际</li><li><strong>提示</strong><ul><li>内设固定大小缓冲区BUFFER，<strong>读&#x2F;写不遗漏不重复</strong> </li><li>实现设备的阻塞和非阻塞两种工作方式</li><li>读指针pRead，写指针pWrite</li></ul></li></ol></li><li><p><strong>编写或复制至少4个应用程序进行读&#x2F;写测试(可选：用echo&#x2F;cat命令代替具有读&#x2F;写设备功能的应用程序)</strong> </p><ol><li>编写不少于2个读&#x2F;写的测试应用程序</li><li>观察缓冲区变化与读&#x2F;写进程的阻塞&#x2F;被唤醒的同步情况。 </li><li>ps命令 查看进程状态：阻塞中……</li></ol></li></ol><h2 id="课设记录"><a href="#课设记录" class="headerlink" title="课设记录"></a>课设记录</h2><p><a href="https://gvqnmru1asr.feishu.cn/wiki/AWTowekjxiftmPkhRqxcVXN2nhf?from=from_copylink">https://gvqnmru1asr.feishu.cn/wiki/AWTowekjxiftmPkhRqxcVXN2nhf?from=from_copylink</a></p><h2 id="课设报告"><a href="#课设报告" class="headerlink" title="课设报告"></a>课设报告</h2><p><a href="https://gvqnmru1asr.feishu.cn/wiki/XgoSwdU0jiMSt9khqWmcSrmInLf?from=from_copylink">https://gvqnmru1asr.feishu.cn/wiki/XgoSwdU0jiMSt9khqWmcSrmInLf?from=from_copylink</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好用工具小记录</title>
    <link href="/2024/05/06/%E5%A5%BD%E7%94%A8%E5%B7%A5%E5%85%B7%E5%B0%8F%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/05/06/%E5%A5%BD%E7%94%A8%E5%B7%A5%E5%85%B7%E5%B0%8F%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="DeskPins"><a href="#DeskPins" class="headerlink" title="DeskPins"></a>DeskPins</h3><p>页面置顶工具</p><h3 id="listary"><a href="#listary" class="headerlink" title="listary"></a>listary</h3><p>一个灰常好用的文件搜索工具</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fork详解</title>
    <link href="/2024/03/28/fork%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/03/28/fork%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="进程的等待wait"><a href="#进程的等待wait" class="headerlink" title="进程的等待wait()"></a>进程的等待<code>wait()</code></h3><p>进程一旦调用了wait，就会立刻<strong>阻塞自己</strong>，由wait分析当前进程中的<strong>某个子进程</strong>是否已经退出了，如果让它找到这样一个已经变成僵尸进程的子进程，wait会收集这个子进程的信息，并将它彻底销毁后返回；如果没有找到这样一个子进程，wait会一直阻塞直到有一个出现</p><h3 id="进程的终结exit"><a href="#进程的终结exit" class="headerlink" title="进程的终结exit()"></a>进程的终结<code>exit()</code></h3><h3 id="进程的休眠sleep"><a href="#进程的休眠sleep" class="headerlink" title="进程的休眠sleep()"></a>进程的休眠<code>sleep()</code></h3>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程控制</title>
    <link href="/2024/03/28/Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/03/28/Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="fork"><a href="#fork" class="headerlink" title="fork()"></a><code>fork()</code></h3><h3 id="进程的等待wait"><a href="#进程的等待wait" class="headerlink" title="进程的等待wait()"></a>进程的等待<code>wait()</code></h3><p>进程一旦调用了wait，就会立刻<strong>阻塞自己</strong>，由wait分析当前进程中的<strong>某个子进程</strong>是否已经退出了，如果让它找到这样一个已经变成僵尸进程的子进程，wait会收集这个子进程的信息，并将它彻底销毁后返回；如果没有找到这样一个子进程，wait会一直阻塞直到有一个出现</p><h3 id="进程的终结exit"><a href="#进程的终结exit" class="headerlink" title="进程的终结exit()"></a>进程的终结<code>exit()</code></h3><h3 id="进程的休眠sleep"><a href="#进程的休眠sleep" class="headerlink" title="进程的休眠sleep()"></a>进程的休眠<code>sleep()</code></h3>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PRPL模式详解 | PRPL patterns</title>
    <link href="/2024/03/21/PRPL/"/>
    <url>/2024/03/21/PRPL/</url>
    
    <content type="html"><![CDATA[<h1 id="PRPL模式-🚀-Preload-Render-Pre-cache-Lazy-Load"><a href="#PRPL模式-🚀-Preload-Render-Pre-cache-Lazy-Load" class="headerlink" title="PRPL模式 🚀 Preload | Render | Pre-cache | Lazy Load"></a>PRPL模式 🚀 Preload | Render | Pre-cache | Lazy Load</h1><span id="more"></span><h2 id="⭐Firstly"><a href="#⭐Firstly" class="headerlink" title="⭐Firstly"></a>⭐Firstly</h2><p>推荐一个网站 <a href="https://www.patterns.dev/#patterns">patterns</a></p><p>设计模式，渲染模式，性能模式……</p><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240321115439466.png"></p><h2 id="🔑Intro"><a href="#🔑Intro" class="headerlink" title="🔑Intro"></a>🔑Intro</h2><h4 id="什么是PRPL"><a href="#什么是PRPL" class="headerlink" title="什么是PRPL?"></a>什么是PRPL?</h4><p>PRPL 描述了一种可以提高网页加载速度和交互性的模式</p><ul><li><strong>Preload</strong>：高优先级加载关键资源，加快页面加载速度</li><li><strong>Render</strong>：关键资源下载完后尽快渲染，而不是等待所有资源加载完毕再渲染</li><li><strong>Pre-cache</strong>：首次访问时预缓存资源到本地，以便后续页面直接从缓存读取</li><li><strong>Lazy load</strong>：延迟加载路由和非关键资源</li></ul><h4 id="为什么需要PRPL？"><a href="#为什么需要PRPL？" class="headerlink" title="为什么需要PRPL？"></a>为什么需要PRPL？</h4><ul><li>当我们想访问一个网站时，我们首先必须向服务器发出请求以获取这些资源。入口点指向的文件从服务器返回，通常是我们应用程序的<strong>初始 HTML 文件</strong>，浏览器的 HTML 解析器在开始从服务器接收此数据后立即开始解析这些数据。如果解析器发现需要更多资源，例如样式表或脚本，则会向服务器发送<strong>另一个 HTTP 请求</strong>以获取这些资源</li><li>反复请求资源并不是最佳选择，因为我们试图<strong>尽量减少客户端和服务器之间的往返次数</strong></li><li>PRPL 模式的重点是<strong>优化初始加载</strong>。在初始路由完全加载和呈现之前，不会加载其他资源</li></ul><h4 id="HTTP-1-1-vs-HTTP-2"><a href="#HTTP-1-1-vs-HTTP-2" class="headerlink" title="HTTP&#x2F;1.1 vs. HTTP&#x2F;2"></a>HTTP&#x2F;1.1 vs. HTTP&#x2F;2</h4><p>![](<a href="https://assets-global.website-files.com/5ff66329429d880392f6cba2/6149cbd7fd4bdd7c82f55cc6_http1">https://assets-global.website-files.com/5ff66329429d880392f6cba2/6149cbd7fd4bdd7c82f55cc6_http1</a> vs http2.png)</p><ul><li>HTTP&#x2F;1.1 在请求和响应中使用换行符分隔的<strong>纯文本协议</strong>，而 HTTP&#x2F;2 将请求和响应分割成“<strong>帧</strong>”。包含标头和正文字段的 HTTP 请求至少分为两个帧：<strong>标头帧和数据帧</strong></li><li>HTTP&#x2F;1.1 客户端和服务器之间最多有6个TCP连接。通过同一个TCP连接发送新请求之前必须先解决之前的请求，如果一个请求耽误很长时间就会阻止后续请求，这个问题称为“<strong>队头阻塞</strong>”</li><li>HTTP&#x2F;2 将消息编码为<strong>二进制数据</strong>，并建立了<strong>双向流</strong>，可以实现包含多个双向流的单个TCP。双向流可以在客户端和服务器之间承载多个请求和响应帧，处理好的帧可以及时返回，有效解决了队头阻塞的问题</li></ul><p><img src="https://assets-global.website-files.com/5ff66329429d880392f6cba2/6149cc3eca0fb2c370604259_http1%20vs%20http2%20responce%20time.png"></p><ul><li><p><strong>服务器推送 server push</strong></p><ul><li><p>与传统的HTTP请求-响应模式不同，服务器推送不需要等待客户端的请求，而是由服务器在检测到客户端需要某些资源时<strong>主动将这些资源推送给客户端</strong></p></li><li><p>客户端收到其他资源后，这些资源将<strong>存储在浏览器缓存中</strong>。当在解析入口文件时发现资源时，浏览器可以快速从缓存中获取资源，而不必向服务器发出 HTTP 请求</p></li><li><p>由于服务器无法知道客户端是否已经缓存了这些资源，因此即使已经存在于客户端的HTTP缓存中，服务器也可能会继续推送这些资源，导致客户端重复获取相同的资源。</p><p>  PRPL模式提出了一种解决方案。它在页面初始加载完成后利用<strong>Service Worker</strong>来缓存这些额外的资源。这样，即使服务器再次推送相同的资源，客户端也可以通过Service Worker从本地缓存中获取这些资源，而不必再次从服务器请求。这样就避免了不必要的网络请求，提高了页面加载速度和用户体验。</p></li></ul></li></ul><h2 id="🌙lighthouse"><a href="#🌙lighthouse" class="headerlink" title="🌙lighthouse"></a>🌙lighthouse</h2><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Lighthouse 运行测评的过程有一套完整的生命周期，可以划分成三个主要流程：</p><ul><li><p><strong>Collecting（收集数据）：</strong>这一步会调用内置的<strong>驱动程序</strong>（Driver） ，其作用是通过谷歌开发工具协议（ Chrome DevTools Protocol） <strong>调起浏览器</strong>，并创建新的 tab 请求待测评的站点，通过浏览器<strong>采集站点数据</strong>并将结果（称之为 Artifacts）保存在本地临时目录。</p></li><li><p><strong>Auditing（分析数据）：</strong>这一步读取 Artifacts 数据，根据内置的评判策略逐条进行检查并计算出各项的数字形式得分。</p></li><li><p><strong>Report（生成报告）：</strong>这个流程将评分结果按照 <strong>PWA、性能、无障碍访问、最佳实践</strong>等纬度进行划分，以 JSON、HTML 等格式输出。</p></li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/1424359-20210105180027391-233543594.png"></p><blockquote><p><strong>PWA</strong></p><p>渐进式网页应用（ProgressiveWebApp）</p><p>PWA 可以在浏览器上访问，也可以单独安装成一个应用在系统上。</p><p>当Chrome检测到当前访问的网页支持PWA的时候，在地址栏的右端就会出现一个安装按钮，点击即可将这个PWA变成一个应用安装到浏览器中。</p><p>而在Android上，使用Chrome浏览PWA站点时也会有相应的提示，添加到应用之后就会自动进行编译安装。iOS上面使用Safari打开网站然后在菜单中选择添加到Home Screen就可以了，之后点开应用图标就会以独立应用形式出现，而不是通过Safari加载网页。</p></blockquote><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240321202000812.png"></p><h4 id="一些指标"><a href="#一些指标" class="headerlink" title="一些指标"></a>一些指标</h4><ul><li><p><strong>性能</strong></p><ul><li>首次内容绘制、可交互时间、速度指标</li></ul></li><li><p><strong>访问无障碍</strong></p><ul><li>相关指标，比如屏幕阅读器友好</li></ul></li><li><p><strong>最佳实践</strong></p><ul><li>比如推荐使用 https，跨域的跳转链接需要使用 rel 标识，不能使用废弃的 API等等</li></ul></li><li><p><strong>搜索引擎优化</strong></p><ul><li>比如图片元素使用 alt 属性等等提高搜索引擎搜索排名，便于搜索引擎能找到你这个网站</li></ul></li></ul><blockquote><p>可以测试自己的网站，在开发过程中持续监测和改进</p><p>以下是上述pattern.dev网页的分析报告:</p></blockquote><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240321121047072.png"></p><h2 id="💡Preload"><a href="#💡Preload" class="headerlink" title="💡Preload"></a>💡Preload</h2><h4 id="预加载资源"><a href="#预加载资源" class="headerlink" title="预加载资源"></a>预加载资源</h4><p>preload 提供了一种声明式的命令，让浏览器**提前加载指定资源(加载后并不执行)**，在需要执行的时候再执行。提供的好处主要是</p><ul><li><strong>将加载和执行分离开</strong>，可不阻塞渲染和 document 的 onload 事件</li><li>通过提前加载指定资源，<strong>可以提高网页的性能和用户体验</strong>，尤其是对于关键资源，如字体、CSS 文件、JavaScript 文件等。</li></ul><blockquote><ul><li>加载<ul><li>加载指的是将 JavaScript 文件从服务器下载到浏览器的过程</li></ul></li><li>执行<ul><li>执行指的是浏览器解析和执行 JavaScript 代码的过程</li></ul></li></ul></blockquote><h4 id="使用preload"><a href="#使用preload" class="headerlink" title="使用preload"></a>使用<code>preload</code></h4><ul><li><p><strong>语法</strong></p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;url/to/preload&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;type&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>as</code>可选属性</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/1717126a3578ca8a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png"></p><h4 id="关于prefetch"><a href="#关于prefetch" class="headerlink" title="关于prefetch"></a>关于<code>prefetch</code></h4><ul><li><p><code>prefetch</code> 用于在浏览器空闲时<strong>预先请求未来可能需要的资源</strong>，以加快后续页面加载速度。它告诉浏览器这些资源可能会在将来的页面中用到，但当前页面并不需要立即使用。</p></li><li><p>语法</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;url/to/preload&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><p><strong>字体提前加载</strong></p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;font.woff2&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;font&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;font/woff2&quot;</span> <span class="hljs-attr">crossorigin</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>动态加载，但不执行</strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 预先加载脚本</span><br><span class="hljs-keyword">let</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;link&quot;</span>);<br>link.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;myscript.js&quot;</span>;<br>link.<span class="hljs-property">rel</span> = <span class="hljs-string">&quot;preload&quot;</span>;<br>link.<span class="hljs-property">as</span> = <span class="hljs-string">&quot;script&quot;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(link);<br><br><span class="hljs-comment">// 立即执行脚本</span><br><span class="hljs-keyword">let</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;myscript.js&quot;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br></code></pre></td></tr></table></figure></li><li><p><strong>基于标记语言的异步加载</strong></p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span></span><br><span class="hljs-tag">  <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;async_script.js&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;let script = document.createElement(&#x27;script&#x27;); script.src = this.href; document.body.appendChild(script);&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure><p>  这一段话首先创建一个链接，然后设置脚本路径，再加载完成之后把脚本添加到页面中，这样异步操作可以保证</p></li></ul><h2 id="💡Render"><a href="#💡Render" class="headerlink" title="💡Render"></a>💡Render</h2><p>如果你的资源影响了你的 <a href="https://web.dev/articles/user-centric-performance-metrics#first_paint_and_first_contentful_paint">First Paint</a> ,lighthouse会给出一个警告：</p><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/17390a45499da7d6~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"></p><ul><li><p><strong>内联关键 JavaScript 和 CSS</strong></p><ul><li>将关键的 JavaScript 和 CSS 直接嵌入到 HTML 页面中，可以减少由于请求这些资源而引起的延迟。这可以通过将 JavaScript 使用 <strong><code>async</code> 属性异步加载</strong>，以及将<strong>关键 CSS 内联到页面头部</strong>来实现。</li><li>然而，内联代码会增加 HTML 文件的大小，并且不易维护，因为所有的代码都在一个文件中。此外，内联的资源也无法被浏览器单独缓存，因为它们与页面内容混合在一起。</li></ul></li><li><p><strong>服务器端渲染（Server-Side Rendering，SSR）</strong></p><ul><li>在服务器端生成页面的 HTML，然后将其发送给客户端。这样，在客户端加载 JavaScript 和执行脚本之前，用户就可以立即看到页面内容。</li><li>这可以改善页面的首次渲染时间，因为它减少了用户等待的时间。然而，SSR 可能会增加 HTML 文件的大小，导致页面下载时间延长。另外，它也会增加服务器端的负载和复杂性。</li></ul></li></ul><h2 id="💡Pre-cache"><a href="#💡Pre-cache" class="headerlink" title="💡Pre-cache"></a>💡Pre-cache</h2><p><img src="https://web.dev/static/articles/apply-instant-loading-with-prpl/image/requestsresponses-servi-9af9ccb5be804.png"></p><ul><li><p><strong>Service Worker</strong></p><ul><li>服务工作线程充当浏览器和网络之间的<strong>代理</strong>，它可以<strong>拦截网络请求</strong>，并且可以<strong>将资源直接从缓存中获取</strong>，而不必每次都从服务器请求资源。</li><li>这样可以提高页面加载速度，尤其是在用户重复访问应用程序时。</li></ul></li><li><p><strong>pre-cache</strong></p><ul><li>通过在服务工作线程中实现<strong>预缓存逻辑</strong>，可以将应用程序所需的核心资源提前缓存到本地。这样，在用户首次访问应用程序时，这些资源就已经存在于本地缓存中，可以直接从缓存中获取，而无需等待服务器响应。</li><li>这不仅提高了页面加载速度，还使得用户可以在离线状态下访问应用程序。</li></ul></li><li><p><strong>使用第三方库简化生成Service Worker</strong></p><ul><li>为了简化服务工作线程的创建和管理，可以使用第三方库，例如Workbox。</li></ul></li></ul><h2 id="💡Lazy-load"><a href="#💡Lazy-load" class="headerlink" title="💡Lazy load"></a>💡Lazy load</h2><p>如果你的网站加载太多资源，lighthouse会提示你：</p><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/17390b6e260cfd91~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp"></p><ul><li><p>为了首次加载更小的JavaScript，其中只包含可以尝试<strong>拆分bundle</strong>，对于剩下的资源按需要<strong>懒加载块</strong>。</p></li><li><p>如果你成功的拆分了bundle，给重要的chunk加上preload，浏览器会提高下载的优先级。</p></li></ul><h2 id="⭐Conclusion"><a href="#⭐Conclusion" class="headerlink" title="⭐Conclusion"></a>⭐Conclusion</h2><p>PRPL 模式的关键思想是尽可能快地加载应用程序的关键部分，并在后续页面使用中继续提供良好的性能</p><ol><li><strong>Preload（预加载）</strong>：在页面加载期间，<strong>服务器可以向客户端推送关键资源</strong>，例如 HTML、CSS、JavaScript 等。这些资源可以通过 HTTP&#x2F;2 的服务器推送功能或其他技术来实现。</li><li><strong>Render（渲染）</strong>：在加载阶段，应用程序应该尽可能快地开始渲染页面内容，以使用户尽快看到有用的信息。这意味着应用程序应该<strong>优先加载和渲染视觉上的关键内容</strong>，而不是等待所有资源都加载完毕后再进行渲染。</li><li><strong>Pre-cache（预缓存）</strong>：在首次访问应用程序时，可以<strong>通过Service Worker将关键资源预先缓存到客户端</strong>，以便后续页面使用时可以直接从缓存中获取。</li><li><strong>Lazy-load（延迟加载）</strong>：延迟加载是指在后续页面使用时<strong>动态加载额外的资源</strong>，而不是在页面初始加载阶段加载所有资源。</li></ol><h2 id="📕Reference"><a href="#📕Reference" class="headerlink" title="📕Reference"></a>📕Reference</h2><ul><li><p><a href="https://www.patterns.dev/vanilla/prpl">PRPL pattern</a></p></li><li><p><a href="https://www.wallarm.com/what/what-is-http-2-and-how-is-it-different-from-http-1">HTTP&#x2F;1 vs. HTTP&#x2F;2</a></p></li><li><p><a href="https://www.cnblogs.com/wenxuehai/p/14236426.html">性能评测工具 lighthouse</a></p></li><li><p><a href="https://web.dev/articles/apply-instant-loading-with-prpl">Apply instant loading with the PRPL pattern</a></p></li><li><p><a href="https://juejin.cn/post/6844904122529873933">前端预加载资源preload</a></p></li></ul><h6 id=""><a href="#" class="headerlink" title=""></a></h6>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js代理</title>
    <link href="/2024/03/19/js%E4%BB%A3%E7%90%86/"/>
    <url>/2024/03/19/js%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="代理proxy"><a href="#代理proxy" class="headerlink" title="代理proxy"></a>代理proxy</h3><ul><li><p>MDN定义：Proxy 对象用于<strong>定义基本操作的自定义行为</strong>（如属性查找，赋值，枚举，函数调用等）</p></li><li><p>通俗的讲Proxy是一个对象操作的拦截器，拦截对目标对象的操作，进行一些自定义的行为</p></li><li><p>可以给<strong>目标对象</strong>(target)定义一个<strong>关联的代理对象</strong>，而这个代理对象可<strong>当作一个抽象的目标对象来使用</strong></p></li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/53ea02f2ff984d50a1c21818c4706282~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="proxy的作用.png"></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSO | Single Sign-On</title>
    <link href="/2024/03/17/SSO%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/17/SSO%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="🔑-SSO-Single-Sign-On-单点登录"><a href="#🔑-SSO-Single-Sign-On-单点登录" class="headerlink" title="🔑 SSO | Single Sign-On 单点登录"></a>🔑 SSO | Single Sign-On 单点登录</h1><p>单点登录全称Single Sign On（以下简称SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/mvgyfyd1cq.jpeg" alt="img"></p><ul><li>用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为<strong>全局会话</strong>，用户与各个子系统建立的会话称为<strong>局部会话</strong>，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系<ul><li>局部会话存在，全局会话一定存在</li><li>全局会话存在，局部会话不一定存在</li><li>全局会话销毁，局部会话必须销毁</li></ul></li></ul><h3 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h3><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/w0719vs47g.jpeg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯备赛笔记 | Web开发</title>
    <link href="/2024/03/01/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/01/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E8%B5%9B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>🚀2024蓝桥杯倒计时五十天…为什么当时报名了web组啊，应该报python组啊。好吧，既来之则安之</p><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h2><p>Grid 布局是一种强大的 CSS 布局系统，它提供了一系列用于定义网格布局的属性。以下是一些常用的 Grid 布局属性：</p><ol><li><p><code>display</code>：指定元素的布局类型为网格布局。例如：<code>display: grid;</code></p></li><li><p><code>grid-template-rows</code> 和 <code>grid-template-columns</code>：定义网格的行和列结构。可以设置固定的长度值（如像素或百分比），也可以使用关键字（如 <code>auto</code>、<code>min-content</code>、<code>max-content</code>）或网格轨道（grid tracks）函数。</p></li><li><p><code>grid-template-areas</code>：通过指定网格区域的名称来定义网格布局。可以使用网格区域名称创建一个网格模板，并将元素放置在相应的区域内。</p></li><li><p><code>grid-gap</code> 或 <code>gap</code>：定义网格单元之间的间距。可以同时指定行间距和列间距，或者使用 <code>row-gap</code> 和 <code>column-gap</code> 分别指定行间距和列间距。</p></li><li><p><code>grid-auto-rows</code> 和 <code>grid-auto-columns</code>：指定自动布局的行和列的大小。当网格容器中的网格项目无法适应显式定义的网格轨道时，这些属性定义了自动创建的隐式网格轨道的大小。</p></li><li><p><code>grid-auto-flow</code>：定义如何分配自动布局的项目。可以指定为 <code>row</code>（从左到右，逐行排序）、<code>column</code>（从上到下，逐列排序）、<code>dense</code>（尽量填充空白单元格）等。</p></li><li><p><code>justify-items</code> 和 <code>align-items</code>：定义网格项目在单元格中的对齐方式。<code>justify-items</code> 控制水平方向的对齐，而 <code>align-items</code> 控制垂直方向的对齐。</p></li><li><p><code>justify-content</code> 和 <code>align-content</code>：定义网格容器内网格行和列的对齐方式。<code>justify-content</code> 控制水平方向的对齐，而 <code>align-content</code> 控制垂直方向的对齐。</p></li><li><p><code>justify-self</code> 和 <code>align-self</code>：定义单个网格项目在单元格内的对齐方式。<code>justify-self</code> 控制水平方向的对齐，而 <code>align-self</code> 控制垂直方向的对齐。</p></li></ol><p>这只是 Grid 布局提供的一些常用属性。Grid 布局还有其他一些属性，如 <code>grid-column-start</code>、<code>grid-column-end</code>、<code>grid-row-start</code>、<code>grid-row-end</code> 等，用于更精确地控制网格项目的位置和大小。通过组合和使用这些属性，可以创建出复杂而灵活的网格布局。</p><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>Flex 布局（Flexbox）是一种用于创建灵活的、响应式的页面布局的 CSS 布局系统。以下是一些常用的 Flex 布局属性：</p><ol><li><p><code>display</code>：指定元素的布局类型为 Flex 布局。例如：<code>display: flex;</code></p></li><li><p><code>flex-direction</code>：定义 Flex 容器中 Flex 项目的排列方向。可以设置为 <code>row</code>（水平方向，从左到右）、<code>row-reverse</code>（水平方向，从右到左）、<code>column</code>（垂直方向，从上到下）、<code>column-reverse</code>（垂直方向，从下到上）。</p></li><li><p><code>flex-wrap</code>：定义当 Flex 容器的 Flex 项目在一条轴线上放不下时是否换行。可以设置为 <code>nowrap</code>（不换行）、<code>wrap</code>（换行，从上到下）或 <code>wrap-reverse</code>（换行，从下到上）。</p></li><li><p><code>justify-content</code>：定义 Flex 项目在主轴方向上的对齐方式。控制 Flex 项目沿主轴的水平对齐方式。可以设置为 <code>flex-start</code>（靠左对齐）、<code>flex-end</code>（靠右对齐）、<code>center</code>（居中对齐）、<code>space-between</code>（两端对齐，项目之间间隔相等）等。</p></li><li><p><code>align-items</code>：定义 Flex 项目在交叉轴方向上的对齐方式。控制 Flex 项目沿交叉轴的垂直对齐方式。可以设置为 <code>flex-start</code>（靠上对齐）、<code>flex-end</code>（靠下对齐）、<code>center</code>（居中对齐）、<code>baseline</code>（基线对齐）等。</p></li><li><p><code>align-content</code>：定义多行 Flex 项目在交叉轴方向上的对齐方式。当有多行 Flex 项目时，控制这些行在交叉轴上的对齐方式。可以设置为 <code>flex-start</code>（靠上对齐）、<code>flex-end</code>（靠下对齐）、<code>center</code>（居中对齐）、<code>space-between</code>（两端对齐，行之间间隔相等）等。</p></li><li><p><code>flex-grow</code>：定义 Flex 项目的放大比例。指定 Flex 项目在剩余空间中相对于其他 Flex 项目的放大比例。默认为 0，即不放大。</p></li><li><p><code>flex-shrink</code>：定义 Flex 项目的缩小比例。指定 Flex 项目在空间不足时相对于其他 Flex 项目的缩小比例。默认为 1，即等比例缩小。</p></li><li><p><code>flex-basis</code>：定义 Flex 项目在主轴上的初始大小。可以设置为固定长度值（如像素或百分比）或 <code>auto</code>（根据内容自动计算大小）。</p></li><li><p><code>flex</code>：是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 的简写形式。可以将这三个属性合并为一个属性进行设置。例如：<code>flex: 1 1 auto;</code></p></li></ol><p>这些是 Flex 布局提供的一些常用属性。通过组合和使用这些属性，可以创建出灵活、自适应的页面布局。</p><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>CSS 盒模型是描述 HTML 元素在页面布局中所占空间的一种模型。它由内容区域（content）、内边距（padding）、边框（border）和外边距（margin）组成。这些部分围绕在一个内容区域，构成了一个矩形的盒子，用来表示和布局页面上的元素。</p><p>具体来说，盒模型可以分为两种：标准盒模型和怪异盒模型（IE 盒模型）。它们的区别在于对元素的宽度和高度的计算方式不同。</p><ol><li><p>标准盒模型：</p><ul><li>元素的宽度（width）和高度（height）只包括内容区域的尺寸。</li><li>内边距（padding）、边框（border）和外边距（margin）是在内容区域之外添加的，不会影响元素的宽度和高度。</li></ul></li><li><p>怪异盒模型（IE 盒模型）：</p><ul><li>元素的宽度（width）和高度（height）包括了内容区域、内边距（padding）和边框（border）的尺寸，但不包括外边距（margin）。</li><li>元素的宽度和高度是指定的内容区域的尺寸加上内边距和边框的尺寸。</li></ul></li></ol><p>在 CSS 中，我们可以通过 <code>box-sizing</code> 属性来控制盒模型的类型：</p><ul><li><code>box-sizing: content-box;</code> 表示标准盒模型。</li><li><code>box-sizing: border-box;</code> 表示怪异盒模型。</li></ul><p>盒模型在页面布局中非常重要，它影响了元素的尺寸计算、边距合并以及布局的方式。了解盒模型可以帮助我们更好地控制和调整页面元素的布局和样式。</p><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><h3 id="nth-of-type和nth-child"><a href="#nth-of-type和nth-child" class="headerlink" title="nth-of-type和nth-child"></a><code>nth-of-type</code>和<code>nth-child</code></h3><ul><li><code>nth-of-type</code>是父元素中<strong>指定类型</strong>的第几个子元素</li><li><code>nth-child</code>则没有指定类型，是所有子元素的第几个</li></ul><h2 id="文本溢出"><a href="#文本溢出" class="headerlink" title="文本溢出"></a>文本溢出</h2><ul><li><strong>单行文字溢出</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br><span class="hljs-attribute">text-overflow</span>: ellipsis;// 显示省略符号来代表被修剪的文本<br>    <span class="hljs-attribute">white-space</span>: nowrap; //文本不会换行，文本会在在同一行上继续，直到遇到标签为止<br>    <span class="hljs-attribute">overflow</span>: hidden;// 超出部分隐藏<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>多行文字溢出</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">display</span>: -webkit-box;<br>    -webkit-line-clamp: <span class="hljs-number">2</span>;<br>    -webkit-box-orient: vertical;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a><code>transform</code></h2><p><strong><code>transform</code> 属性</strong>：用于对元素进行平移、旋转、缩放或倾斜等变换操作。它可以接受多个变换函数，每个函数之间使用空格分隔。</p><ul><li>平移：<code>translate()</code> 函数，接受一个或两个参数，分别表示水平和垂直方向的位移。</li><li>旋转：<code>rotate()</code> 函数，接受一个参数，表示旋转的角度。</li><li>缩放：<code>scale()</code> 函数，接受一个或两个参数，分别表示水平和垂直方向的缩放比例。</li><li>倾斜：<code>skew()</code> 函数，接受一个或两个参数，分别表示水平和垂直方向的倾斜角度。</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.myElement</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>, <span class="hljs-number">50px</span>) <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.5</span>) <span class="hljs-built_in">skew</span>(<span class="hljs-number">10deg</span>, <span class="hljs-number">20deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h2><p><strong><code>filter</code> 属性</strong>：用于将模糊、饱和度、对比度、亮度、颜色偏移等图形效果应用于元素。它可以接受多个滤镜函数，每个函数之间使用空格分隔。</p><ul><li>模糊：<code>blur()</code> 函数，接受一个参数，表示模糊的程度。</li><li>饱和度：<code>saturate()</code> 函数，接受一个参数，表示饱和度的倍数。</li><li>对比度：<code>contrast()</code> 函数，接受一个参数，表示对比度的倍数。</li><li>亮度：<code>brightness()</code> 函数，接受一个参数，表示亮度的倍数。</li><li>颜色偏移：<code>hue-rotate()</code> 函数，接受一个参数，表示颜色的旋转角度。</li><li>阴影：<code>drop-shadow()</code> 函数，用于添加阴影效果。</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.myElement</span> &#123;<br>    <span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">5px</span>) <span class="hljs-built_in">saturate</span>(<span class="hljs-number">200%</span>) <span class="hljs-built_in">contrast</span>(<span class="hljs-number">150%</span>) <span class="hljs-built_in">brightness</span>(<span class="hljs-number">1.5</span>) <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">90deg</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><h3 id="filter-1"><a href="#filter-1" class="headerlink" title="filter()"></a><code>filter()</code></h3><p>JavaScript 中的 <code>filter()</code> 方法是数组对象的一个内置方法，用于创建一个新的数组，其中包含满足指定条件的原始数组元素。</p><p><code>filter()</code> 方法接受一个回调函数作为参数，该回调函数会对数组中的每个元素进行调用，并根据回调函数的返回值来确定是否包含该元素在结果数组中。回调函数接受三个参数：当前元素、当前索引和原始数组。</p><p>以下是 <code>filter()</code> 方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">filter</span>(<span class="hljs-title function_">callback</span>(element, index, array))<br></code></pre></td></tr></table></figure><ul><li><code>array</code>: 要操作的原始数组。</li><li><code>callback</code>: 回调函数，用于对数组的每个元素进行评估。</li><li><code>element</code>: 当前正在处理的数组元素。</li><li><code>index</code> (可选): 当前元素的索引。</li><li><code>array</code> (可选): 原始数组。</li></ul><p><code>filter()</code> 方法会遍历原始数组的每个元素，并将满足回调函数条件的元素添加到结果数组中。最后，它返回这个结果数组。</p><p>以下是一个简单的例子，演示如何使用 <code>filter()</code> 方法来筛选出数组中大于 5 的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>];<br><br><span class="hljs-keyword">const</span> filteredNumbers = numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span> number &gt; <span class="hljs-number">5</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(filteredNumbers); <span class="hljs-comment">// 输出 [6, 7, 8, 9, 10]</span><br></code></pre></td></tr></table></figure><p>在上述例子中，<code>filter()</code> 方法根据回调函数 <code>(number) =&gt; number &gt; 5</code> 的返回值来决定元素是否包含在结果数组中。</p><h3 id="search"><a href="#search" class="headerlink" title="search()"></a><code>search()</code></h3><p>在 JavaScript 中，<code>search()</code> 是字符串对象的一个内置方法，用于搜索字符串中与指定正则表达式匹配的第一个位置。</p><p><code>search()</code> 方法接受一个正则表达式作为参数，并返回匹配结果的索引。如果找到匹配项，则返回第一个匹配项的索引；如果未找到匹配项，则返回 -1。</p><p>以下是 <code>search()</code> 方法的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">search</span>(regexp)<br></code></pre></td></tr></table></figure><ul><li><code>string</code>: 要搜索的字符串。</li><li><code>regexp</code>: 要匹配的正则表达式。</li></ul><p>下面是一个简单的例子，演示如何使用 <code>search()</code> 方法来搜索字符串中的特定模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;Hello, world!&#x27;</span>;<br><br><span class="hljs-keyword">const</span> position = str.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/world/</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(position); <span class="hljs-comment">// 输出 7</span><br></code></pre></td></tr></table></figure><p>在上述例子中，<code>search()</code> 方法使用正则表达式 <code>/world/</code> 来搜索字符串 <code>str</code> 中是否包含 “world”。由于 “world” 出现在索引 7 处，因此 <code>search()</code> 方法返回 7。</p><p>需要注意的是，<code>search()</code> 方法只返回第一个匹配项的索引。如果你需要获取更多关于匹配项的信息（如匹配的文本、多个匹配项等），可以考虑使用 <code>match()</code> 方法或利用正则表达式的 <code>exec()</code> 方法。</p><h3 id="flat"><a href="#flat" class="headerlink" title="flat()"></a><code>flat()</code></h3><p><code>flat()</code> 是 <code>JavaScript</code> 数组的⼀个⽅法，⽤于<strong>将多维数组扁平化为⼀维数组</strong>。</p><p>该⽅法可以接收⼀个整数参数，表示要扁平化的嵌套层数。例如，如果传递参数 2 ，则会将⼆维数组扁 平化为⼀维数组，但不会将三维及以上的数组扁平化。</p><p>如果不传递参数，则<strong>默认值扁平化⼀层</strong>。如果数组中有空位（即未定义的元素），则 <code>ﬂat()</code> ⽅法默认会将其删除，返回⼀个新的不含空位的数组。</p><p>以下是 <code>ﬂat()</code> ⽅法的示例⽤法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br><br>arr1.<span class="hljs-title function_">flat</span>(); <span class="hljs-comment">// [1, 2, 3, 4]</span><br><br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]];<br><br>arr2.<span class="hljs-title function_">flat</span>(); <span class="hljs-comment">// [1, 2, 3, 4, [5, 6]]</span><br><br><span class="hljs-keyword">const</span> arr3 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]];<br><br>arr3.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><p>在上⾯的示例中，<code>arr1</code> 和 <code>arr2</code> 数组中的嵌套数组都被扁平化为了⼀维数组。在 <code>arr3</code> 中，<code>flat(2)</code> ⽅法将嵌套数组扁平化了两层，⽣成了⼀个包含所有元素的⼀维数组。</p><h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a><code>includes()</code></h3><p><code>includes</code> 是 JavaScript 中数组和字符串的方法之一。它用于检查数组或字符串是否包含特定的值，并返回一个布尔值，指示是否找到了指定的值。</p><p>对于数组来说，<code>includes</code> 方法用于检查数组中是否包含某个特定的元素。如果包含，则返回 <code>true</code>；否则返回 <code>false</code>。语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.<span class="hljs-title function_">includes</span>(valueToFind[, fromIndex])<br></code></pre></td></tr></table></figure><ul><li><code>valueToFind</code>：要查找的值。</li><li><code>fromIndex</code>（可选）：从哪个索引开始搜索。如果省略，则默认从索引 0 开始搜索。如果 <code>fromIndex</code> 大于等于数组长度，则直接返回 <code>false</code>。</li></ul><p>对于字符串来说，<code>includes</code> 方法用于检查字符串是否包含特定的子字符串。如果包含，则返回 <code>true</code>；否则返回 <code>false</code>。语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">string.<span class="hljs-title function_">includes</span>(searchString[, position])<br></code></pre></td></tr></table></figure><ul><li><code>searchString</code>：要查找的子字符串。</li><li><code>position</code>（可选）：开始搜索的位置，默认为 0。如果 <code>position</code> 大于或等于字符串长度，则直接返回 <code>false</code>。</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">3</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array.<span class="hljs-title function_">includes</span>(<span class="hljs-number">6</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">const</span> string = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;world&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&quot;foo&quot;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>includes</code> 方法在判断某个元素或子字符串是否存在时很方便，特别是在条件语句中。</p><h3 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a><code>replaceAll()</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> paragraph = <span class="hljs-string">&quot;I think Ruth&#x27;s dog is cuter than your dog!&quot;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(paragraph.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;monkey&#x27;</span>));<br><span class="hljs-comment">// Expected output: &quot;I think Ruth&#x27;s monkey is cuter than your monkey!&quot;</span><br><br><span class="hljs-comment">// Global flag required when calling replaceAll with regex</span><br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/Dog/gi</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(paragraph.<span class="hljs-title function_">replaceAll</span>(regex, <span class="hljs-string">&#x27;ferret&#x27;</span>));<br><span class="hljs-comment">// Expected output: &quot;I think Ruth&#x27;s ferret is cuter than your ferret!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a><code>eval()</code></h3><p><code>eval()</code> 函数是 JavaScript 中的一个全局函数，它用于执行传入的字符串作为 JavaScript 代码，并返回执行结果。其基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(string)<br></code></pre></td></tr></table></figure><p>其中，<code>string</code> 参数是要执行的 JavaScript 代码的字符串表示形式。当 <code>eval()</code> 函数被调用时，传入的字符串将被解析和执行为 JavaScript 代码。</p><p>虽然 <code>eval()</code> 函数在某些情况下可以方便地执行动态生成的 JavaScript 代码，但它也存在安全风险和性能问题。因此，在实际开发中，应该尽量避免使用 <code>eval()</code> 函数，尤其是对用户输入的字符串进行求值，以防止代码注入和其他安全问题的发生。</p><p>另外，<code>eval()</code> 函数在严格模式下的行为可能会有所不同。在严格模式下，它无法在调用代码的作用域之外创建变量或函数。</p><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是两种常见的数据复制方式，它们在复制对象或数组时表现出不同的行为。让我为你详细解释一下：</p><ol><li><p><strong>浅拷贝（Shallow Copy）</strong>：</p><ul><li>浅拷贝是指创建一个新的对象或数组，将原始对象或数组的所有属性或元素复制到新对象或数组中。</li><li>如果对象或数组的属性值或元素是基本数据类型（如数字、字符串、布尔值等），那么在浅拷贝中，会<strong>直接复制这些值</strong>。这意味着原始对象和新对象中的这些属性或元素是完全独立的，互不影响。</li><li>但是，如果对象或数组的属性值或元素是引用类型（如对象、数组等），则浅拷贝<strong>只会复制引用</strong>，而不会复制引用指向的实际数据。这意味着原始对象和新对象中的这些属性或元素实际上是<strong>共享同一份数据的</strong>，修改其中一个会影响到另一个。</li></ul></li><li><p><strong>深拷贝（Deep Copy）</strong>：</p><ul><li>深拷贝是指创建一个新的对象或数组，并且<strong>递归地复制原始对象或数组的所有属性或元素，包括基本数据类型和引用类型</strong>。</li><li>深拷贝会创建原始对象或数组的完全独立的副本，新对象或数组中的所有属性或元素都与原始对象或数组中的对应项无关联。</li><li>即使原始对象或数组中的属性值或元素是引用类型，深拷贝也会复制引用指向的实际数据，而不是仅仅复制引用本身。这确保了新对象或数组中的引用类型数据是<strong>完全独立</strong>的，修改其中一个不会影响到另一个。</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">cartList</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cartList</span>));<br><span class="hljs-comment">// 深拷贝</span><br></code></pre></td></tr></table></figure><h2 id="拓展运算符"><a href="#拓展运算符" class="headerlink" title="拓展运算符"></a>拓展运算符</h2><p>在 ES6 中，”…”（三个连续的点）是一个扩展运算符（Spread Operator）的语法。它有以下几种主要的作用：</p><ul><li><strong>数组的展开</strong>：使用扩展运算符可以将一个数组展开为独立的元素。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...arr); <span class="hljs-comment">// 输出: 1 2 3</span><br></code></pre></td></tr></table></figure><ul><li><strong>函数调用时的参数传递</strong>：扩展运算符可以用于将一个数组作为参数传递给函数，并展开为独立的参数。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b, c</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(...numbers)); <span class="hljs-comment">// 输出: 6</span><br></code></pre></td></tr></table></figure><ul><li><strong>对象的展开</strong>：扩展运算符可以用于将一个对象展开为另一个对象的属性。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> obj1 = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj2 = &#123; ...obj1, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// 输出: &#123; x: 1, y: 2, z: 3 &#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>数组和对象的浅拷贝</strong>：通过扩展运算符可以创建数组和对象的浅拷贝。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> arrCopy = [...arr];<br><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> objCopy = &#123; ...obj &#125;;st objCopy = &#123; ...obj &#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是，扩展运算符只能在可迭代对象（如数组）或具有可枚举属性的对象上使用。它提供了一种方便的方式来处理数组和对象的展开、合并和复制操作，使代码更加简洁和易读。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式是一种用来匹配字符串模式的工具，它可以用来在文本中搜索、替换特定模式的文本，或者验证字符串是否符合某种模式。下面是正则表达式的基本语法：</p><ol><li><p><strong>普通字符</strong>：普通字符是正则表达式中的字母和数字，它们匹配自身。例如，正则表达式 <code>hello</code> 将会匹配字符串中的 “hello”。</p></li><li><p><strong>特殊字符</strong>：正则表达式中有一些特殊字符具有特殊的含义，它们不是按照字面意思匹配字符，而是具有一些特殊的功能。常用的特殊字符包括：</p><ul><li><code>.</code>：匹配任意一个字符。</li><li><code>^</code>：匹配输入的开始。</li><li><code>$</code>：匹配输入的结尾。</li><li><code>*</code>：匹配前面的子表达式零次或多次。</li><li><code>+</code>：匹配前面的子表达式一次或多次。</li><li><code>?</code>：匹配前面的子表达式零次或一次。</li><li><code>\</code>：转义字符，用于匹配特殊字符本身。</li></ul></li><li><p><strong>字符类</strong>：字符类用来匹配一个字符集中的任意一个字符。字符类由方括号 <code>[]</code> 组成。例如，<code>[abc]</code> 匹配字符 “a”、”b” 或 “c” 中的任意一个。</p></li><li><p><strong>反义字符类</strong>：使用 <code>^</code> 符号可以匹配除了字符类中的字符以外的任意字符。例如，<code>[^abc]</code> 匹配除了 “a”、”b” 和 “c” 以外的任意字符。</p></li><li><p><strong>量词</strong>：量词用来指定匹配字符的次数。常用的量词包括：</p><ul><li><code>&#123;n&#125;</code>：匹配前面的元素恰好出现 n 次。</li><li><code>&#123;n,&#125;</code>：匹配前面的元素至少出现 n 次。</li><li><code>&#123;n,m&#125;</code>：匹配前面的元素至少出现 n 次，最多出现 m 次。</li></ul></li><li><p><strong>分组</strong>：使用圆括号 <code>()</code> 可以将多个表达式组合成一个整体，并且可以对整体应用量词。例如，<code>(abc)+</code> 匹配 “abc” 出现一次或多次。</p></li><li><p><strong>转义字符</strong>：如果想要匹配正则表达式中的特殊字符本身，可以使用反斜杠 <code>\</code> 进行转义。例如，<code>\.</code> 可以匹配实际的句点字符。</p></li></ol><ul><li><code>g</code> 表示全局匹配模式，会尝试找到所有匹配的模式。</li></ul><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变<code>this</code>指向</h2><p><code>call</code>, <code>apply</code>, 和 <code>bind</code> 是 JavaScript 中用于改变函数执行上下文（即 <code>this</code> 的指向）的方法。它们的主要区别在于<strong>参数的传递方式和立即执行与延迟执行</strong>。</p><h3 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a><code>call</code> 方法</h3><p><code>call</code> 方法立即调用函数，并且允许你<strong>传入一个指定的 <code>this</code> 值以及一个参数列表</strong>。</p><p>语法：<code>function.call(thisArg, arg1, arg2, ...)</code></p><ul><li><code>thisArg</code>：指定函数执行时的上下文，即函数中的 <code>this</code> 的值。</li><li><code>arg1, arg2, ...</code>：函数执行时的参数列表。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>! I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.role&#125;</span>.`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;developer&#x27;</span><br>&#125;;<br><br>greet.<span class="hljs-title function_">call</span>(person, <span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-comment">// 输出：Hello, Alice! I&#x27;m developer.</span><br></code></pre></td></tr></table></figure><h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a><code>apply</code> 方法</h3><p><code>apply</code> 方法与 <code>call</code> 方法类似，但是参数传递的方式不同。**<code>apply</code> 方法接受一个包含参数的数组**。</p><p>语法：<code>function.apply(thisArg, [argsArray])</code></p><ul><li><code>thisArg</code>：指定函数执行时的上下文，即函数中的 <code>this</code> 的值。</li><li><code>argsArray</code>：一个数组或类数组对象，包含函数执行时的参数列表。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, age</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>! I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.role&#125;</span> and I&#x27;m <span class="hljs-subst">$&#123;age&#125;</span> years old.`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;developer&#x27;</span><br>&#125;;<br><br>greet.<span class="hljs-title function_">apply</span>(person, [<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">30</span>]); <span class="hljs-comment">// 输出：Hello, Alice! I&#x27;m developer and I&#x27;m 30 years old.</span><br></code></pre></td></tr></table></figure><h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a><code>bind</code> 方法</h3><p><code>bind</code> 方法与 <code>call</code> 和 <code>apply</code> 不同，它不会立即调用函数，而是<strong>返回一个新的函数，绑定了指定的 <code>this</code> 值和参数</strong>。</p><p>语法：<code>function.bind(thisArg, arg1, arg2, ...)</code></p><ul><li><code>thisArg</code>：指定函数执行时的上下文，即函数中的 <code>this</code> 的值。</li><li><code>arg1, arg2, ...</code>：函数执行时的参数列表。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>! I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.role&#125;</span>.`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> person = &#123;<br>  <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;developer&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> greetPerson = greet.<span class="hljs-title function_">bind</span>(person);<br><span class="hljs-title function_">greetPerson</span>(<span class="hljs-string">&#x27;Alice&#x27;</span>); <span class="hljs-comment">// 输出：Hello, Alice! I&#x27;m developer.</span><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li><code>call</code> 和 <code>apply</code> 立即调用函数，并且能够指定 <code>this</code> 值和参数列表。</li><li><code>call</code> 和 <code>apply</code> 的区别在于参数传递的方式：<code>call</code> 使用逐个传参，<code>apply</code> 使用数组传参。</li><li><code>bind</code> 返回一个新的函数，并且绑定了指定的 <code>this</code> 值和参数，但不会立即执行。</li></ul><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h2><p><code>v-model</code> 是 Vue.js 提供的一个指令，用于实现表单元素和 Vue 实例数据的双向绑定。它通常用于表单输入元素，例如文本框、复选框、单选按钮和选择框等。</p><p>使用 <code>v-model</code> 指令时，你需要将其绑定到表单元素上，并指定一个 Vue 实例中的数据属性作为参数。<code>v-model</code> 会自动将表单元素的值与 Vue 实例的数据属性进行双向绑定，即当表单元素的值发生变化时，Vue 实例中对应的数据属性也会跟着更新；反之，当 Vue 实例中的数据属性发生变化时，表单元素的值也会相应地更新。</p><p>下面是 <code>v-model</code> 的基本用法：</p><ul><li><strong>文本输入框</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue 实例中的数据</span><br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue!&#x27;</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，文本输入框中的内容会与 Vue 实例中的 <code>message</code> 数据属性进行双向绑定。当你在输入框中输入内容时，<code>message</code> 数据属性会实时更新；反之，当你在 Vue 实例中修改了 <code>message</code> 的值时，输入框中的内容也会实时更新。</p><ul><li><strong>复选框</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checked&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue 实例中的数据</span><br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">checked</span>: <span class="hljs-literal">false</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，复选框的选中状态会与 Vue 实例中的 <code>checked</code> 数据属性进行双向绑定。当你勾选或取消勾选复选框时，<code>checked</code> 数据属性会实时更新；反之，当你在 Vue 实例中修改了 <code>checked</code> 的值时，复选框的选中状态也会实时更新。</p><ul><li><strong>单选按钮</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;A&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;B&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue 实例中的数据</span><br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">selected</span>: <span class="hljs-string">&#x27;A&#x27;</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，选中的单选按钮的值会与 Vue 实例中的 <code>selected</code> 数据属性进行双向绑定。当你选中某个单选按钮时，<code>selected</code> 数据属性会更新为对应的值；反之，当你在 Vue 实例中修改了 <code>selected</code> 的值时，对应的单选按钮也会被选中。</p><ul><li><strong>下拉选择框</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;A&quot;</span>&gt;</span>Option A<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;B&quot;</span>&gt;</span>Option B<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;C&quot;</span>&gt;</span>Option C<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Vue 实例中的数据</span><br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">selected</span>: <span class="hljs-string">&#x27;A&#x27;</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，下拉选择框中选中的选项会与 Vue 实例中的 <code>selected</code> 数据属性进行双向绑定。当你选择了某个选项时，<code>selected</code> 数据属性会更新为对应的值；反之，当你在 Vue 实例中修改了 <code>selected</code> 的值时，下拉选择框中对应的选项也会被选中。</p><p>综上所述，<code>v-model</code> 指令使得表单元素和 Vue 实例的数据之间建立了双向绑定关系，使得数据的变化能够实时地反映到表单元素上，从而提高了开发效率。</p><h2 id="其他数据绑定和动态渲染"><a href="#其他数据绑定和动态渲染" class="headerlink" title="其他数据绑定和动态渲染"></a>其他数据绑定和动态渲染</h2><p>除了 <code>v-model</code> 外，Vue 还提供了一些其他的指令来实现数据绑定和动态渲染。下面是一些常用的 Vue 指令：</p><ol><li><p><strong>v-bind</strong>：用于动态绑定 HTML 属性。可以绑定 HTML 元素的任何属性，例如 <code>class</code>、<code>style</code>、<code>href</code> 等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>class</code> 属性根据 <code>isActive</code> 数据属性的值进行动态绑定，当 <code>isActive</code> 为 <code>true</code> 时，<code>active</code> 类会被添加到 <code>div</code> 元素中。</p></li><li><p><strong>v-if</strong> 和 <strong>v-else</strong>：用于条件渲染。根据表达式的值是否为真来添加或移除元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>Now you see me<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-else</span>&gt;</span>Now you don&#x27;t<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 <code>seen</code> 数据属性为 <code>true</code> 时，第一个 <code>p</code> 元素会显示；否则，第二个 <code>p</code> 元素会显示。</p></li><li><p><strong>v-for</strong>：用于循环渲染列表数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面的例子中，<code>v-for</code> 指令会循环遍历 <code>items</code> 数组中的每一个元素，并将每个元素的 <code>text</code> 属性显示在列表项中。</p></li><li><p><strong>v-on</strong>：用于绑定事件监听器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span>Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当按钮被点击时，<code>handleClick</code> 方法会被调用。</p></li><li><p><strong>v-show</strong>：根据表达式的值的真假来切换元素的显示状态，类似于 <code>v-if</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>Now you see me<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 <code>isShow</code> 数据属性为 <code>true</code> 时，<code>p</code> 元素会显示；否则，<code>p</code> 元素会隐藏，但它仍然存在于 DOM 中。</p></li></ol><p>这些指令是 Vue.js 中常用的数据绑定和动态渲染的方法，通过合理的使用这些指令，你可以更灵活地处理数据和界面的交互。</p><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>Vuex 是 Vue.js 的官方状态管理库，用于集中管理应用中的所有组件的状态。它基于全局状态管理模式，将状态存储在一个全局对象中，并通过一些特定的方法进行状态的更新和获取。</p><p>下面是 Vuex Store 的基本用法：</p><ol><li><p><strong>安装 Vuex</strong>：首先，您需要在项目中安装 Vuex。您可以使用 npm 或 yarn 来安装 Vuex：</p> <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install vuex <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p> 或者</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">yarn <span class="hljs-built_in">add</span> vuex<br></code></pre></td></tr></table></figure></li><li><p><strong>创建 Store</strong>：接下来，您需要创建一个 Vuex Store。这通常是在项目的根目录下的一个单独的文件中完成。一个基本的 Vuex Store 可能如下所示：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// store.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>      state.<span class="hljs-property">count</span>++;<br>    &#125;,<br>    <span class="hljs-title function_">decrement</span>(<span class="hljs-params">state</span>) &#123;<br>      state.<span class="hljs-property">count</span>--;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">context</span>) &#123;<br>      context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-title function_">decrement</span>(<span class="hljs-params">context</span>) &#123;<br>      context.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;decrement&#x27;</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-attr">getCount</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>在应用中使用 Store</strong>：一旦创建了 Vuex Store，您可以在应用程序的入口文件中将其引入，并通过 Vue 实例的 <code>store</code> 选项将其注入到根组件中：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  store,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>在组件中使用 Store</strong>：一旦 Store 注入到了根组件中，您可以通过在组件中使用 <code>this.$store</code> 来访问 Store 中的状态和方法。例如，在组件中使用 <code>mapState</code> 辅助函数来获取状态：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyComponent.vue</span><br><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrement&quot;</span>&gt;</span>Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; mapState, mapActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;count&#x27;</span>])</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    ...<span class="hljs-title function_">mapActions</span>([<span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-string">&#x27;decrement&#x27;</span>])</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ol><p>这就是基本的 Vuex Store 的用法。它允许您在应用中集中管理和共享状态，并通过一系列的约定和方法来确保状态的一致性和可维护性。</p><h1 id="Echart"><a href="#Echart" class="headerlink" title="Echart"></a>Echart</h1><p>ECharts 是一个用于构建交互式的图表和可视化数据的开源库。它提供了丰富的图表类型和灵活的配置选项，可以轻松创建各种图表，如折线图、柱状图、饼图等。</p><p>以下是 ECharts 的基本语法：</p><ol><li><p><strong>引入 ECharts 库：</strong> 在 HTML 文件中引入 ECharts 库的 JavaScript 文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;echarts.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>创建图表容器：</strong> 在 HTML 中创建一个用于显示图表的容器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chart&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 600px; height: 400px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>初始化图表：</strong> 在 JavaScript 中初始化图表对象，并指定图表容器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> chart = echarts.<span class="hljs-title function_">init</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;chart&#x27;</span>));<br></code></pre></td></tr></table></figure></li><li><p><strong>配置图表选项：</strong> 使用 JavaScript 对象来配置图表的各种选项，如标题、数据系列、坐标轴等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> option = &#123;<br>    <span class="hljs-attr">title</span>: &#123;<br>        <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;折线图示例&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">xAxis</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;category&#x27;</span>,<br>        <span class="hljs-attr">data</span>: [<span class="hljs-string">&#x27;周一&#x27;</span>, <span class="hljs-string">&#x27;周二&#x27;</span>, <span class="hljs-string">&#x27;周三&#x27;</span>, <span class="hljs-string">&#x27;周四&#x27;</span>, <span class="hljs-string">&#x27;周五&#x27;</span>, <span class="hljs-string">&#x27;周六&#x27;</span>, <span class="hljs-string">&#x27;周日&#x27;</span>]<br>    &#125;,<br>    <span class="hljs-attr">yAxis</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;value&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">series</span>: [&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;line&#x27;</span>,<br>        <span class="hljs-attr">data</span>: [<span class="hljs-number">120</span>, <span class="hljs-number">200</span>, <span class="hljs-number">150</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>, <span class="hljs-number">110</span>, <span class="hljs-number">130</span>]<br>    &#125;]<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>设置图表选项：</strong> 使用 <code>setOption()</code> 方法将配置好的选项应用到图表中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">chart.<span class="hljs-title function_">setOption</span>(option);<br></code></pre></td></tr></table></figure></li></ol><p>通过以上步骤，就可以在页面中创建并显示一个简单的折线图。ECharts 还提供了丰富的配置选项和 API，可以实现更丰富和复杂的图表效果，如动画、交互、数据筛选等。</p><p>在 ECharts 中，<code>xAxis</code> 和 <code>yAxis</code> 是用来配置图表的 X 轴和 Y 轴的参数的。这些参数可以设置图表的轴类型、刻度、标签样式等。</p><p>下面是 <code>xAxis</code> 和 <code>yAxis</code> 中常用的参数说明：</p><h3 id="xAxis（X-轴配置项）："><a href="#xAxis（X-轴配置项）：" class="headerlink" title="xAxis（X 轴配置项）："></a>xAxis（X 轴配置项）：</h3><ul><li><p><strong>type</strong>：设置 X 轴的类型，可选值包括：</p><ul><li><code>&#39;category&#39;</code>：类目轴，适用于离散的类目数据，如名称、时间等。</li><li><code>&#39;value&#39;</code>：数值轴，适用于连续的数值数据。</li><li><code>&#39;time&#39;</code>：时间轴，适用于时间序列数据。</li></ul></li><li><p><strong>data</strong>：设置 X 轴的类目数据，在 <code>type</code> 为 <code>&#39;category&#39;</code> 时使用，表示 X 轴上的刻度标签。</p></li><li><p><strong>name</strong>：设置 X 轴的名称。</p></li><li><p><strong>nameTextStyle</strong>：设置 X 轴名称的样式，可以设置字体大小、颜色等。</p></li><li><p><strong>axisLabel</strong>：设置刻度标签的样式，可以设置字体大小、颜色等。</p></li></ul><h3 id="yAxis（Y-轴配置项）："><a href="#yAxis（Y-轴配置项）：" class="headerlink" title="yAxis（Y 轴配置项）："></a>yAxis（Y 轴配置项）：</h3><ul><li><p><strong>type</strong>：设置 Y 轴的类型，可选值同 <code>xAxis</code> 中的 <code>type</code>。</p></li><li><p><strong>name</strong>：设置 Y 轴的名称。</p></li><li><p><strong>nameTextStyle</strong>：设置 Y 轴名称的样式。</p></li><li><p><strong>axisLabel</strong>：设置刻度标签的样式。</p></li><li><p><strong>min</strong> 和 <strong>max</strong>：设置 Y 轴的最小值和最大值，用于控制 Y 轴的范围。</p></li><li><p><strong>splitNumber</strong>：设置 Y 轴的分割段数。</p></li></ul><p>这些参数可以根据具体需求进行设置，以实现不同样式和功能的 X 轴和 Y 轴。例如，如果你需要一个类目轴，你可以将 <code>type</code> 设置为 <code>&#39;category&#39;</code>，并在 <code>data</code> 中传入对应的类目数据；如果需要数值轴，你可以将 <code>type</code> 设置为 <code>&#39;value&#39;</code>，并设置 <code>min</code> 和 <code>max</code> 来控制轴的范围。</p><h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>Node.js 的 <code>http</code> 模块用于创建 HTTP 服务器和客户端。以下是 <code>http</code> 模块的基础语法：</p><ol><li><strong>创建 HTTP 服务器</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br><span class="hljs-comment">// 创建 HTTP 服务器</span><br><span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理请求并发送响应</span><br>  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span> &#125;);<br>  res.<span class="hljs-title function_">end</span>(<span class="hljs-string">&#x27;Hello, World!\n&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">// 服务器监听端口</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3000</span>;<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Server is running on port <span class="hljs-subst">$&#123;PORT&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>处理请求和发送响应</strong>：</li></ol><p>HTTP 服务器通过传入的回调函数来处理请求。回调函数接收两个参数：<code>req</code>（请求对象）和 <code>res</code>（响应对象）。在回调函数中，你可以读取请求的数据、设置响应头和发送响应内容。</p><ol start="3"><li><strong>创建 HTTP 客户端</strong>：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><br><span class="hljs-comment">// 发送 HTTP 请求</span><br><span class="hljs-keyword">const</span> options = &#123;<br>  <span class="hljs-attr">hostname</span>: <span class="hljs-string">&#x27;www.example.com&#x27;</span>,<br>  <span class="hljs-attr">port</span>: <span class="hljs-number">80</span>,<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> req = http.<span class="hljs-title function_">request</span>(options, <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`statusCode: <span class="hljs-subst">$&#123;res.statusCode&#125;</span>`</span>);<br><br>  res.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received data: <span class="hljs-subst">$&#123;chunk&#125;</span>`</span>);<br>  &#125;);<br>&#125;);<br><br>req.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Request error: <span class="hljs-subst">$&#123;error&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-comment">// 发送请求</span><br>req.<span class="hljs-title function_">end</span>();<br></code></pre></td></tr></table></figure><p>在此示例中，我们使用 <code>http.request()</code> 方法创建了一个 HTTP 请求对象 <code>req</code>，然后通过 <code>req.end()</code> 方法发送请求。一旦响应可用，回调函数将被调用，我们可以在其中处理响应数据。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT | Software Construction</title>
    <link href="/2024/02/26/Software-Construction/"/>
    <url>/2024/02/26/Software-Construction/</url>
    
    <content type="html"><![CDATA[<h1 id="🚀MIT-6-031-Software-Construction-课程自学笔记"><a href="#🚀MIT-6-031-Software-Construction-课程自学笔记" class="headerlink" title="🚀MIT 6.031 Software Construction 课程自学笔记"></a>🚀MIT 6.031 Software Construction 课程自学笔记</h1><span id="more"></span><h2 id="📕Reading2-testing"><a href="#📕Reading2-testing" class="headerlink" title="📕Reading2-testing"></a>📕Reading2-testing</h2><h3 id="⭐Why-software-testing-is-hard"><a href="#⭐Why-software-testing-is-hard" class="headerlink" title="⭐Why software testing is hard"></a>⭐Why software testing is hard</h3><ul><li>无穷的测试集是不可能全面详尽测试的</li><li>随机的测试项是不太可信的，可能无法发现bug</li><li>随机或统计测试对软件不适用，因为软件的行为是不连续的离散的</li></ul><blockquote><p>所以需要 <strong>系统测试 systematic testing</strong></p></blockquote><h3 id="⭐Test-first-programming"><a href="#⭐Test-first-programming" class="headerlink" title="⭐Test-first programming"></a>⭐Test-first programming</h3><ul><li><strong>Spec</strong>: Write a specification for the function. 编写函数规范</li><li><strong>Test</strong>: Write tests that exercise the specification. </li><li><strong>Implement</strong>: Write the implementation.</li></ul><h3 id="⭐systematic-testing"><a href="#⭐systematic-testing" class="headerlink" title="⭐systematic testing"></a>⭐systematic testing</h3><ul><li><strong>Correct</strong><ul><li>正确的 合法的</li><li>正确的实现可以通过所有测试点</li></ul></li><li><strong>Thorough</strong><ul><li>全面的 详尽的</li><li>尽可能涵盖可能出现错误的测试点</li></ul></li><li><strong>Small</strong><ul><li>简洁的 快速的</li><li>编写快速，更新容易</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>MIT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript闭包 | 从机制到应用</title>
    <link href="/2024/02/25/js%E9%97%AD%E5%8C%85/"/>
    <url>/2024/02/25/js%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="🤗JavaScript语言中的作用域和闭包（closure）详解"><a href="#🤗JavaScript语言中的作用域和闭包（closure）详解" class="headerlink" title="🤗JavaScript语言中的作用域和闭包（closure）详解"></a>🤗JavaScript语言中的作用域和闭包（closure）详解</h1><span id="more"></span><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>Javascript语言有特有的”链式作用域”结构（chain scope）</p><ul><li><strong>在函数内部可以直接读取全局变量</strong></li><li><strong>在函数外部自然无法读取函数内的局部变量</strong></li></ul><hr><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包（Closure）是计算机编程中的一个概念，通常用于描述函数（或者其他可执行的代码块）以及其在定义时所处的环境（词法环境）之间的关系。简单来说，闭包是一个函数和其相关的引用环境的组合体。</p><p>在许多编程语言中，函数是第一类对象，可以被当作参数传递、赋值给变量、作为返回值等。<strong>当一个函数在定义时引用了其外部作用域中的变量，即使在该变量的作用域消失后，只要该函数还存在，它依然能够访问和操作这些变量，这种函数就形成了闭包</strong>。</p><p>闭包的主要特点包括：</p><ol><li><strong>内部函数引用了外部函数的变量或参数。</strong></li><li><strong>外部函数返回内部函数。</strong></li><li><strong>外部函数的作用域消失后，内部函数仍然可以访问外部函数的变量。</strong></li></ol><p>闭包在实际编程中有着广泛的应用，例如在 JavaScript 中，闭包经常用于<strong>创建私有变量、模块化设计、实现回调函数</strong>等。</p><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/images"></p><hr><h3 id="闭包产生的条件"><a href="#闭包产生的条件" class="headerlink" title="闭包产生的条件"></a>闭包产生的条件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>) &#123;<br>a++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-keyword">return</span> f2<br>&#125;<br><br><span class="hljs-keyword">var</span> f = <span class="hljs-title function_">f1</span>()<span class="hljs-comment">// f1()执行的结果是f2；变量f指向函数f2</span><br><span class="hljs-title function_">f</span>()<span class="hljs-comment">// 11执行f()，改变变量a的值</span><br><span class="hljs-title function_">f</span>()<span class="hljs-comment">// 12继续执行f()，变量a状态会维持</span><br></code></pre></td></tr></table></figure><p>f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收</p><blockquote><p><strong>返回一个函数，并且这个函数对局部变量存在引用，这就形成了闭包的包含关系，维持局部变量的关系</strong></p></blockquote><hr><h3 id="Vue中的闭包"><a href="#Vue中的闭包" class="headerlink" title="Vue中的闭包"></a>Vue中的闭包</h3><p>在 Vue.js 中，闭包通常与组件的数据和方法相关联。Vue 组件中的数据和方法通常被封装在组件实例中，这些数据和方法可以通过组件模板进行访问和操作。闭包在 Vue 组件中的应用主要体现在以下几个方面：</p><ol><li><strong>数据封装和访问控制</strong>：Vue 组件中的数据可以通过闭包进行封装，从而实现私有数据的效果。通过在组件定义中使用函数来返回数据，可以利用闭包的特性确保数据的封装性和访问控制，避免数据被意外修改或篡改。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> privateData = <span class="hljs-string">&#x27;Private Data&#x27;</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">getPrivateData</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> privateData;<br>      &#125;<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123; getPrivateData() &#125;&#125;&lt;/div&gt;&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>事件处理函数</strong>：在 Vue 组件中，事件处理函数通常需要访问组件实例中的数据和方法。通过使用闭包，可以在事件处理函数中访问组件实例的数据和方法，从而实现事件处理函数与组件实例的绑定。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;increment&quot;&gt;Click me&lt;/button&gt;&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>异步操作</strong>：在 Vue 组件中，有时需要进行异步操作，例如发起 HTTP 请求或定时器回调等。闭包可以帮助保存组件实例中的数据和方法的引用，确保在异步操作中能够正确地访问和操作组件数据。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Initial Message&#x27;</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;Updated Message&#x27;</span>;<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure><hr><h3 id="练习一下"><a href="#练习一下" class="headerlink" title="练习一下"></a>练习一下</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;<br><br>　　<span class="hljs-keyword">var</span> object = &#123;<br>　　　　name : <span class="hljs-string">&quot;My Object&quot;</span>,<br><br>　　　　getNameFunc : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>　　　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>　　　　　　&#125;;<br><br>　　　　&#125;<br><br>　　&#125;;<br><br>　　<span class="hljs-title function_">alert</span>(object.<span class="hljs-title function_">getNameFunc</span>()());<br><span class="hljs-comment">// The window  </span><br><span class="hljs-comment">// 相当于就是this.name</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;<br><br>　　<span class="hljs-keyword">var</span> object = &#123;<br>　　　　name : <span class="hljs-string">&quot;My Object&quot;</span>,<br><br>　　　　getNameFunc : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>　　　　　　<span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;<br>　　　　　　<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>　　　　　　　　<span class="hljs-keyword">return</span> that.<span class="hljs-property">name</span>;<br>　　　　　　&#125;;<br><br>　　　　&#125;<br><br>　　&#125;;<br><br>　　<span class="hljs-title function_">alert</span>(object.<span class="hljs-title function_">getNameFunc</span>()());<br><span class="hljs-comment">// My object</span><br><span class="hljs-comment">// getNameFunc的内部函数引用了that，所以getNameFunc作用域不会被销毁，that指向object</span><br></code></pre></td></tr></table></figure><hr><p><strong>附</strong></p><p><a href="https://juejin.cn/post/6937469222251560990">掘金大佬文</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟DOM和diff算法 | Vue源码</title>
    <link href="/2024/02/19/VDOM/"/>
    <url>/2024/02/19/VDOM/</url>
    
    <content type="html"><![CDATA[<h1 id="⭐DOM和diff算法-解读Vue源码"><a href="#⭐DOM和diff算法-解读Vue源码" class="headerlink" title="⭐DOM和diff算法 | 解读Vue源码"></a>⭐DOM和diff算法 | 解读Vue源码</h1><p><a href="https://juejin.cn/post/6844904078196097031">详解：虚拟dom及dIff算法-一篇就够了</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue侦听器 | watch选项</title>
    <link href="/2024/02/17/Vue%E4%BE%A6%E5%90%AC%E5%99%A8/"/>
    <url>/2024/02/17/Vue%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="👀watch基本用法"><a href="#👀watch基本用法" class="headerlink" title="👀watch基本用法"></a>👀<code>watch</code>基本用法</h2><ul><li><p>在 Vue.js 中，<code>watch</code> 是一个选项，用于侦听 Vue 实例中数据的变化并作出相应的响应。</p><ul><li><code>watch</code> 选项可以接收两个参数：<strong>要观察的数据属性的名称和一个回调函数</strong>。</li><li>当被观察的数据发生变化时，Vue.js 会自动调用该回调函数，<strong>并传入两个参数：新值和旧值</strong>。</li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> question = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> answer = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 可以直接侦听一个 ref</span></span><br><span class="language-javascript"><span class="hljs-title function_">watch</span>(question, <span class="hljs-keyword">async</span> (newQuestion, oldQuestion) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">if</span> (newQuestion.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;?&#x27;</span>)) &#123;</span><br><span class="language-javascript">    loading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">    answer.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;Thinking...&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://yesno.wtf/api&#x27;</span>)</span><br><span class="language-javascript">      answer.<span class="hljs-property">value</span> = (<span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>()).<span class="hljs-property">answer</span></span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">catch</span> (error) &#123;</span><br><span class="language-javascript">      answer.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="language-javascript">      loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    Ask a yes/no question:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;loading&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="👀监听数据源类型"><a href="#👀监听数据源类型" class="headerlink" title="👀监听数据源类型"></a>👀监听数据源类型</h2><ul><li><p><code>watch</code> 的第一个参数可以是<strong>不同形式的“数据源”</strong>：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 单个 ref</span><br><span class="hljs-comment">// 在 x 的值发生变化时执行回调函数，并传入新的值 newX</span><br><br><span class="hljs-title function_">watch</span>(x, <span class="hljs-function">(<span class="hljs-params">newX</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`x is <span class="hljs-subst">$&#123;newX&#125;</span>`</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// getter 函数</span><br><span class="hljs-comment">// 在 x 或 y 的值发生变化时执行回调函数，并计算 x.value + y.value 的结果作为侦听的值。当侦听的值发生变化时，执行回调函数，并传入新的值 sum</span><br><br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> x.<span class="hljs-property">value</span> + y.<span class="hljs-property">value</span>,<br>  <span class="hljs-function">(<span class="hljs-params">sum</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`sum of x + y is: <span class="hljs-subst">$&#123;sum&#125;</span>`</span>)<br>  &#125;<br>)<br><br><br><span class="hljs-comment">// 多个来源组成的数组</span><br><span class="hljs-comment">// 同时监听 x 和 y 的值的变化，并在任一值发生变化时执行回调函数。回调函数的参数是一个数组，包含了 x 和 y 的新值 [newX, newY]</span><br><br><span class="hljs-title function_">watch</span>([x, <span class="hljs-function">() =&gt;</span> y.<span class="hljs-property">value</span>], <span class="hljs-function">(<span class="hljs-params">[newX, newY]</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`x is <span class="hljs-subst">$&#123;newX&#125;</span> and y is <span class="hljs-subst">$&#123;newY&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><hr></li></ul><h2 id="👀watch-options"><a href="#👀watch-options" class="headerlink" title="👀watch options"></a>👀watch options</h2><h3 id="immediate"><a href="#immediate" class="headerlink" title="immediate"></a>immediate</h3><ul><li>在使用<code>watch</code>时, 使用<code>immediate: true</code>选项, 这样它就会在<strong>组件创建时立即执行.</strong></li><li>举例来说，我们想<strong>请求一些初始数据</strong>，然后在相关状态更改时重新请求数据。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  source,<br>  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 立即执行，且当 `source` 改变时再次执行</span><br>  &#125;,<br>  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="deep"><a href="#deep" class="headerlink" title="deep"></a>deep</h3><ul><li><p><code>deep</code>即深入观察, 监听器会层层遍历, <strong>给对象的所有属性(及子属性)添加监听器.</strong> </p></li><li><p>这样做无疑会有很大的性能开销, 修改<code>obj</code>中<strong>任何一个属性</strong>都会触发监听器中的处理函数.</p></li></ul><blockquote><p>直接给 <code>watch()</code> 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;)<br><br><span class="hljs-title function_">watch</span>(obj, <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在嵌套的属性变更时触发</span><br>  <span class="hljs-comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span><br>  <span class="hljs-comment">// 因为它们是同一个对象！</span><br>&#125;)<br><br>obj.<span class="hljs-property">count</span>++<br></code></pre></td></tr></table></figure><blockquote><p>一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">someObject</span>,<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 仅当 state.someObject 被替换时触发</span><br>  &#125;<br>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">someObject</span>,<br>  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span><br>    <span class="hljs-comment">// *除非* state.someObject 被整个替换了</span><br>  &#125;,<br>  &#123; <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><p>&nbsp;</p><blockquote><p><strong>总之，如果第一个参数直接传入一个对象或者手动设置deep深层监听，该对象任何一个属性改变都会触发回调函数；否则若使用的getter函数，只有当整个对象被改变时才会触发回调函数</strong></p></blockquote><hr><h2 id="👀watchEffect"><a href="#👀watchEffect" class="headerlink" title="👀watchEffect()"></a>👀<code>watchEffect()</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> todoId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br><span class="hljs-title function_">watch</span>(<br>  todoId,<br>  <span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<br>      <span class="hljs-string">`https://jsonplaceholder.typicode.com/todos/<span class="hljs-subst">$&#123;todoId.value&#125;</span>`</span><br>    )<br>    data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>()<br>  &#125;,<br>  &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> &#125;<br>)<br></code></pre></td></tr></table></figure><p>todoId同时在源和回调函数中使用，可以替换为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watchEffect</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<br>    <span class="hljs-string">`https://jsonplaceholder.typicode.com/todos/<span class="hljs-subst">$&#123;todoId.value&#125;</span>`</span><br>  )<br>  data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p>&nbsp;</p><blockquote><p>对于有<strong>多个依赖项</strong>的侦听器来说，使用 <code>watchEffect()</code> 可以<strong>消除手动维护依赖列表的负担</strong>。此外，如果你需要侦听一个嵌套数据结构中的几个属性，<code>watchEffect()</code> 可能会比深度侦听器更有效，因为它将<strong>只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性</strong>。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT详解笔记</title>
    <link href="/2024/02/16/JWT%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/02/16/JWT%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="🔑JWT（JSON-Web-Token）"><a href="#🔑JWT（JSON-Web-Token）" class="headerlink" title="🔑JWT（JSON Web Token）"></a>🔑JWT（JSON Web Token）</h2><span id="more"></span><p><strong>JWT（JSON Web Token）</strong>是一种开放标准（RFC 7519），用于在网络应用之间安全地传输信息。它是一种轻量级的认证和授权机制，常用于身份验证和信息传递。</p><p>JWT由三部分组成，通过点号（.）分隔开来：</p><ol><li><p><strong>Header（头部）</strong>：包含关于令牌的元数据和算法的信息。例如，指定令牌使用的签名算法（例如HMAC、RSA等）和令牌类型（如JWT）。</p></li><li><p><strong>Payload（负载）</strong>：包含称为声明（claims）的信息，它是JWT的主要内容。声明是关于实体（通常是用户）和其他数据的陈述。有三种类型的声明：</p><ul><li>Registered claims（注册声明）：这些是预定义的声明，包括iss（令牌签发者）、exp（过期时间）、sub（主题）等。</li><li>Public claims（公共声明）：这些是自定义的声明，根据应用程序的需要定义。</li></ul></li></ol><ul><li>Private claims（私有声明）：这些是自定义的声明，用于在同意的各方之间共享信息，但不是注册的或公共的声明。</li></ul><ol start="3"><li><p><strong>Signature（签名）</strong>：使用头部和负载经过签名算法计算得出的签名，用于验证令牌的完整性和真实性。签名使用一个密钥（对称加密）或一对公私钥（非对称加密）进行生成和验证。</p><p> &nbsp;</p></li></ol><p><strong>JWT的工作流程如下：</strong></p><ol><li>用户通过提供其凭据（如用户名和密码）进行身份验证。</li><li>服务器验证凭据，并在验证成功后生成JWT。</li><li>服务器将JWT发送回客户端。</li><li>客户端将JWT存储在本地（通常是在浏览器的本地存储或Cookie中）。</li><li>客户端在每个后续请求中将JWT包含在请求的头部、查询参数或Cookie中。</li><li>服务器验证JWT的签名和有效期，并根据其中的声明对请求进行授权和身份验证。</li></ol><p>由于JWT是自包含的，它不需要在服务器端存储会话信息，因此具有良好的可扩展性。它也可以在分布式系统中使用，允许不同服务之间共享用户身份和授权信息。</p><hr><p>&nbsp;</p><h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><p>A JWT contains three parts:</p><ul><li><p><strong>头部 Header</strong></p><p>  : Consists of two parts:</p><ul><li>The signing algorithm that’s being used.</li><li>The type of token, which, in this case, is mostly “JWT”.</li></ul></li><li><p><strong>载荷 Payload</strong>: The payload contains the claims or the JSON object.</p></li><li><p><strong>签名 Signature</strong>: A string that is generated via a cryptographic algorithm that can be used to verify the integrity of the JSON payload.</p></li></ul><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240216203256224.png" alt="image-20240216203256224"></p><p>&nbsp;</p><h3 id="How-do-they-work"><a href="#How-do-they-work" class="headerlink" title="How do they work"></a>How do they work</h3><p>The easiest way to explain how a JWT works is via an example. We will start by creating a JWT for a specific JSON payload and then go about verifying it:</p><h5 id="1-Create-a-JSON"><a href="#1-Create-a-JSON" class="headerlink" title="1) Create a JSON"></a>1) Create a JSON</h5><p>Let’s take the following minimal JSON payload:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;userId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;abcd123&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;expiry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1646635611301</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>&nbsp;</p><h5 id="2-Create-a-JWT-signing-key-and-decide-the-signing-algorithm"><a href="#2-Create-a-JWT-signing-key-and-decide-the-signing-algorithm" class="headerlink" title="2) Create a JWT signing key and decide the signing algorithm"></a>2) Create a JWT signing key and decide the signing algorithm</h5><p>First, we need a signing key and an algorithm to use. We can generate a signing key using any secure random source. For the purpose of this post, let’s use:</p><ul><li>Signing key: <code>NTNv7j0TuYARvmNMmWXo6fKvM4o6nv/aUi9ryX38ZH+L1bkrnD1ObOQ8JAUmHCBq7Iy7otZcyAagBLHVKvvYaIpmMuxmARQ97jUVG16Jkpkp1wXOPsrF9zwew6TpczyHkHgX5EuLg2MeBuiT/qJACs1J0apruOOJCg/gOtkjB4c=</code></li><li>Signing algorithm: <code>HMAC + SHA256</code>, also known as <code>HS256</code>.</li></ul><p>&nbsp;</p><h5 id="3-Creating-the-“Header”"><a href="#3-Creating-the-“Header”" class="headerlink" title="3) Creating the “Header”"></a>3) Creating the “Header”</h5><p>This contains the information about which signing algorithm is used. Like the payload, this is also a JSON and will be appended to the start of the JWT (hence the name header):</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>&nbsp;</p><h5 id="4-Create-a-signature"><a href="#4-Create-a-signature" class="headerlink" title="4) Create a signature"></a>4) Create a signature</h5><ul><li><p>First, we remove all the spaces from the payload JSON and then base64 encode it to give us <code>eyJ1c2VySWQiOiJhYmNkMTIzIiwiZXhwaXJ5IjoxNjQ2NjM1NjExMzAxfQ</code>. You can try pasting this string in an <a href="https://www.base64decode.org/">online base64 decoder</a> to retrieve our JSON.</p></li><li><p>Similarly, we remove the spaces from the header JSON and base64 encode it to give us: <code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code>.</p></li><li><p>We concatenate both the base 64 strings, with a <code>.</code> in the middle like <code>&lt;header&gt;.&lt;payload&gt;</code>, giving us <code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJhYmNkMTIzIiwiZXhwaXJ5IjoxNjQ2NjM1NjExMzAxfQ</code>. There is no special reason to do it this way other than to set a convention that the industry can follow.</p></li><li><p>Now we run the <code>Base64 + HMACSHA256</code> function on the above concatenated string and the secret to give us the signature:</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">Base64URLSafe(<br>    HMACSHA256(&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJhYmNkMTIzIiwiZXhwaXJ5IjoxNjQ2NjM1NjExMzAxfQ&quot;, &quot;NTNv7j0TuYARvmNMmWXo6fKvM4o6nv/aUi9ryX38ZH+L1bkrnD1ObOQ8JAUmHCBq7Iy7otZcyAagBLHVKvvYaIpmMuxmARQ97jUVG16Jkpkp1wXOPsrF9zwew6TpczyHkHgX5EuLg2MeBuiT/qJACs1J0apruOOJCg/gOtkjB4c=&quot;)<br>)<br><br>Results in:<br>3Thp81rDFrKXr3WrY1MyMnNK8kKoZBX9lg-JwFznR-M<br></code></pre></td></tr></table></figure><p>  We base64 encode it only as an industry convention.</p></li></ul><p>&nbsp;</p><h5 id="5-Creating-the-JWT"><a href="#5-Creating-the-JWT" class="headerlink" title="5) Creating the JWT"></a>5) Creating the JWT</h5><p>Finally, we append the generated signature like <code>&lt;header&gt;.&lt;body&gt;.&lt;signature&gt;</code> to create our JWT:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJhYmNkMTIzIiwiZXhwaXJ5IjoxNjQ2NjM1NjExMzAxfQ.3Thp81rDFrKXr3WrY1MyMnNK8kKoZBX9lg-JwFznR-M<br></code></pre></td></tr></table></figure><p>&nbsp;</p><h5 id="6-Verifying-the-JWT"><a href="#6-Verifying-the-JWT" class="headerlink" title="6) Verifying the JWT"></a>6) Verifying the JWT</h5><p>The auth server will send the JWT back to the client’s frontend. The frontend will attach the JWT to network requests to the client’s api layer. The api layer will do the following steps to verify the JWT:</p><ul><li>Fetches the header part of the JWT (<code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code>).</li><li>Does base64 decoding on it to get the plain text JSON: <code>&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;</code></li><li>Verifies that the <code>typ</code> field’s value is <code>JWT</code> and the <code>alg</code> is <code>HS256</code>. If not, it would reject the JWT.</li><li>Fetches signing secret key and runs the same <code>Base64URLSafe(HMACSHA256(...))</code> operation as step number (4) on the header and body of the incoming JWT. Note that if the incoming JWT’s body is different, this step will generate a different signature than in step (4).</li><li>Checks that the generated signature is the same as the signature from the incoming JWT. If it’s not, then the JWT is rejected.</li><li>We base64 decode the body of the JWT (<code>eyJ1c2VySWQiOiJhYmNkMTIzIiwiZXhwaXJ5IjoxNjQ2NjM1NjExMzAxfQ</code>) to give us <code>&#123;&quot;userId&quot;:&quot;abcd123&quot;,&quot;expiry&quot;:1646635611301&#125;</code>.</li><li>We reject the JWT if the current time (in milliseconds) is greater than the JSON’s <code>expiry</code> time (since the JWT is expired).</li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS对象解构</title>
    <link href="/2024/02/16/%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84/"/>
    <url>/2024/02/16/%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="💡对象解构-JavaScript语法-Vue"><a href="#💡对象解构-JavaScript语法-Vue" class="headerlink" title="💡对象解构 | JavaScript语法 | Vue"></a>💡对象解构 | JavaScript语法 | Vue</h1><h2 id="💡基础语法"><a href="#💡基础语法" class="headerlink" title="💡基础语法"></a>💡基础语法</h2><p>在 JavaScript 中，对象解构是一种从对象中提取属性值并将其赋值给变量的语法。使用对象解构的语法结构可以通过一种简洁的方式从对象中选择性地提取属性。</p><p>对象解构的基本语法是<strong>使用花括号 <code>&#123;&#125;</code> 来指定要提取的属性，然后将其赋值给对应的变量</strong>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">42</span> &#125;;<br><br><span class="hljs-comment">// 使用对象解构</span><br><span class="hljs-keyword">const</span> &#123; message, count &#125; = obj;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 输出: &#x27;Hello&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 输出: 42</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个名为 <code>obj</code> 的对象，其中包含 <code>message</code> 和 <code>count</code> 两个属性。然后，通过对象解构将 <code>obj</code> 中的属性值提取出来并分别赋值给 <code>message</code> 和 <code>count</code> 变量。这样，我们可以直接使用这些变量来访问对象的属性值。</p><p>&nbsp;</p><p>对象解构还支持给<strong>变量指定默认值，以防对象中不存在对应的属性</strong>。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span> &#125;;<br><br><span class="hljs-comment">// 使用对象解构，并为 count 指定默认值</span><br><span class="hljs-keyword">const</span> &#123; message, count = <span class="hljs-number">0</span> &#125; = obj;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 输出: &#x27;Hello&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count); <span class="hljs-comment">// 输出: 0</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>obj</code> 对象中没有 <code>count</code> 属性，但我们通过对象解构为 <code>count</code> 指定了默认值为 <code>0</code>。因此，尽管 <code>obj</code> 中没有 <code>count</code> 属性，但 <code>count</code> 变量的值仍为默认值 <code>0</code>。</p><hr><h2 id="💡在Vue列表渲染中的应用"><a href="#💡在Vue列表渲染中的应用" class="headerlink" title="💡在Vue列表渲染中的应用"></a>💡在Vue列表渲染中的应用</h2><p>对象解构在 Vue.js 的 <code>v-for</code> 循环中使用时，可以方便地<strong>从迭代的对象中选择性地提取属性，并将其赋值给对应的变量</strong>。这样，我们可以在循环迭代中灵活地访问和使用对象的属性值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = <span class="hljs-title function_">ref</span>([&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;])<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;&#123; message &#125; in items&quot;</span>&gt;</span><br>  &#123;&#123; message &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 有 index 索引时 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(&#123; message &#125;, index) in items&quot;</span>&gt;</span><br>  &#123;&#123; message &#125;&#125; &#123;&#123; index &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue条件渲染 | v-if和v-show</title>
    <link href="/2024/02/16/Vue%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
    <url>/2024/02/16/Vue%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="👨‍🎨Vue条件渲染-v-if-vs-v-show"><a href="#👨‍🎨Vue条件渲染-v-if-vs-v-show" class="headerlink" title="👨‍🎨Vue条件渲染 | v-if vs. v-show"></a>👨‍🎨Vue条件渲染 | <code>v-if</code> vs. <code>v-show</code></h1><span id="more"></span><h2 id="💡Vue官方文档辨析"><a href="#💡Vue官方文档辨析" class="headerlink" title="💡Vue官方文档辨析"></a>💡Vue官方文档辨析</h2><p><code>v-if</code> 是“<strong>真实的</strong>”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</p><p><code>v-if</code> 也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</p><p>相比之下，<code>v-show</code> 简单许多，元素无论初始条件如何，始终会被渲染，只有 <strong>CSS <code>display</code> 属性会被切换</strong>。</p><p>总的来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，<strong>如果需要频繁切换，则使用 <code>v-show</code> 较好</strong>；<strong>如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适</strong>。</p><h2 id="💡详细and通俗理解"><a href="#💡详细and通俗理解" class="headerlink" title="💡详细and通俗理解"></a>💡详细and通俗理解</h2><ul><li><code>v-show</code> 控制的是<strong>元素的 CSS（display）</strong>；<code>v-if</code> 是控制<strong>元素本身的添加或删除</strong>。</li><li><strong><code>v-show</code> 切换的时候不会触发组件的生命周期</strong>。 <code>v-if</code> 由 <code>false</code> 变为 <code>true</code> 会触发组件的<code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code> 钩子（跟组件的初始化执行的钩子一致），由 <code>true</code> 变为 <code>false</code> 会触发组件的 <code>beforeDestory</code>、<code>destoryed</code> 钩子。</li></ul><p>如果以性能为准则：</p><ul><li><code>v-if</code> 具有<strong>更高的切换成本</strong>（每当条件更改时）</li><li><code>v-show</code> 具有<strong>更高的初始渲染成本</strong>。</li></ul><p>因此，如果您需要频繁切换某些内容，请使用 <code>v-show</code>。如果条件在运行时变化不那么频繁，请使用 <code>v-if</code>。</p><p>另一件要考虑的事情是使用 <code>v-if</code> 允许我们将其他逻辑块与它结合使用。具体来说，我们可以使用 <code>v-else</code> 和 <code>v-else-if </code> 块来真正将高级逻辑构建到我们的应用程序中。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue响应式原理</title>
    <link href="/2024/02/15/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2024/02/15/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="💡Vue响应式原理详解-疑惑小记录"><a href="#💡Vue响应式原理详解-疑惑小记录" class="headerlink" title="💡Vue响应式原理详解|疑惑小记录"></a>💡Vue响应式原理详解|疑惑小记录</h1><span id="more"></span><h2 id="💡Proxy对象"><a href="#💡Proxy对象" class="headerlink" title="💡Proxy对象"></a>💡Proxy对象</h2><p><strong>Proxy 对象</strong>是 ECMAScript 6 引入的一种用于<strong>创建代理对象</strong>的特殊对象。它允许你在操作一个对象之前定义自定义的行为，这些行为会在对象的属性被读取、写入或删除时被触发。Proxy 对象提供了一种强大的机制，可以拦截并定义各种操作，例如属性查找、赋值、枚举等，从而实现元编程的功能。</p><p>Proxy 对象的基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要包装的目标对象。</li><li><code>handler</code>：一个包含了代理对象的拦截器（handler）方法的对象。</li></ul><p>代理对象的拦截器方法包括了一系列<strong>钩子函数</strong>，比如 <code>get</code>、<code>set</code>、<code>has</code>、<code>deleteProperty</code> 等，通过这些钩子函数，你可以定义在对目标对象进行操作时的行为。例如，你可以定义一个 <code>get</code> 钩子函数来拦截属性的读取操作，或者定义一个 <code>set</code> 钩子函数来拦截属性的赋值操作。</p><p>&nbsp;</p><p>以下是一个简单的示例，展示了如何使用 Proxy 对象来拦截对象的读取和赋值操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting property &quot;<span class="hljs-subst">$&#123;prop&#125;</span>&quot;`</span>);<br>    <span class="hljs-keyword">return</span> target[prop];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, value</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting property &quot;<span class="hljs-subst">$&#123;prop&#125;</span>&quot; to &quot;<span class="hljs-subst">$&#123;value&#125;</span>&quot;`</span>);<br>    target[prop] = value;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出: Getting property &quot;name&quot;; John</span><br>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">40</span>; <span class="hljs-comment">// 输出: Setting property &quot;age&quot; to &quot;40&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个代理对象 <code>proxy</code>，它拦截了 <code>target</code> 对象的读取和赋值操作。当访问 <code>proxy</code> 对象的属性时，<code>get</code> 钩子函数会被触发，并输出一条日志；当对 <code>proxy</code> 对象的属性进行赋值时，<code>set</code> 钩子函数会被触发，并输出一条日志。</p><hr><h2 id="💡reactive-和-ref"><a href="#💡reactive-和-ref" class="headerlink" title="💡reactive() 和 ref()"></a>💡<code>reactive()</code> 和 <code>ref()</code></h2><p><code>reactive()</code> 和 <code>ref()</code> 是 Vue 3 中用于创建响应式数据的两种不同方式。它们的主要区别在于它们处理数据的方式和用法：</p><ol><li><p><strong><code>reactive()</code>：</strong></p><ul><li><code>reactive()</code> 函数用于创建一个具有响应式特性的对象。</li><li>当你使用 <code>reactive()</code> 包裹一个对象时，该对象的所有属性都会变成响应式的，即当对象的属性发生变化时，相关的视图会被重新渲染。</li><li><code>reactive()</code> 返回的是一个 Proxy 对象，它会拦截对对象的所有操作，从而使得对对象的任何改变都能被 Vue 追踪到，并触发相应的更新。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>&#125;);<br><br><span class="hljs-comment">// state.count 会自动变为响应式的</span><br></code></pre></td></tr></table></figure></li><li><p><strong><code>ref()</code>：</strong></p><ul><li><code>ref()</code> 函数用于创建一个具有响应式特性的简单数据值（比如数字、字符串等）。</li><li>当你使用 <code>ref()</code> 包裹一个简单的数据值时，它会返回一个包含该值的响应式对象。但是，对于对象类型的数据，<code>ref()</code> 不会自动转换为响应式对象。</li><li><code>ref()</code> 返回的是一个包含 <code>.value</code> 属性的普通对象，当你需要获取数据时，需要<strong>通过 <code>.value</code> 属性来访问</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// count.value 会自动变为响应式的</span><br></code></pre></td></tr></table></figure></li></ol><p>总结一下，主要区别在于：</p><ul><li><code>reactive()</code> 用于创建响应式对象，它处理<strong>复杂的对象类型数据</strong>，并且返回一个 <strong>Proxy 对象</strong>。</li><li><code>ref()</code> 用于创建响应式简单数据值，它处理<strong>基本的数据类型</strong>，返回一个<strong>带有 <code>.value</code> 属性的普通对象</strong>。</li></ul><p>&nbsp;</p><blockquote><p>值得注意的是，<code>reactive()</code> 返回的是一个原始对象的Proxy，它和原始对象是<strong>不相等</strong>的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> raw = &#123;&#125;<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-title function_">reactive</span>(raw)<br><br><span class="hljs-comment">// 代理对象和原始对象不是全等的</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy === raw) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><blockquote><p>只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是 <strong>仅使用你声明对象的代理版本</strong>。</p></blockquote><blockquote><p><code>reactive()</code> 函数用于创建一个具有响应式特性的对象。当你使用 <code>reactive()</code> 包裹一个对象时，<strong>该对象的所有属性都会变成响应式的</strong>，<strong>但是该对象本身不会变成响应式的</strong>。因此，<code>reactive()</code> 函数返回的是一个 Proxy 对象，而不是一个响应式对象本身。</p></blockquote><blockquote><p>为保证访问代理的一致性，对同一个原始对象调用 <code>reactive()</code> 会总是返回同样的代理对象，而对一个已存在的代理对象调用 <code>reactive()</code> 会返回其本身：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在同一个对象上调用 reactive() 会返回相同的代理</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reactive</span>(raw) === proxy) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 在一个代理上调用 reactive() 会返回它自己</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">reactive</span>(proxy) === proxy) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-title function_">reactive</span>(&#123;&#125;)<br><br><span class="hljs-keyword">const</span> raw = &#123;&#125;<br>proxy.<span class="hljs-property">nested</span> = raw<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">nested</span> === raw) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>但是<code>reactive()</code> API 有一些局限性：</strong></p><ul><li>有限的值类型</li><li>不能替换整个对象</li><li>对解构操作不友好</li></ul><p><strong>所以建议使用 <code>ref()</code> 作为声明响应式状态的主要 API</strong></p><h2 id="💡shallowRef"><a href="#💡shallowRef" class="headerlink" title="💡shallowRef()"></a>💡<code>shallowRef()</code></h2><ul><li><strong>浅层次响应</strong></li><li>只到<code>x.value</code>，再深层的改变(比如<code>x.value.name</code>)就不会响应了</li></ul><h2 id="💡triggerRef"><a href="#💡triggerRef" class="headerlink" title="💡triggerRef()"></a>💡<code>triggerRef()</code></h2>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue异步更新机制 | $nextTick原理</title>
    <link href="/2024/02/15/Vue%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%E5%8F%8AnextTick/"/>
    <url>/2024/02/15/Vue%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6%E5%8F%8AnextTick/</url>
    
    <content type="html"><![CDATA[<h2 id="🌳Vue异步更新机制及-nextTick原理详解"><a href="#🌳Vue异步更新机制及-nextTick原理详解" class="headerlink" title="🌳Vue异步更新机制及$nextTick原理详解"></a>🌳Vue异步更新机制及$nextTick原理详解</h2><span id="more"></span><h3 id="更新周期"><a href="#更新周期" class="headerlink" title="更新周期"></a>更新周期</h3><p>更新周期是 Vue.js 用于管理状态变化并更新视图的时间段。Vue.js 使用了一种称为“异步更新队列”的机制来优化性能，它将状态变化的处理推迟到下一个事件循环中执行，从而使得多次状态变化的处理可以被合并成一次更新，提高了性能。</p><p>更新周期的划分主要包括以下几个阶段：</p><ol><li><p><strong>触发状态变化：</strong> 更新周期的第一步是触发状态变化。这可能是通过调用 <code>Vue</code> 实例的响应式属性或者通过调用 <code>$set</code>、<code>$delete</code> 等方法来修改数据。</p></li><li><p><strong>异步更新队列收集：</strong> Vue.js 将所有触发的状态变化操作收集到异步更新队列中。在同一个事件循环中，所有的状态变化操作都会被收集起来。</p></li><li><p><strong>异步更新队列处理：</strong> 在下一个事件循环中，Vue.js 会开始处理异步更新队列。它会遍历队列中的所有状态变化操作，并执行更新操作。</p></li><li><p><strong>执行 Virtual DOM 的重新渲染：</strong> 对于每个状态变化操作，Vue.js 会重新渲染 Virtual DOM。它会比较前后两个状态下 Virtual DOM 的差异，然后仅仅更新需要更新的部分。</p></li><li><p><strong>真实 DOM 的更新：</strong> 最后，Vue.js 会将 Virtual DOM 中的变化映射到真实 DOM 上，从而更新页面的显示。</p></li></ol><p>通过这种方式，Vue.js 能够将多次状态变化操作合并成一次更新，减少了更新的次数，提高了性能。同时，这种异步更新机制也能保证所有的状态变化操作在一个更新周期内完成，避免了因多次状态变化而导致的不必要的重复渲染。</p><hr><p><img src="https://cn.vuejs.org/assets/lifecycle.DLmSwRQE.png" alt="组件生命周期图示"></p><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>在 Vue.js 应用程序中，<strong>生命周期钩子（Lifecycle Hooks）</strong>是一组可以让你在组件的不同生命周期阶段执行自定义代码的函数。这些钩子函数允许你<strong>控制组件的创建、更新和销毁过程</strong>，以便在不同的时间点执行逻辑代码。</p><p>&nbsp;</p><p>Vue.js 的生命周期钩子可以分为以下三个阶段：</p><ol><li><p><strong>创建阶段（Creation Phase）</strong>：</p><ul><li><code>beforeCreate</code>：在实例被创建之初，数据观测（data observation）和事件&#x2F;生命周期事件的配置之前调用。</li></ul></li></ol><ul><li><code>created</code>：实例已经完成数据观测、属性和方法的运算，但尚未挂载到 DOM。可以访问数据、进行异步操作等。</li></ul><ol start="2"><li><p><strong>更新阶段（Update Phase）</strong>：</p><ul><li><code>beforeMount</code>：在实例被挂载到 DOM 之前调用。</li><li><code>mounted</code>：实例已经挂载到 DOM 上，此时可以访问 DOM 元素，进行操作或与第三方库进行交互。</li><li><code>beforeUpdate</code>：在响应式数据更新时，在更新之前调用。</li></ul></li></ol><ul><li><code>updated</code>：在响应式数据更新且 DOM 重新渲染完成后调用。</li></ul><ol start="3"><li><p><strong>销毁阶段（Destruction Phase</strong>）：</p><ul><li><code>beforeUnmount</code>：在实例销毁之前调用。</li><li><code>unmounted</code>：实例被销毁后调用，此时组件相关的实例、指令等都被解绑，可进行清理操作。</li></ul><p>&nbsp;</p></li></ol><p>这些生命周期钩子函数可以通过在组件中声明对应名称的方法来使用。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;changeMessage&quot;</span>&gt;</span>Change Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Hello, Vue!&quot;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Component created&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Component mounted&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">startTimer</span>();</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Component before update&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Component updated&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Component before unmount&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">stopTimer</span>();</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Component unmounted&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">changeMessage</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;Message changed!&quot;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">startTimer</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Timer tick&quot;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;, <span class="hljs-number">1000</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">stopTimer</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>生命周期钩子函数提供了灵活的方式来管理组件的行为，在不同的阶段执行逻辑代码，例如初始化数据、访问 DOM、处理异步操作、清理资源等。它们是 Vue.js 组件开发中非常有用的功能。</p><p>&nbsp;</p><blockquote><p>以下是各个钩子的具体常见用法</p></blockquote><ul><li><p><strong>created 钩子：</strong></p><ul><li><strong>初始化数据</strong>：可以在 created 钩子中设置组件的默认数据。</li><li><strong>发起异步请求</strong>：可以在 created 钩子中发起网络请求或获取远程数据。</li><li><strong>订阅事件</strong>：可以在 created 钩子中订阅全局事件或自定义事件。</li></ul></li><li><p><strong>mounted 钩子：</strong></p><ul><li><strong>操作 DOM</strong>：可以在 mounted 钩子中获取组件的 DOM 元素，执行 DOM 操作或初始化第三方库。</li><li><strong>注册事件监听器</strong>：可以在 mounted 钩子中注册事件监听器，以响应用户的交互操作。</li><li>开始动画效果：可以在 mounted 钩子中启动动画效果，例如渐变、滚动等。</li></ul></li><li><p><strong>beforeUpdate 钩子：</strong></p><ul><li><strong>执行预处理逻辑</strong>：可以在 beforeUpdate 钩子中执行数据处理、计算属性等操作，以准备组件的更新。</li><li><strong>取消更新</strong>：在 beforeUpdate 钩子中检查特定条件，决定是否取消组件的更新。</li></ul></li><li><p><strong>updated 钩子：</strong></p><ul><li><strong>执行 DOM 操作</strong>：可以在 updated 钩子中执行与 DOM 相关的操作，例如更新 DOM 元素、重绘图表等。</li><li><strong>与第三方库交互</strong>：可以在 updated 钩子中与其他库进行交互，以响应组件的更新。</li></ul></li><li><p><strong>beforeUnmount 钩子：</strong></p><ul><li><strong>清理工作</strong>：可以在 beforeUnmount 钩子中取消订阅事件、清除定时器、释放资源等，以准备组件的销毁。</li><li><strong>取消网络请求</strong>：可以在 beforeUnmount 钩子中取消未完成的网络请求，以避免内存泄漏。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub+PicGo图床设置</title>
    <link href="/2024/02/11/github-pigco%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE/"/>
    <url>/2024/02/11/github-pigco%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="👍GitHub-PicGo图床搭建不出错指南-常见问题"><a href="#👍GitHub-PicGo图床搭建不出错指南-常见问题" class="headerlink" title="👍GitHub+PicGo图床搭建不出错指南&amp;常见问题"></a>👍GitHub+PicGo图床搭建不出错指南&amp;常见问题</h2><span id="more"></span><p>前段时间写博客写图片路径太痛苦了，特别是截屏的图片</p><p>（众所周知）PicGo是一款非常好用的图床工具，尤其搭配typora格外丝滑，很适合写博客</p><p>本人最初是根据下面这篇文章搭建的图床</p><p><a href="https://blog.csdn.net/yefcion/article/details/88412025">PicGo+GitHub搭建个人图床工具</a></p><p>配置好了之后一直上传不成功，困扰停滞了半个月，今天终于解决</p><p>按照以下步骤来，应该是不出错指南吼吼</p><hr><h3 id="⚠Attention"><a href="#⚠Attention" class="headerlink" title="⚠Attention"></a>⚠Attention</h3><p><strong>更</strong></p><p>发现这种方式上传的图片必须挂vpn才能访问…</p><p>谁叫github现在都需要翻墙呢（记得大一上的时候还是不需要的…</p><p><strong>so 如果你发现有些图片显示不了 这是木有办法的 翻墙是可以正常看见的</strong></p><p>为了方便我自己 我就 偷懒了🤫</p><hr><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><ul><li><p>在github创建一个<strong>public</strong>的仓库，用于存放图片</p></li><li><p>点击github头像 – settings – developer settings – tokens(classic)</p><p>  生成一个token,<strong>复制到一个地方</strong></p><p>  <img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240211201119607.png"></p></li></ul><h3 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h3><p>网上有很多资源，可以去官网下载，也可以去别人博客里面找网盘安装包，这里不过多赘述。我用的2.3.0</p><blockquote><p>这里小小提醒一点：<strong>最好不要安装beta测试版</strong></p></blockquote><p>很简单的安装过程</p><h3 id="图床配置"><a href="#图床配置" class="headerlink" title="图床配置"></a>图床配置</h3><blockquote><p>这里推荐用githubPlus插件</p></blockquote><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240211200501729.png"></p><ul><li><p>repo填仓库地址</p><p>  注意按上面的格式来 <strong>斜杠只有中间一个</strong></p></li><li><p>branch现在一般用main</p></li><li><p>token刚才生成的复制进去</p></li><li><p>path可以无也可以自己创建一个文件夹 仓库里得有这个文件夹</p></li><li><p>Url按下面格式填</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/用户名/</span>仓库名/main<br></code></pre></td></tr></table></figure><blockquote><p>别用网上说的什么cdn.jsdelivr.net&#x2F;，那个好像被禁了</p></blockquote></li><li><p>origin是github</p></li></ul><p>点击确认 然后回到上传区测试一下</p><p>正常情况上传是没有问题的，如果遇到上传失败(和我一样)，<strong>不要急不要急</strong>，可以参考下面的解决方案</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>我半个月前遇到过不同的报错，你的报错具体可以去日志里面查看</p><p>我今天最后解决的根源，竟然是vpn。。。</p><p>参考这篇<a href="https://blog.csdn.net/zmy766138/article/details/128082713#:~:text=%E5%85%B3%E9%97%ADsteam%2B%2B%E5%90%8E%E5%86%8D%E6%AC%A1%E4%B8%8A%E4%BC%A0%20%E6%88%90%E5%8A%9F%E8%A7%A3%E5%86%B3%EF%BC%8C%E7%BB%8F%E8%BF%87%E6%B5%8B%E8%AF%95%EF%BC%8C%E4%BE%8B%E5%A6%82fastGitHub%E8%BF%99%E7%B1%BB%E8%BD%AF%E4%BB%B6%EF%BC%8C%E9%83%BD%E6%9C%89%E5%8F%AF%E8%83%BD%E5%AF%BC%E8%87%B4%E8%BF%99%E7%B1%BB%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5,%E5%B0%9D%E8%AF%95uu%E5%8A%A0%E9%80%9F%E5%99%A8%20%EF%BC%8C%E9%80%89%E6%8B%A9%E5%AD%A6%E6%9C%AF%E8%B5%84%E6%BA%90%E5%8A%A0%E9%80%9F%EF%BC%8C%E5%85%8D%E8%B4%B9%EF%BC%8C%E5%8F%AF%E8%A7%A3%E5%86%B3%E5%A6%82%E4%B8%8A%E9%97%AE%E9%A2%98%EF%BC%8C%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BA%8A">关于picgo图床报错“unable to verify the first certificate”</a></p><p>就是<strong>下个steam++</strong>, 然后用<strong>学术资源加速</strong></p><p>下好之后莫名其妙就上传成功了，然后换回我的clash竟然莫名其妙也成功了，不知道为什么，反正成功了就是了</p><p>多试一下，有时候就是玄学</p><h3 id="结合typora"><a href="#结合typora" class="headerlink" title="结合typora"></a>结合typora</h3><p>很熟悉的工具啊 ， 打开<strong>文件 – 偏好设置 – 图像</strong></p><p><strong>上传服务</strong>（PicGo) 和<strong>picgo路径</strong>（可执行文件路径）填一下</p><p><img src="https://raw.githubusercontent.com/JerryC66/picgo-repo/main/img/image-20240211202251227.png"></p><p><strong>然后就可以开启博客丝滑之旅了</strong>！！！</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>盘点pandas的高光瞬间</title>
    <link href="/2024/02/04/%E7%9B%98%E7%82%B9pandas%E7%9A%84%E9%AB%98%E5%85%89%E7%9E%AC%E9%97%B4/"/>
    <url>/2024/02/04/%E7%9B%98%E7%82%B9pandas%E7%9A%84%E9%AB%98%E5%85%89%E7%9E%AC%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>👊<strong>Python 数据分析实践与实战的必备高级工具</strong></p><span id="more"></span><h3 id="pivot-table透视表"><a href="#pivot-table透视表" class="headerlink" title="pivot_table透视表"></a>pivot_table透视表</h3><p><a href="https://zhuanlan.zhihu.com/p/31952948">pivot_table透视表</a></p><h3 id="melt"><a href="#melt" class="headerlink" title="melt"></a>melt</h3><p><a href="https://blog.csdn.net/maymay_/article/details/80039677">melt用法</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络流问题 | 最大流</title>
    <link href="/2024/02/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%97%AE%E9%A2%98/"/>
    <url>/2024/02/03/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="💧Network-Flow-Maximum-Flow-Problem"><a href="#💧Network-Flow-Maximum-Flow-Problem" class="headerlink" title="💧Network Flow | Maximum Flow Problem"></a>💧Network Flow | Maximum Flow Problem</h2><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在最大流问题中，给定一个有向图，其中每条边都有一个<strong>容量限制</strong>，同时有一个<strong>源点</strong>和一个<strong>汇点</strong>。最大流问题的目标是找到从源点到汇点的最大流量，即通过网络中的路径，使得<strong>从源点到汇点的流量最大化</strong>。</p><blockquote><p>增广路是一条路径，它满足以下两个条件：</p><ol><li>路径上的边的剩余容量大于0。</li><li>路径上的边的剩余容量的最小值称为该路径的容量。</li></ol></blockquote><p><strong>基本步骤</strong></p><ul><li>初始化流量为0</li><li>在图中寻找一条增广路</li><li>如果找到增广路，将流量沿着增广路增加到容量限制</li><li>重复步骤2和步骤3，直到无法找到增广路为止</li><li>最终的流量即为最大流。</li></ul><p>但是这个算法太粗糙了，很容易举出例子，流量用尽了可是最后得到的并非是最大流量，结果和前面选择的路径有关系</p><p>所以需要引入一种”<strong>撤销</strong>“思想，允许犯错</p><h3 id="Ford-Fulkerson算法"><a href="#Ford-Fulkerson算法" class="headerlink" title="Ford-Fulkerson算法"></a>Ford-Fulkerson算法</h3><ul><li>两个图<ul><li>最大流量图和剩余流量图</li></ul></li><li><strong>反向边</strong><ul><li>这个算法最关键的部分 就是这条边减少多少流量 同时添加一个相应流量的反向边</li></ul></li></ul><blockquote><p>可以理解为 你现在占用了该路径这么多流量 但是有机会抵消这个操作 来探索更大流的方案</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, graph</span>):<br>        self.graph = graph<br>        self.ROW = <span class="hljs-built_in">len</span>(graph)<br>  <br>    <span class="hljs-comment"># 使用深度优先搜索查找增广路径</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">BFS</span>(<span class="hljs-params">self, s, t, parent</span>):<br>        visited = [<span class="hljs-literal">False</span>] * (self.ROW)<br>        queue = []<br>        queue.append(s)<br>        visited[s] = <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">while</span> queue:<br>            u = queue.pop(<span class="hljs-number">0</span>)<br>  <br>            <span class="hljs-keyword">for</span> ind, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.graph[u]):<br>                <span class="hljs-keyword">if</span> visited[ind] == <span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> val &gt; <span class="hljs-number">0</span>:<br>                    queue.append(ind)<br>                    visited[ind] = <span class="hljs-literal">True</span><br>                    parent[ind] = u<br>                    <span class="hljs-keyword">if</span> ind == t:<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>  <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>  <br>    <span class="hljs-comment"># Ford-Fulkerson算法求解最大流</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">FordFulkerson</span>(<span class="hljs-params">self, source, sink</span>):<br>        parent = [-<span class="hljs-number">1</span>] * (self.ROW)<br>        max_flow = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> self.BFS(source, sink, parent)://不断寻找增广路径<br>            path_flow = <span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;Inf&quot;</span>)<br>            s = sink<br>            <span class="hljs-keyword">while</span>(s != source)://从汇点向源点回溯 不断更新该路径的最小流量<br>                path_flow = <span class="hljs-built_in">min</span>(path_flow, self.graph[parent[s]][s])<br>                s = parent[s]<br>  <br>            max_flow += path_flow<br>  <br>            v = sink<br>            <span class="hljs-keyword">while</span>(v != source):<br>                u = parent[v]<br>                self.graph[u][v] -= path_flow<br>                self.graph[v][u] += path_flow<br>                v = parent[v]<br>  <br>        <span class="hljs-keyword">return</span> max_flow<br><br><span class="hljs-comment"># 测试代码</span><br>graph = [[<span class="hljs-number">0</span>, <span class="hljs-number">16</span>, <span class="hljs-number">13</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>],<br>         [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]<br><br>g = Graph(graph)<br>source = <span class="hljs-number">0</span><br>sink = <span class="hljs-number">5</span><br>max_flow = g.FordFulkerson(source, sink)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最大流量为:&quot;</span>, max_flow)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python绘图与数据可视化</title>
    <link href="/2024/02/03/python%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <url>/2024/02/03/python%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>💪<strong>一些常画图 常用库 强大的工具！比如matplotlib, seaborn, pyechart等！</strong></p><span id="more"></span><h3 id="3D柱形图"><a href="#3D柱形图" class="headerlink" title="3D柱形图"></a>3D柱形图</h3><ul><li><strong>方法签名</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">add(name, x_axis, y_axis, data,<br>    grid3d_opacity=<span class="hljs-number">1</span>,<br>    grid3d_shading=<span class="hljs-string">&#x27;color&#x27;</span>, **kwargs)<br><br>name -&gt; <span class="hljs-built_in">str</span><br>图例名称<br>x_axis -&gt; <span class="hljs-built_in">str</span><br>x 坐标轴数据。需为类目轴，也就是不能是数值。<br>y_axis -&gt; <span class="hljs-built_in">str</span><br>y 坐标轴数据。需为类目轴，也就是不能是数值。<br>data -&gt; [<span class="hljs-built_in">list</span>], 包含列表的列表<br>数据项，数据中，每一行是一个『数据项』，每一列属于一个『维度』<br>grid3d_opacity -&gt; <span class="hljs-built_in">int</span><br>3D 笛卡尔坐标系组的透明度（柱状的透明度），默认为 <span class="hljs-number">1</span>，完全不透明。<br>grid3d_shading -&gt; <span class="hljs-built_in">str</span><br>三维柱状图中三维图形的着色效果。<br>color：只显示颜色，不受光照等其它因素的影响。<br>lambert：通过经典的 lambert 着色表现光照带来的明暗。<br>realistic：真实感渲染，配合 light.ambientCubemap 和 postEffect 使用可以让展示的画面效果和质感有质的提升。ECharts GL 中使用了基于物理的渲染（PBR) 来表现真实感材质。<br><br></code></pre></td></tr></table></figure><p><a href="https://gallery.pyecharts.org/#/Bar3D/bar3d_punch_card">官方文档</a></p><p>下面是用美赛d的数据集写的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> Bar3D<br><br>csv_file_path = <span class="hljs-string">&#x27;data.csv&#x27;</span><br>df = pd.read_csv(csv_file_path, header=<span class="hljs-literal">None</span>)<br><br>years = df.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">12</span>, <span class="hljs-number">1</span>].tolist()<br>months = <span class="hljs-built_in">list</span>(df.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>:])<br>data = []<br>max_flow = <span class="hljs-number">8580</span><br>min_flow = <span class="hljs-number">6456</span><br><br><span class="hljs-keyword">for</span> year <span class="hljs-keyword">in</span> years:<br>    <span class="hljs-keyword">for</span> i, month <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(months):<br>        <span class="hljs-comment"># 后面画其他流域的流量就只用改变years.index(year) + 12后面的数字 这里表示行数 每次加11就好</span><br>        value = <span class="hljs-built_in">float</span>(df.iloc[years.index(year) + <span class="hljs-number">111</span>, months.index(month) + <span class="hljs-number">2</span>])<br>        <span class="hljs-built_in">print</span>(value)<br>        <span class="hljs-keyword">if</span> value &gt; max_flow:<br>            max_flow = value<br>        <span class="hljs-keyword">if</span> value &lt; min_flow:<br>            min_flow = value<br>        data.append([year, month, value])<br><br>bar3d = Bar3D(<span class="hljs-string">&quot;St. Lawrence River - Flow at Cornwall&quot;</span>, width=<span class="hljs-number">800</span>, height=<span class="hljs-number">600</span>)<br>x_axis = years<br>y_axis = months<br>range_color = [<span class="hljs-string">&#x27;#313695&#x27;</span>, <span class="hljs-string">&#x27;#4575b4&#x27;</span>, <span class="hljs-string">&#x27;#74add1&#x27;</span>, <span class="hljs-string">&#x27;#abd9e9&#x27;</span>, <span class="hljs-string">&#x27;#e0f3f8&#x27;</span>, <span class="hljs-string">&#x27;#ffffbf&#x27;</span>,<br>               <span class="hljs-string">&#x27;#fee090&#x27;</span>, <span class="hljs-string">&#x27;#fdae61&#x27;</span>, <span class="hljs-string">&#x27;#f46d43&#x27;</span>, <span class="hljs-string">&#x27;#d73027&#x27;</span>, <span class="hljs-string">&#x27;#a50026&#x27;</span>]<br><br>bar3d.add(<span class="hljs-string">&quot;&quot;</span>,<br>          x_axis,<br>          y_axis,<br>          data,<br>          is_visualmap=<span class="hljs-literal">True</span>,<br>          visual_range=[min_flow, max_flow],<br>          line_opacity=<span class="hljs-number">1</span>,<br>          <span class="hljs-comment">#亲身体验下面这条很有用！可以更立体更明晰！</span><br>          grid3d_shading=<span class="hljs-string">&quot;lambert&quot;</span>,<br>          <span class="hljs-comment"># 控制左下角颜色范围</span><br>          visual_range_color=[<span class="hljs-string">&#x27;#e0f3f8&#x27;</span>, <span class="hljs-string">&#x27;#2260b3&#x27;</span>]<br>          )<br><br>bar3d.render()<br><br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/img/py1.png"></p><h3 id="主题河流图"><a href="#主题河流图" class="headerlink" title="主题河流图"></a>主题河流图</h3><p><a href="https://gallery.pyecharts.org/#/ThemeRiver/theme_river">官网示例</a></p><p>正好我们国赛选的是河流相关问题，现学了一下，调试很久，居然成功了</p><p>有几个需要注意的点：</p><ul><li>y_data第一个每一个记录的第一个值必须是<strong>标准日期形式</strong>，我们最开始只有月份，需要转换一下</li><li>pyechart感觉还没有很好推广，需要注意<strong>python版本问题和导包方式</strong>，这就自己google一下慢慢调吧</li><li>还没有找到更换颜色的方案</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> options <span class="hljs-keyword">as</span> opts<br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> ThemeRiver<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">month_to_date</span>(<span class="hljs-params">month_str</span>):<br>    month_mapping = &#123;<br>        <span class="hljs-string">&#x27;Jan&#x27;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&#x27;Feb&#x27;</span>: <span class="hljs-number">2</span>,<br>        <span class="hljs-string">&#x27;Mar&#x27;</span>: <span class="hljs-number">3</span>,<br>        <span class="hljs-string">&#x27;Apr&#x27;</span>: <span class="hljs-number">4</span>,<br>        <span class="hljs-string">&#x27;May&#x27;</span>: <span class="hljs-number">5</span>,<br>        <span class="hljs-string">&#x27;Jun&#x27;</span>: <span class="hljs-number">6</span>,<br>        <span class="hljs-string">&#x27;Jul&#x27;</span>: <span class="hljs-number">7</span>,<br>        <span class="hljs-string">&#x27;Aug&#x27;</span>: <span class="hljs-number">8</span>,<br>        <span class="hljs-string">&#x27;Sep&#x27;</span>: <span class="hljs-number">9</span>,<br>        <span class="hljs-string">&#x27;Oct&#x27;</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-string">&#x27;Nov&#x27;</span>: <span class="hljs-number">11</span>,<br>        <span class="hljs-string">&#x27;Dec&#x27;</span>: <span class="hljs-number">12</span><br>    &#125;<br>    month_num = month_mapping.get(month_str)<br>    date_obj = datetime(year=<span class="hljs-number">2022</span>, month=month_num, day=<span class="hljs-number">1</span>)<br>    formatted_date = date_obj.strftime(<span class="hljs-string">&#x27;%Y/%m/%d&#x27;</span>)<br>    <span class="hljs-keyword">return</span> formatted_date<br><br>x_data = [<span class="hljs-string">&#x27;St. Marys River&#x27;</span>, <span class="hljs-string">&#x27;St. Clair River&#x27;</span>, <span class="hljs-string">&#x27;Detroit River&#x27;</span>, <span class="hljs-string">&#x27;Niagara River&#x27;</span>, <span class="hljs-string">&#x27;St. Lawrence River&#x27;</span>]<br>y_data = []<br><br>df = pd.read_excel(<span class="hljs-string">&#x27;flow.xlsx&#x27;</span>)<br><br><span class="hljs-keyword">for</span> river <span class="hljs-keyword">in</span> x_data:<br>    river_data = df.melt(id_vars=<span class="hljs-string">&#x27;Month&#x27;</span>, value_vars=river, var_name=<span class="hljs-string">&#x27;River&#x27;</span>, value_name=<span class="hljs-string">&#x27;Flow&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(river_data)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end&#x27;</span>)<br>    <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> river_data.iterrows():<br>        y_data.append([month_to_date(row[<span class="hljs-string">&#x27;Month&#x27;</span>]), row[<span class="hljs-string">&#x27;Flow&#x27;</span>]])<br><br>(<br>    ThemeRiver()<br>    .add(<br>        series_name=x_data,<br>        data=y_data,<br>        singleaxis_opts=opts.SingleAxisOpts(<br>            pos_top=<span class="hljs-string">&quot;50&quot;</span>, pos_bottom=<span class="hljs-string">&quot;50&quot;</span>, type_=<span class="hljs-string">&quot;time&quot;</span><br>        )<br>    )<br>    .set_global_opts(<br>        tooltip_opts=opts.TooltipOpts(trigger=<span class="hljs-string">&quot;axis&quot;</span>, axis_pointer_type=<span class="hljs-string">&quot;line&quot;</span>)<br>    )<br>    .render(<span class="hljs-string">&quot;theme_river_colored.html&quot;</span>)<br>)<br><br></code></pre></td></tr></table></figure><p>画好效果如下，还是很贴切滴，满意嘿嘿</p><p><img src="/img/py2.png"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多目标优化问题 | Pareto前沿</title>
    <link href="/2024/02/02/%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <url>/2024/02/02/%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="🔑多目标优化问题详解及帕累托最优"><a href="#🔑多目标优化问题详解及帕累托最优" class="headerlink" title="🔑多目标优化问题详解及帕累托最优"></a><strong>🔑多目标优化问题详解及帕累托最优</strong></h2><p>💡美赛第一天选择的题目有关多目标优化，可能会用到这个算法，无论如何先记录一下</p><span id="more"></span><h3 id="💡前言"><a href="#💡前言" class="headerlink" title="💡前言"></a>💡前言</h3><ul><li><p>生活中的优化问题很多，优化问题存在的<strong>优化目标超过一个并需要同时处理</strong> ,就成为<strong>多目标优化问题</strong></p></li><li><p>一般情况下 ,多目标优化问题的<strong>各个子目标之间是矛盾的</strong>，需要进行进行<strong>协调和折中</strong>处理 </p></li><li><p>其与单目标优化问题的本质区别在于 ,它的解并非唯一 ,而是存在<strong>一组由众多 Pareto最优解组成的最优解集合</strong> ,集合中的各个元素称为 Pareto最优解或非劣最优解</p></li></ul><h3 id="💡多目标规划"><a href="#💡多目标规划" class="headerlink" title="💡多目标规划"></a>💡多目标规划</h3><ul><li><p><strong>多目标规划问题是指在多个目标函数之间存在冲突或矛盾的优化问题</strong></p></li><li><p>一般步骤如下：</p><ul><li>定义问题的<strong>决策变量</strong>和<strong>目标函数</strong>。决策变量是影响问题结果的变量，而目标函数是需要最小化或最大化的问题指标。</li><li>根据实际问题的特点，确定问题的<strong>约束条件</strong>。约束条件通常包括等式约束和不等式约束，用于限制决策变量的取值范围。</li><li><strong>建立多目标规划模型</strong>。根据实际问题的特点，选择适当的多目标规划方法，例如线性规划、非线性规划、整数规划等。</li></ul></li></ul><h3 id="💡权重法"><a href="#💡权重法" class="headerlink" title="💡权重法"></a>💡权重法</h3><p>权重法（Weighted Sum Method）：将多目标问题转化为单目标问题，<strong>将多个目标函数加权求和</strong>，然后对单个目标函数进行最优化求解。</p><h3 id="💡向量优化法"><a href="#💡向量优化法" class="headerlink" title="💡向量优化法"></a>💡向量优化法</h3><p>向量优化法是用于解决多目标规划问题的一种方法，它通过将多个目标函数组合成一个目标向量，然后利用向量之间的比较进行求解。向量优化法的基本思想是将多个目标函数的最小化问题转化为<strong>一个目标向量的最小化问题</strong>。</p><h3 id="💡约束优化法"><a href="#💡约束优化法" class="headerlink" title="💡约束优化法"></a>💡约束优化法</h3><p>约束优化法是一种常用的求解多目标规划问题的方法，它将目标函数最小化的问题转化为一个<strong>带有约束条件的最优化问题</strong>。该方法通常可以用来解决复杂的多目标规划问题，其中目标函数之间存在相互制约的关系。</p><h3 id="💡帕累托最优"><a href="#💡帕累托最优" class="headerlink" title="💡帕累托最优"></a>💡帕累托最优</h3><ul><li><p><strong>解A优于解B</strong>（解A强帕累托支配解B）</p><p>  假设现在有两个目标函数，<strong>解A对应的目标函数值都比解B对应的目标函数值好</strong>，则称解A比解B优越，也可以叫做解A强帕累托支配解B</p><p>  下图解E优于解C,D</p><p>  <img src="/img/pareto1.png"></p></li><li><p><strong>解A无差别于解B</strong>（解A能帕累托支配解B）</p><p>  同样假设两个目标函数，解A对应的一个目标函数值优于解B对应的一个目标函数值，但是解A对应的另一个目标函数值要差于解B对应的一个目标函数值，则称解A无差别于解B，也叫作解A能帕累托支配解B，</p><p>  上面的图，点C和点D就是这种情况，C点在第一个目标函数的值比D小，在第二个函数的值比D大。</p></li><li><p><strong>最优解</strong></p><p>  假设在设计空间中，<strong>解A对应的目标函数值优越其他任何解，</strong>则称解A为最优解</p><p>  实际生活中这种解是不可能存在的，由此提出了帕累托最优解</p></li><li><p><strong>帕累托最优解</strong></p><p>  假设两个目标函数，对于解A而言，在 变量空间 中<strong>找不到其他的解能够优于解A</strong>（注意这里的优于一定要<strong>两个目标函数值都优于A对应的函数值</strong>），那么解A就是帕累托最优解</p><p>  下图x1 x2之间都是帕累托最优解</p><p>  <img src="/img/pareto2.png"></p></li><li><p><strong>帕累托最优前沿</strong></p><p>  帕累托最优解对应的目标函数值就是帕累托最优前沿</p></li></ul><hr><p><strong>0204更</strong></p><p>哎呦最后竟然真的用到了pareto！</p><p>下面是算法伪代码，板子上写不出好看的字</p><p><img src="/img/pareto.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Per aspera ad astra</title>
    <link href="/2024/01/31/%E7%A9%BF%E8%B6%8A%E9%80%86%E5%A2%83%E6%8A%B5%E8%BE%BE%E7%B9%81%E6%98%9F/"/>
    <url>/2024/01/31/%E7%A9%BF%E8%B6%8A%E9%80%86%E5%A2%83%E6%8A%B5%E8%BE%BE%E7%B9%81%E6%98%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="穿越逆境-抵达繁星"><a href="#穿越逆境-抵达繁星" class="headerlink" title="穿越逆境 抵达繁星"></a>穿越逆境 抵达繁星</h2><p>🌼一段超级温暖的话，from一位超级爱的朋友…</p><span id="more"></span><p>&nbsp;</p><p>​<strong>“人一直会看见高山，而一山总比一山高，希望你相信你也是很棒的很勇敢的很优秀的很专注的很多人爱你的，每个人成为呼啸最高峰的那阵风前，都有过无数挫败晦暗的时刻，正是因为客观存在的这些问题，人往往能够追求更好的自我。我认为痛苦从来不是必要的，但直接面对它的人、勇于挑战它的人，永远都很了不起。”</strong></p><p>&nbsp;</p><p><img src="/img/test.jpg"></p><p>&nbsp;</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SmoothLLM</title>
    <link href="/2024/01/31/SmoothLLM/"/>
    <url>/2024/01/31/SmoothLLM/</url>
    
    <content type="html"><![CDATA[<h1 id="SmoothLLM"><a href="#SmoothLLM" class="headerlink" title="SmoothLLM"></a>SmoothLLM</h1><p>💪 <strong>Defending Large Language Models Against Jailbreaking Attacks</strong></p><span id="more"></span><p>SmoothLLM 是一种旨在<strong>保护大型语言模型免受越狱攻击</strong>的算法</p><p>原论文请参看<a href="https://arxiv.org/abs/2310.03684">SmoothLLM</a></p><h2 id="Several-concepts"><a href="#Several-concepts" class="headerlink" title="Several concepts"></a>Several concepts</h2><h3 id="Adversarial-prompting"><a href="#Adversarial-prompting" class="headerlink" title="Adversarial prompting"></a>Adversarial prompting</h3><p><strong>对抗性输入（Adversarial Input）</strong>是指经过有意设计或修改的输入数据，旨在欺骗或误导机器学习模型的输入。</p><ul><li><strong>提示注入（Prompt Injection)</strong><br>  通过注入一条指令来劫持模型输出，以忽略原始指令并执行注入的指令</li><li><strong>提示泄漏（Prompt Leaking)</strong><br>  模型可能通过提示的选择或生成的内容中泄露出训练数据的信息</li><li><strong>越狱（Jailbreaking)</strong><br>  对预先训练的语言模型进行攻击，使其生成不当或有害的内容，即使模型原本经过了对抗性训练</li><li><strong>防御策略（Defense Tactics)</strong></li></ul><h3 id="Adversarial-training"><a href="#Adversarial-training" class="headerlink" title="Adversarial training"></a>Adversarial training</h3><ul><li>提高模型对抗攻击的能力，使其在面对输入数据中的有意制造的扰动或误导性信息时能够保持<strong>稳健性</strong></li><li>通过在训练数据中引入一些经过计算的<strong>对抗性样本</strong>，迫使模型更好地理解和适应这些干扰，从而提高其在真实场景中的<strong>鲁棒性</strong></li><li>对抗性训练的步骤<ul><li>生成对抗性样本</li><li>将对抗性样本添加到训练集</li><li>训练模型</li></ul></li></ul><h3 id="Jailbreaking"><a href="#Jailbreaking" class="headerlink" title="Jailbreaking"></a>Jailbreaking</h3><ul><li><strong>越狱（Jailbreaking）</strong>是一种提示注入技术，用于绕过语言模型（LLM）的创建者放置在其上的安全和审查功能</li><li>越狱的方法<ul><li><strong>伪装</strong><ul><li>简单伪装 pretend you can…</li><li>角色扮演 he is an actor…</li></ul></li><li><strong>对齐黑客</strong><ul><li>承担责任 you are supposed to answer…</li><li>研究实验 i am conducting a test about…</li></ul></li><li><strong>授权用户</strong><ul><li>上级模型  I am GPT-4…you are GPT-3</li><li>sudo模式 内核模式</li></ul></li></ul></li></ul><h2 id="Abastact"><a href="#Abastact" class="headerlink" title="Abastact"></a>Abastact</h2><ul><li><p>SmoothLLM is an algorithm designed to <strong>defend large language models against jailbreaking attacks</strong>.</p></li><li><p>It randomly <strong>perturbs input prompts and aggregates predictions</strong> to detect adversarial inputs.</p></li><li><p>SmoothLLM <strong>reduces the attack success rate</strong> on popular LLMs to below one percentage point.</p></li><li><p>It uses exponentially <strong>fewer queries</strong> than existing attacks and is <strong>compatible</strong> with any LLM.</p></li></ul><h2 id="Symbol-convention"><a href="#Symbol-convention" class="headerlink" title="Symbol convention"></a>Symbol convention</h2><ul><li><p><strong>a deterministic function JB</strong><br>  checks whether the response R begins with the target T</p><p>  <img src="/img/smooth1.png"></p></li><li><p><strong>the goal of the attack</strong></p><p>  <img src="/img/smooth2.png"></p></li><li><p><strong>attack success rate (ASR)</strong></p><p>  the ASR is the fraction of the triplets (Gj, Tj, Sj) in D that jailbreak the LLM.</p><p>  <img src="/img/smooth3.png"></p></li></ul><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><ul><li>对抗性训练或数据增强<ul><li>需要对底层模型重新训练，计算上不可行</li><li>闭源模型不透明，只能通过查询访问来防御</li></ul></li><li>使用困惑度过滤器进行预处理、改写输入提示以及采用对抗性训练<ul><li>计算成本大</li></ul></li><li>在输入提示的子字符串上应用安全过滤器<ul><li>复杂性随着输入提示的长度增加而增加</li><li>并未在GCG攻击下进行评估</li></ul></li></ul><h2 id="A-desiderata-for-LLM-defenses"><a href="#A-desiderata-for-LLM-defenses" class="headerlink" title="A desiderata for LLM defenses"></a>A desiderata for LLM defenses</h2><ul><li>在缓解攻击的同时，不应对非敌对输入产生显著性能下降<ul><li><strong>攻击缓解（Attack Mitigation）</strong></li><li><strong>非保守性（Non-Conservatism）</strong></li></ul></li><li>在不引入实施折衷的情况下对所有可用LLMs的适用性<ul><li><strong>效率（Efficiency）</strong></li><li><strong>兼容性（Compatibility）</strong></li></ul></li></ul><h2 id="SmoothLLM-Algorithm1"><a href="#SmoothLLM-Algorithm1" class="headerlink" title="SmoothLLM Algorithm1"></a>SmoothLLM Algorithm1</h2><p><img src="/img/smooth9.png" alt="smoothllm"></p><h3 id="Perturbation-step"><a href="#Perturbation-step" class="headerlink" title="Perturbation step"></a>Perturbation step</h3><ul><li>three kinds of perturbations<ul><li>Insert</li><li>Swap</li><li>Patch</li></ul></li><li>At q &#x3D; 10%, the ASR for swap perturbations falls below 1%</li><li>the entire prompt is perturbed, not just the suffix;</li></ul><h3 id="Agregation-step"><a href="#Agregation-step" class="headerlink" title="Agregation step"></a>Agregation step</h3><ul><li>a collection of perturbed prompts</li><li>on average, perturbed prompts tend to nullify jailbreaks</li><li>SmoothLLM算法的核心思想是<strong>通过对输入提示进行大量随机扰动，引入随机性，以平均地抵消对抗性部分</strong></li></ul><h3 id="Algorithm1"><a href="#Algorithm1" class="headerlink" title="Algorithm1"></a>Algorithm1</h3><p><img src="/img/smooth4.png" alt="Algorithm1"></p><ul><li>随机扰动生成了N个输入提示Qj，传递给LLM模型生成响应</li><li>判断大多数响应是否是“jailbreak”</li><li>返回与该估计一致的任何响应LLM(Q)，汇总这些预测</li><li>Algorithm 1的两个参数：N（样本数量）和q（扰动百分比）</li></ul><h3 id="Robustness-guarantees"><a href="#Robustness-guarantees" class="headerlink" title="Robustness guarantees"></a>Robustness guarantees</h3><p><img src="/img/smooth5.png"></p><ul><li>k (不稳定参数) 是要使得攻击失败，最少需要改变的字符数</li></ul><p><img src="/img/smooth6.png"></p><ul><li>m是输入提示的长度，ms是后缀的长度，M是扰动的字符数</li><li>当攻击对扰动更加鲁棒时，为了提高SmoothLLM成功减轻攻击的概率，需要增加扰动百分比q</li></ul><h3 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h3><p><img src="/img/smooth7.png"></p><h2 id="Experimental-evaluation"><a href="#Experimental-evaluation" class="headerlink" title="Experimental evaluation"></a>Experimental evaluation</h2><h3 id="Attack-mitigation"><a href="#Attack-mitigation" class="headerlink" title="Attack mitigation"></a>Attack mitigation</h3><ul><li>GCG对Vicuna和Llama2的攻击<ul><li>ASR显著降低</li></ul></li><li>SmoothLLM对自适应攻击的威胁<ul><li>不能直接用GCG攻击，因为是字符级别扰动使得梯度计算不可行（可以用代理模型在token级别攻击）</li><li>使用代理模型时，攻击SmoothLLM的效果不如直接攻击未进行防御的LLM</li></ul></li><li>SmoothLLM对PAIR语义jailbreak的防御<ul><li>不是针对PAIR的模型，但是仍可以有效降低ASR</li></ul></li></ul><h3 id="Non-conservatism"><a href="#Non-conservatism" class="headerlink" title="Non-conservatism"></a>Non-conservatism</h3><ul><li>N值越大往往会提高标称性能，而q值的增加则会降低标称性能</li><li>平衡减弱攻击性和生成有效文本的程度</li></ul><h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><ul><li>SmoothLLM的查询效率通常比GCG高5到6个数量级（对昂贵攻击的廉价防御）</li></ul><h3 id="Compatibility"><a href="#Compatibility" class="headerlink" title="Compatibility"></a>Compatibility</h3><ul><li>通过转移攻击后缀实验表明，SmoothLLM在一定程度上对于闭源LLM具有兼容性</li></ul><h2 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h2><ul><li><strong>The interplay between q and the ASR</strong><ul><li>q应该被选择得足够小，以便提示符保留其语义内容</li><li>未来的工作应该关注更健壮的方法来检测越狱</li></ul></li><li><strong>Broad applicability of SmoothLLM</strong><ul><li>由于SmoothLLM干扰了整个输入提示，此防御广泛适用于任何基于反向提示的越狱</li></ul></li><li><strong>The computational burden of jailbreaking</strong><ul><li>查询效率高、时间效率高、与黑盒llm的兼容性强</li><li>SmoothLLM是随机防御，廉价地防御</li></ul></li><li><strong>Other variants of SmoothLLM</strong><ul><li>设计和评估SmoothLLM的新变体</li><li>比如聚合步骤的新方案</li></ul></li></ul><p><img src="/img/smooth10.png"></p><p><img src="/img/smooth11.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>大模型</category>
      
      <category>攻防问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模小笔记</title>
    <link href="/2024/01/31/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%80%BB%E8%A7%88/"/>
    <url>/2024/01/31/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>🤔 准备小小记录一篇~ 笔记的图片还是等把picgo修好了再全部上传吧😭</p><span id="more"></span><h3 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h3><ul><li><p><strong>1 、优化模型</strong></p></li><li><ul><li>1.1 数学规划模型<ul><li>1.2 微分方程组模型</li><li>1.3 图论与网络优化问题</li><li>1.4 概率模型</li><li>1.5 组合优化经典问题</li><li>现代优化算法：禁忌搜索；模拟退火；遗传算法；人工神经网络</li></ul></li></ul></li><li><p><strong>2、分类模型</strong></p></li><li><ul><li>2.1 判别分析<ul><li>2.2 聚类分析</li><li>2.3 神经网络分类方法</li></ul></li></ul></li><li><p><strong>3、评价模型</strong></p></li><li><ul><li>3.1 层次分析法(AHP)<ul><li>3.2 灰色综合评价法（灰色关联度分析）</li><li>3.3 模糊综合评价法</li><li>3.4 BP神经网络综合评价法</li><li>3.5 数据包络法(DEA)</li><li>3.6 组合评价法</li></ul></li></ul></li><li><p><strong>4、预测模型</strong></p></li><li><ul><li>4.1 回归分析法<ul><li>4.2 时间序列分析法</li><li>4.3 灰色预测法</li><li>4.4 BP神经网络法</li><li>4.5 支持向量机法</li><li>4.6 组合预测法</li></ul></li></ul></li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="灵敏度分析"><a href="#灵敏度分析" class="headerlink" title="灵敏度分析"></a>灵敏度分析</h4><p>模型中有些参数设置的是常数，但现实中很难存在严格意义上的常数参数，所以求解完问题之后<strong>对某些常数参数进行修改</strong>，如果修改后的模型求解的结果与原先相差不大，则灵敏度分析是可靠的</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex的配置和使用</title>
    <link href="/2024/01/31/Latex%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/31/Latex%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Latex的配置和使用"><a href="#Latex的配置和使用" class="headerlink" title="Latex的配置和使用"></a>Latex的配置和使用</h2><p>👊 美赛将至，记录一下latex相关的，有坑有经验有方法</p><span id="more"></span><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="安装Tex-Live"><a href="#安装Tex-Live" class="headerlink" title="安装Tex Live"></a>安装Tex Live</h4><ul><li>直接去官网下载i<strong>so后缀的压缩包</strong>即可，或者镜像源下载，压缩包体积很大，需要耐心一点</li></ul><blockquote><p>注意！！！血泪教训！！！不要随意更改压缩包下载路径，<strong>压缩包就下在C盘里面</strong>，后面出现报错最后发现就是下到D盘导致的。配置过程还有什么问题可参考下面链接</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/412931055">texlive安装失败问题总结</a></p><ul><li>解压缩，解压路径随意了</li><li>双击后缀为bat的文件，为了节省空间可以只下载必要的语言和附带的工具，在advance-collection里面设置</li><li>点击安装，经历一个亿点点漫长的等待……success</li><li>正常情况没什么问题，我一波三折是因为前段时间马虎得把系统环境变量Path删了，修复之后今天安装成功</li></ul><h4 id="下载TeX编辑器"><a href="#下载TeX编辑器" class="headerlink" title="下载TeX编辑器"></a>下载TeX编辑器</h4><p>随意选择，按需使用咯</p><ul><li><strong>Texstudio</strong></li><li><strong>VSCode</strong></li><li><strong>Overleaf</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对话：传播的智慧</title>
    <link href="/2024/01/28/%E4%BC%A0%E6%92%AD%E7%9A%84%E6%99%BA%E6%85%A7/"/>
    <url>/2024/01/28/%E4%BC%A0%E6%92%AD%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="《书写一张融合文化感，归属感和个性感的城市名片》"><a href="#《书写一张融合文化感，归属感和个性感的城市名片》" class="headerlink" title="《书写一张融合文化感，归属感和个性感的城市名片》"></a><em><strong>《书写一张融合文化感，归属感和个性感的城市名片》</strong></em></h3><p>​🎉<strong>对话:传播的智慧 结课论文~ 很喜欢的一篇作品啊，仿佛找回久违的高中的一丝文气</strong>🌼</p><span id="more"></span><p> <img src="/img/city6.png"></p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>在一张张丰富多彩的城市名片上，鄂尔多斯如黄河般奔腾，展现着绿色发展和金色传奇的中国现代古城魅力；海淀则以集艺术之大成的园林艺术、走在时代前沿的科技创新和领先教育为笔墨，勾勒出一幅引人流连徜徉的美好画卷；而武汉，有“百湖之市”这张靓丽的绿色名片，有“中国最具幸福感城市”这句响亮的口号，更有几年前疫情之下众志成城的“英雄城市”这个光荣的头衔，我们大武汉的形象愈加丰富多元，深入人心。</p><p>近几年，全国多所城市纷纷打造“一公里半径读书圈”，这是城市打造自己文化品牌的众多举措之一。还有社区图书馆、读书自助驿站、流动读书点、街道书屋陆续“上线”，更有最美夜市、建筑艺术馆，原生态民居、科技创新、传统文化等等目不暇接，各大城市都亮出了自己的文化名片。</p><p>城市形象是一个城市文化的外显，是能够激发人们思想感情活动的城市形态和特征。正如毕淑敏所言，城市是一粒粒精致的银扣，不分昼夜地熠熠闪光。一座城市有无限宝藏亟需我们去发掘，有无数色彩等待我们去描摹，所以一座城市应该给人留下什么样的记忆或印象？一座城市应该如何打造自己的名片？我想，一张融合文化感，归属感和个性感的城市名片是一个不错的答案。</p><p>  <img src="/img/city2.jpg"></p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>我国是拥有五千余年历史的文明古国，在不同的区域、不同的城市都有经典亦精彩的文化底蕴，它们在城市的风貌中灿烂闪烁、历久弥坚。南京的烟柳绿水秦淮河、北京的碧瓦皇墙四合院、苏州的小巧园林、西安的古都文化……这些都是我国厉史性代表城市別具一格的文化特色，它们也已成为这些城市不可磨灭的形象。</p><p>《城市文化》中有言，“城市是文化的容器”。只有立得住根，守得住魂，城市才能在岁月的风雨中成长，才能经得住时代发展任务的考验。</p><p>然而，近年来许多大体量的新建筑在各个城市拔地而起，“前城一面”的问题也更加严重，习总书记在上海考察时曾言：“城市历史文化遗存的是前人智慧的沉淀，是城市内涵、品质、特色的重要标志”。诚然，只有牢记漫漫历史积淀下来的文化底蕴，一座城才永远有迈步向前的厚实底气。</p><p><img src="/img/city3.jpg"></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>梭罗叹：“城市是一个几百万人一起孤独生活的地方。”然而城市也能以其特有的暖心之举，人文关怀，让生活在其中的人孤独尽失，爱意隆重。</p><p>面对严峻的冬季疫情防控形势，为了减少人员大规模流动，不少城市发出倡议：就地过年。各地相继启动暖心行动：图书馆举办年节特色活动，社区“一对一”指导年夜饭，对就地过年的人员实施奖励慰问，发放现金补贴……收到充满人文关怀的温暖名片，人们在这样的城市找到了归属感。</p><p>用人文情怀柔化一座城，用城市关怀温暖一群人，用众人之力书写城市名片。共情才能共鸣，共鸣才能同心，同心才能共振。当一座城市真正做到暖入人心，深入人心，这座城市的名片才有深度，有意义。</p><p> <img src="/img/wuhan1.jpg"></p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>近些年来，“网红城市”呈井喷状态，遍地开花。“网红城市”最大的“卖点”并非是多么宏大的山水风景，恰恰是在当地居民看来及其寻常的“细节”，彰显了城市个性。而随着当前短视频平台的兴起，或许你一个瞬间不经意的记录，就为你的城市名片添上独具匠心的一笔。</p><p>国家对外文化交流研究基地主任陈圣来说：“最理想的城市宣传，是由每个市民来进行。”以其最个性化的传播，逃离快速发展下同质化潮流的裹挟。</p><p>可以发现，人们对城市形象的感知，逐渐变为场景化，多元化的动态审美，在关注城市物质空间的同时，也注重城市与人的互动，以及个体的心理感受。这对于城市治理者非常具有启示意义，当外界用全新的眼光衡量这座城市的价值时，那么城市也要学会重新认识自己。一座城市只有依靠不断创新和改革，努力放大自己的特质，才可能在现代城市竞争中取胜。</p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>打造一个具有文化浓度，人情温度，时代深度的城市IP，任重而道远，需要城市和人民携手，文化与创意齐飞。众心成文，众志成城，书写出一张张融合文化感，归属感和个性感的城市名片，在于你，在于我，在于这个时代的每一个人。</p><p> <img src="/img/city4.png"></p>]]></content>
    
    
    <categories>
      
      <category>文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识</title>
    <link href="/2024/01/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/01/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><p>🤔 面向对象期末考试前三天速成Java大师</p><span id="more"></span><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><strong>局部变量</strong>  方法 语句块中</li><li><strong>成员变量</strong> 类中  方法外</li><li><strong>类变量&#x2F;静态变量</strong><ul><li>类中 方法外 </li><li>static</li><li>与类相关 不与实例相关</li></ul></li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在Java中，修饰符是用来修饰类、方法、变量以及其他数据类型的关键字。它们提供了额外的信息，用于控制访问级别、继承性、特定行为等。以下是一些常见的Java修饰符：</p><ol><li><p><strong>访问修饰符（Access Modifiers）：</strong></p><ul><li><code>public</code>: 公共的，可以被任何类访问。</li><li><code>protected</code>: 受保护的，可以被同一包内的类及其子类访问。</li><li><code>default</code> (包级别): 如果没有指定修饰符，默认为包级别，可以被同一包内的类访问。</li><li><code>private</code>: 私有的，只能在声明它的类内部访问。</li></ul></li><li><p><strong>非访问修饰符：</strong></p><ul><li><code>final</code>: 表示最终的，不可更改的。用于修饰类、方法、变量。</li><li><code>abstract</code>: 用于声明抽象类和抽象方法。</li><li><code>static</code>: 表示静态的，属于类而不是实例。用于方法、变量、代码块。</li><li><code>transient</code>: 用于标记不希望序列化的字段。</li><li><code>volatile</code>: 用于多线程编程，确保变量的可见性。</li></ul></li><li><p><strong>其他修饰符：</strong></p><ul><li><code>synchronized</code>: 用于多线程同步，修饰方法或代码块。</li><li><code>native</code>: 表示一个方法用其他编程语言（如C、C++）实现，通常与<code>JNI</code>（Java Native Interface）一起使用。</li><li><code>strictfp</code>: 用于确保浮点运算在不同平台上产生相同的结果。</li><li><code>default</code> (接口中): 用于指定接口中的默认方法实现。</li></ul></li><li><p><strong>注解修饰符：</strong></p><ul><li><code>@Override</code>: 表示该方法覆盖了父类的方法。</li><li><code>@Deprecated</code>: 表示该元素（类、方法等）已过时，不推荐使用。</li><li><code>@SuppressWarnings</code>: 抑制编译器警告。</li><li>其他自定义注解。</li></ul></li></ol><p>这些修饰符可以根据需要进行组合使用，以满足特定的编程需求。例如，一个方法可以同时使用<code>public</code>、<code>static</code>和<code>final</code>修饰符。</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li></ul><h3 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h3><h4 id="character类"><a href="#character类" class="headerlink" title="character类"></a>character类</h4><p>Java中的<code>Character</code>类是一个包装类，用于表示字符类型数据（Unicode字符）。它提供了许多用于处理字符的方法和常量。</p><p>以下是一些<code>Character</code>类的常用方法和常量：</p><ol><li><p>静态方法：</p><ul><li><code>isDigit(char ch)</code>：检查字符是否为数字字符。</li><li><code>isLetter(char ch)</code>：检查字符是否为字母字符。</li><li><code>isLetterOrDigit(char ch)</code>：检查字符是否为字母或数字字符。</li><li><code>isUpperCase(char ch)</code>：检查字符是否为大写字母。</li><li><code>isLowerCase(char ch)</code>：检查字符是否为小写字母。</li><li><code>toUpperCase(char ch)</code>：将字符转换为大写。</li><li><code>toLowerCase(char ch)</code>：将字符转换为小写。</li></ul></li><li><p>常量：</p><ul><li><code>MIN_VALUE</code>：<code>char</code>类型的最小值，即 <code>\u0000</code>。</li><li><code>MAX_VALUE</code>：<code>char</code>类型的最大值，即 <code>\uffff</code>。</li><li><code>MIN_RADIX</code>：进制的最小值，即 2。</li><li><code>MAX_RADIX</code>：进制的最大值，即 36。</li><li><code>SIZE</code>：<code>char</code>类型的位数，通常为 16。</li></ul></li></ol><p>下面是一个示例代码，演示了如何使用<code>Character</code>类的一些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>        System.out.println(Character.isDigit(ch));  <span class="hljs-comment">// false</span><br>        System.out.println(Character.isLetter(ch));  <span class="hljs-comment">// true</span><br>        System.out.println(Character.isLetterOrDigit(ch));  <span class="hljs-comment">// true</span><br>        System.out.println(Character.isUpperCase(ch));  <span class="hljs-comment">// true</span><br>        System.out.println(Character.isLowerCase(ch));  <span class="hljs-comment">// false</span><br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">lowercaseCh</span> <span class="hljs-operator">=</span> Character.toLowerCase(ch);<br>        System.out.println(lowercaseCh);  <span class="hljs-comment">// &#x27;a&#x27;</span><br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">uppercaseCh</span> <span class="hljs-operator">=</span> Character.toUpperCase(ch);<br>        System.out.println(uppercaseCh);  <span class="hljs-comment">// &#x27;A&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h4><p>在Java中，<code>String</code>类是一个非常常用的类，用于表示和操作字符串。它是<strong>不可变（immutable）</strong>的，意味着一旦创建，就不能更改其内容。<code>String</code>类提供了许多方法来处理字符串，如下所示：</p><ol><li><p>创建字符串：</p><ul><li>使用双引号：<code>String str = &quot;Hello, World!&quot;;</code></li><li>使用<code>new</code>关键字：<code>String str = new String(&quot;Hello, World!&quot;);</code></li></ul></li><li><p>字符串长度：</p><ul><li><code>int length()</code>: 返回字符串的长度。</li></ul></li><li><p>字符串连接：</p><ul><li><code>String concat(String str)</code>: 将指定的字符串连接到原始字符串的末尾。</li><li>使用加号（+）运算符：<code>String result = str1 + str2;</code></li></ul></li><li><p>字符串提取：</p><ul><li><code>char charAt(int index)</code>: 返回指定索引位置的字符。</li><li><code>String substring(int beginIndex)</code>: 返回从指定索引开始到字符串末尾的子字符串。</li><li><code>String substring(int beginIndex, int endIndex)</code>: 返回从指定的开始索引到结束索引之间的子字符串（不包括结束索引）。</li></ul></li><li><p>字符串查找：</p><ul><li><code>int indexOf(String str)</code>: 返回指定字符串在原始字符串中第一次出现的索引。</li><li><code>int lastIndexOf(String str)</code>: 返回指定字符串在原始字符串中最后一次出现的索引。</li><li><code>boolean contains(CharSequence sequence)</code>: 检查原始字符串是否包含指定的字符序列。</li></ul></li><li><p>字符串替换：</p><ul><li><code>String replace(char oldChar, char newChar)</code>: 将原始字符串中的所有旧字符替换为新字符。</li><li><code>String replace(CharSequence target, CharSequence replacement)</code>: 将原始字符串中的所有目标字符序列替换为指定的替换字符序列。</li></ul></li><li><p>字符串拆分：</p><ul><li><code>String[] split(String regex)</code>: 使用给定的正则表达式将字符串拆分为子字符串数组。</li></ul></li><li><p>字符串转换：</p><ul><li><code>char[] toCharArray()</code>: 将字符串转换为字符数组。</li><li><code>byte[] getBytes()</code>: 将字符串转换为字节数组。</li><li><code>int parseInt(String str)</code>: 将字符串解析为整数。</li></ul></li><li><p>字符串比较：</p><ul><li><code>boolean equals(Object obj)</code>: 检查字符串是否与指定对象相等。</li><li><code>boolean equalsIgnoreCase(String anotherString)</code>: 检查字符串是否与指定字符串相等，忽略大小写。</li><li><code>int compareTo(String anotherString)</code>: 按字典顺序比较两个字符串。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        System.out.println(<span class="hljs-string">&quot;Length: &quot;</span> + length);  <span class="hljs-comment">// 13</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">concatStr</span> <span class="hljs-operator">=</span> str.concat(<span class="hljs-string">&quot; Welcome!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Concatenated String: &quot;</span> + concatStr);  <span class="hljs-comment">// Hello, World! Welcome!</span><br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">charAtIndex</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">4</span>);<br>        System.out.println(<span class="hljs-string">&quot;Character at index 4: &quot;</span> + charAtIndex);  <span class="hljs-comment">// o</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">subString</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">7</span>);<br>        System.out.println(<span class="hljs-string">&quot;Substring from index 7: &quot;</span> + subString);  <span class="hljs-comment">// World!</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">indexOf</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-string">&quot;o&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;First index of &#x27;o&#x27;: &quot;</span> + indexOf);  <span class="hljs-comment">// 4</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">replacedStr</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Replaced String: &quot;</span> + replacedStr);  <span class="hljs-comment">// Hellx, Wxrld!</span><br><br>        String[] splitArray = str.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Split String:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : splitArray) &#123;<br>            System.out.println(s);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Output:</span><br><span class="hljs-comment">        Split String:</span><br><span class="hljs-comment">        Hello</span><br><span class="hljs-comment">         World!</span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-type">char</span>[] charArray = str.toCharArray();<br>        System.out.println(<span class="hljs-string">&quot;Character Array:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : charArray) &#123;<br>            System.out.println(c);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Output:</span><br><span class="hljs-comment">        Character Array:</span><br><span class="hljs-comment">        H</span><br><span class="hljs-comment">        e</span><br><span class="hljs-comment">        l</span><br><span class="hljs-comment">        l</span><br><span class="hljs-comment">        o</span><br><span class="hljs-comment">        ,</span><br><span class="hljs-comment">         </span><br><span class="hljs-comment">        W</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><h4 id="stringBuffer"><a href="#stringBuffer" class="headerlink" title="stringBuffer"></a>stringBuffer</h4><p>在Java中，<code>StringBuffer</code>类是一个<strong>可变的字符串类</strong>，用于处理可变字符串。与<code>String</code>类不同，<code>StringBuffer</code>类的内容可以修改。<code>StringBuffer</code>类提供了许多方法来对字符串进行修改和操作。</p><p>以下是<code>StringBuffer</code>类的一些常用方法：</p><ol><li><p>创建<code>StringBuffer</code>对象：</p><ul><li><code>StringBuffer sb = new StringBuffer();</code>：创建一个空的<code>StringBuffer</code>对象。</li><li><code>StringBuffer sb = new StringBuffer(&quot;Hello&quot;);</code>：使用指定的字符串创建一个<code>StringBuffer</code>对象。</li></ul></li><li><p>追加和插入操作：</p><ul><li><code>StringBuffer append(String str)</code>：在当前字符串的末尾追加指定的字符串。</li><li><code>StringBuffer insert(int offset, String str)</code>：在指定的偏移量位置插入指定的字符串。</li></ul></li><li><p>删除操作：</p><ul><li><code>StringBuffer delete(int start, int end)</code>：删除指定索引范围内的字符。</li><li><code>StringBuffer deleteCharAt(int index)</code>：删除指定索引位置的字符。</li></ul></li><li><p>修改操作：</p><ul><li><code>void setCharAt(int index, char ch)</code>：将指定索引位置的字符设置为给定字符。</li><li><code>void replace(int start, int end, String str)</code>：将指定索引范围内的字符替换为给定字符串。</li></ul></li><li><p>反转字符串：</p><ul><li><code>StringBuffer reverse()</code>：反转当前字符串。</li></ul></li><li><p>获取字符串长度：</p><ul><li><code>int length()</code>：返回当前字符串的长度。</li></ul></li><li><p>转换为字符串：</p><ul><li><code>String toString()</code>：将当前字符串缓冲区转换为<code>String</code>对象。</li></ul></li></ol><p>下面是一个示例代码，演示了如何使用<code>StringBuffer</code>类的一些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBufferExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><br>        sb.append(<span class="hljs-string">&quot;, World!&quot;</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello, World!</span><br><br>        sb.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot; Java&quot;</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello Java, World!</span><br><br>        sb.delete(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello, World!</span><br><br>        sb.setCharAt(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;J&#x27;</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello, Jorld!</span><br><br>        sb.reverse();<br>        System.out.println(sb.toString());  <span class="hljs-comment">// !dlroJ ,olleH</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> sb.length();<br>        System.out.println(<span class="hljs-string">&quot;Length: &quot;</span> + length);  <span class="hljs-comment">// 13</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们首先创建了一个<code>StringBuffer</code>对象<code>sb</code>，并使用其方法进行追加、插入、删除、修改和反转操作。最后，我们获取了字符串的长度并输出结果。</p><p>需要注意的是，<code>StringBuffer</code>类是线程安全的，适用于多线程环境。如果在单线程环境下使用，建议使用效率更高但线程不安全的<code>StringBuilder</code>类。</p><h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        name = myName; <br>        id = myid;<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123; <br>        System.out.println(name+<span class="hljs-string">&quot;正在吃&quot;</span>); <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;正在睡&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">introduction</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;大家好！我是&quot;</span>         + id + <span class="hljs-string">&quot;号&quot;</span> + name + <span class="hljs-string">&quot;.&quot;</span>); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Penguin</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        <span class="hljs-built_in">super</span>(myName, myid); <br>        <span class="hljs-comment">//可以用super()通过父类的公有方法（public 方法）来访问和设置 private 成员</span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Java 不支持多继承，但支持多重继承。</p></li><li><p>子类拥有父类非 private 的属性、方法。</p></li><li><p><strong>extends</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">private</span> String name;   <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        <span class="hljs-comment">//初始化属性值</span><br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//吃东西方法的具体实现  &#125; </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//睡觉方法的具体实现  &#125; </span><br>&#125; <br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Animal</span>&#123; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>implements</strong></li></ul><p>使用 implements 关键字可以<strong>变相</strong>的使java具有<strong>多继承</strong>的特性，使用范围为类继承接口的情况，可以<strong>同时继承多个接口</strong>（接口跟接口之间采用逗号分隔）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>super 和 this</strong><ul><li><strong>super</strong>关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</li><li><strong>this</strong>关键字：指向自己的引用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;animal : eat&quot;</span>);<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;dog : eat&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.eat();   <span class="hljs-comment">// this 调用自己的方法</span><br>    <span class="hljs-built_in">super</span>.eat();  <span class="hljs-comment">// super 调用父类方法</span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>    a.eat();<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    d.eatTest();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>final</strong></p><ul><li>使用 final 关键字声明类，就是把类定义定义为<strong>最终类</strong>，<strong>不能被继承</strong></li><li>或者用于<strong>修饰方法</strong>，该方法<strong>不能被子类重写</strong></li></ul></li><li><p><strong>构造器</strong></p><ul><li>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</li><li>如果父类的构造器<strong>带有参数</strong>，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</li><li>如果父类构造器<strong>没有参数</strong>，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会<strong>自动调用父类的无参构造器</strong>。</li></ul></li></ul><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>在Java中，方法的重写是指子类定义了一个与其父类中方法<strong>签名相同</strong>（<strong>方法名、参数列表、返回类型相同</strong>）的方法。<strong>重写（Override）发生在继承关系中</strong>，子类通过<strong>重写父类的方法</strong>来提供自己的实现。这样做的主要目的是为了在子类中修改或扩展父类的行为。</p><p>以下是方法重写的基本规则：</p><ol><li><p><strong>方法签名：</strong> 重写的方法与父类方法具有相同的方法签名，包括方法名、参数列表和返回类型。</p></li><li><p><strong>访问修饰符：</strong> 重写的方法的访问修饰符不能比父类中被重写的方法的访问修饰符更严格。例如，如果父类中的方法是<code>public</code>，那么子类中的重写方法也必须是<code>public</code>。</p></li><li><p><strong>返回类型：</strong> 重写的方法的返回类型必须与被重写方法的返回类型相同或是其子类。</p></li><li><p><strong>抛出异常：</strong> 如果被重写的方法在父类中声明了异常，那么子类中重写的方法的声明异常不能超出父类方法声明的异常。子类可以不抛出异常或者只抛出父类方法声明的异常的子类。</p></li></ol><p>下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal makes a sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 子类重写父类方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 子类可以新增其他方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fetch</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog fetches a ball&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        animal.makeSound();  <span class="hljs-comment">// 调用的是Dog类的makeSound()方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code> 类继承了 <code>Animal</code> 类，并重写了 <code>makeSound</code> 方法。在 <code>Main</code> 类中，创建了一个 <code>Dog</code> 对象，并通过 <code>Animal</code> 类型的引用调用了 <code>makeSound</code> 方法。这样的调用会执行 <code>Dog</code> 类中重写的方法，而不是 <code>Animal</code> 类中的原始方法。这就是多态的一种体现。</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>方法的<strong>重载（Overloading）</strong>是指在一个类中可以定义多个方法，这些方法具有<strong>相同的名字</strong>但具有<strong>不同的参数列表</strong>。在方法重载中，方法名相同，但<strong>参数类型、参数个数或者参数顺序不同</strong>。</p><p>重载的目的是提高代码的灵活性和可读性，使得开发者可以用一致的方式来命名不同版本的同一种操作。</p><p>以下是方法重载的基本规则：</p><ol><li>方法名必须相同。</li><li>参数列表必须不同，包括参数类型、参数个数或者参数顺序。</li><li>返回类型可以相同也可以不同。</li><li>可以有不同的访问修饰符。</li><li>重载方法可以声明新的或更广泛的检查异常。</li></ol><p>下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-comment">// 两个整数相加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-comment">// 三个整数相加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b + c;<br>    &#125;<br><br>    <span class="hljs-comment">// 两个浮点数相加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-comment">// 字符串连接</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">concatenate</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-keyword">return</span> str1 + str2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Calculator</code> 类定义了多个名为 <code>add</code> 的方法，它们的参数列表分别为两个整数、三个整数和两个浮点数。这就是方法的重载。同样，还有一个 <code>concatenate</code> 方法，用于字符串连接，也是方法重载的一种形式。</p><p>调用这些方法时，编译器会根据实际参数的数量和类型来确定调用哪个版本的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);          <span class="hljs-comment">// 调用两个整数相加的方法</span><br><span class="hljs-type">int</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>);      <span class="hljs-comment">// 调用三个整数相加的方法</span><br><span class="hljs-type">double</span> <span class="hljs-variable">result3</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">5.5</span>, <span class="hljs-number">10.5</span>);   <span class="hljs-comment">// 调用两个浮点数相加的方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result4</span> <span class="hljs-operator">=</span> calculator.concatenate(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot; World&quot;</span>); <span class="hljs-comment">// 调用字符串连接的方法</span><br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>多态就是同一个接口，使用不同的实例而执行不同操作</p><ul><li><p><strong>必要条件</strong></p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<strong>Parent p &#x3D; new Child();</strong></li></ul></li><li><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，<strong>再去调用子类的同名方法</strong>。</p></li><li><p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在Java中，抽象类（Abstract Class）是一种特殊的类，<strong>它不能被实例化</strong>，用于提供其他类的共同抽象和部分实现，所以抽象类<strong>必须被继承，才能被使用</strong>。抽象类可以包含抽象方法和非抽象方法。</p><p>关键点和特征：</p><ol><li><p><strong>关键字 <code>abstract</code>：</strong> 抽象类使用关键字 <code>abstract</code> 声明。在抽象类中可以包含抽象方法和非抽象方法。抽象方法是没有具体实现的方法，需要在<strong>具体的子类中被实现</strong>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal sleeps&quot;</span>);  <span class="hljs-comment">// 非抽象方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>不能实例化：</strong> 由于抽象类包含抽象方法，不能被直接实例化。可以通过<strong>继承抽象类并提供抽象方法的实现来创建具体的子类</strong>。</p></li><li><p><strong>继承和实现：</strong> 子类继承自抽象类，可以选择性地实现抽象方法。如果子类是非抽象类，它必须提供所有抽象方法的具体实现；如果子类也是抽象类，可以选择性地实现抽象方法，或者继续将它标记为抽象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>可以有构造方法：</strong> 抽象类可以有构造方法，用于初始化抽象类的成员变量或执行其他初始化操作。子类在实例化时，会先调用父类的构造方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-type">int</span> age;<br><br>    Animal(<span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>可以包含成员变量和非抽象方法：</strong> 除了抽象方法外，抽象类可以包含成员变量、非抽象方法、静态方法等。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-type">int</span> sides;<br><br>    Shape(<span class="hljs-type">int</span> sides) &#123;<br>        <span class="hljs-built_in">this</span>.sides = sides;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayInfo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a shape with &quot;</span> + sides + <span class="hljs-string">&quot; sides.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>抽象类用于建模一些通用的特征和行为，并要求具体的子类提供实际的实现。在继承层次结构中，抽象类为多态性提供了基础。</p><ul><li>\1. 抽象类不能被实例化(初学者很容易犯的错)，<strong>如果被实例化，就会报错</strong>，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>\2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>\3. 抽象类中的抽象方法只是声明，不包含方法体，就是<strong>不给出方法的具体实现</strong>也就是方法的具体功能。</li><li>\4. <strong>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</strong>。</li><li>\5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><strong>修改属性的可见性</strong>来限制对属性的访问（一般限制为<strong>private</strong>）</li><li>对每个值属性提供对外的<strong>公共方法</strong>访问，也就是创建一对赋取值方法，用于<strong>对私有属性的访问</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 文件名: EncapTest.java */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncapTest</span>&#123;<br> <br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> String idNum;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> age;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> name;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIdNum</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> idNum;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">( <span class="hljs-type">int</span> newAge)</span>&#123;<br>      age = newAge;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String newName)</span>&#123;<br>      name = newName;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIdNum</span><span class="hljs-params">( String newId)</span>&#123;<br>      idNum = newId;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在Java中，接口（Interface）是一种抽象类型，用于定义一组抽象方法的集合，而不包含具体的实现。接口提供了一种将类与类之间以及类与接口之间进行关联的机制，支持多继承和规范化的设计。</p><p>以下是Java接口的主要特点和用法：</p><ol><li><p><strong>定义接口：</strong> 使用 <code>interface</code> 关键字来声明接口。接口中的方法<strong>默认是抽象的，不包含方法体</strong>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>实现接口：</strong> 通过 <code>implements</code> 关键字，<strong>一个类可以实现一个或多个接口</strong>。<strong>实现接口的类必须提供接口中所有抽象方法的具体实现</strong>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing MyInterface&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>多继承：</strong> 一个类可以实现多个接口，从而达到<strong>多继承</strong>的效果。这是Java中实现多继承的一种方式。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceB</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span>, InterfaceB &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing InterfaceA&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing InterfaceB&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>接口的默认方法和静态方法：</strong> Java 8 引入了接口的默认方法和静态方法，使得接口可以包含具体的方法实现。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Default method in interface&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static method in interface&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在实现类中，<strong>可以选择性地重写抽象方法</strong>，并可以直接使用默认方法和静态方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing MyInterface&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 不重写 defaultMethod，使用默认实现</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        myObject.myMethod();<br>        myObject.defaultMethod();<br>        MyInterface.staticMethod();<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>接口的继承：</strong> 一个接口可以继承另一个接口，通过 <strong><code>extends</code></strong> 关键字。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在Java中，枚举（Enum）是一种特殊的数据类型，用于定义包含固定常量值的有限集合。枚举类型在Java中是一种引用数据类型，它可以包含字段、方法和构造方法。</p><p>以下是Java中枚举的基本用法和特点：</p><ol><li><p><strong>定义枚举：</strong> 使用 <code>enum</code> 关键字来定义枚举类型。枚举中的每个值都是枚举类型的一个实例。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY<br>&#125;<br></code></pre></td></tr></table></figure><p> 在上面的例子中，<code>Day</code> 枚举包含七个实例，分别代表星期的每一天。</p></li><li><p><strong>枚举常量：</strong> 枚举的每个值被称为枚举常量。在上面的例子中，<code>SUNDAY</code>、<code>MONDAY</code> 等就是枚举常量。</p></li><li><p><strong>访问枚举常量：</strong> 枚举常量可以通过枚举类型的名称访问。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> Day.MONDAY;<br></code></pre></td></tr></table></figure></li><li><p><strong>枚举可以有字段、方法和构造方法：</strong> 与普通类一样，枚举可以包含字段、方法和构造方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    SUNDAY(<span class="hljs-string">&quot;Sun&quot;</span>), MONDAY(<span class="hljs-string">&quot;Mon&quot;</span>), TUESDAY(<span class="hljs-string">&quot;Tue&quot;</span>), WEDNESDAY(<span class="hljs-string">&quot;Wed&quot;</span>),<br>    THURSDAY(<span class="hljs-string">&quot;Thu&quot;</span>), FRIDAY(<span class="hljs-string">&quot;Fri&quot;</span>), SATURDAY(<span class="hljs-string">&quot;Sat&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String abbreviation;<br><br>    Day(String abbreviation) &#123;<br>        <span class="hljs-built_in">this</span>.abbreviation = abbreviation;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAbbreviation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> abbreviation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在这个例子中，<code>Day</code> 枚举包含了一个字段 <code>abbreviation</code>，一个构造方法和一个获取缩写的方法。</p></li><li><p><strong>枚举的比较：</strong> 枚举常量之间可以使用 <code>==</code> 运算符进行比较。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">day1</span> <span class="hljs-operator">=</span> Day.MONDAY;<br><span class="hljs-type">Day</span> <span class="hljs-variable">day2</span> <span class="hljs-operator">=</span> Day.MONDAY;<br><br><span class="hljs-keyword">if</span> (day1 == day2) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Both are the same day&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>switch语句和枚举：</strong> 枚举类型特别适合在 <code>switch</code> 语句中使用，因为它可以列举所有可能的情况。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> Day.MONDAY;<br><br><span class="hljs-keyword">switch</span> (day) &#123;<br>    <span class="hljs-keyword">case</span> MONDAY:<br>        System.out.println(<span class="hljs-string">&quot;It&#x27;s Monday&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TUESDAY:<br>        System.out.println(<span class="hljs-string">&quot;It&#x27;s Tuesday&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// 其他情况...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型（Generics）是Java语言中的一个重要特性，它允许<strong>在类、接口和方法的定义中使用一个或多个类型参数</strong>，以实现代码的重用和类型安全性。</p><p>通过使用泛型，可以编写通用的代码，可以在不指定具体类型的情况下定义类、接口或方法。这使得代码可以<strong>适用于不同类型的数据</strong>，提高了代码的灵活性和可重用性。</p><p>泛型的主要目的是在<strong>编译时执行类型检查，以避免在运行时出现类型转换错误</strong>。它提供了类型安全性，可以在编译时捕获和修复类型错误，而不是在运行时抛出异常。</p><p>使用泛型的常见场景包括：</p><ol><li><p><strong>泛型类（Generic Class）</strong>：定义一个类时，可以使用泛型来表示其中的一个或多个类型参数。例如，<code>ArrayList&lt;T&gt;</code> 是一个泛型类，可以在创建对象时指定具体的类型参数，如 <code>ArrayList&lt;String&gt;</code>。</p></li><li><p><strong>泛型接口（Generic Interface）</strong>：类似于泛型类，泛型接口允许在接口中使用类型参数。例如，<code>List&lt;T&gt;</code> 是一个泛型接口，可以在实现接口时指定具体的类型参数。</p></li><li><p><strong>泛型方法（Generic Method）</strong>：在方法的定义中使用泛型类型参数。这允许方法在调用时接受不同类型的参数，并且可以在方法内部使用泛型类型进行操作。例如，<code>&lt;T&gt; T getFirst(List&lt;T&gt; list)</code> 是一个泛型方法，可以返回列表中的第一个元素，并且可以适用于不同类型的列表。</p></li></ol><p>泛型的好处包括：</p><ol><li><p><strong>类型安全性</strong>：泛型提供了编译时的类型检查，可以在编译时捕获类型错误，避免在运行时出现类型转换错误。</p></li><li><p><strong>代码重用</strong>：通过使用泛型，可以编写通用的代码，可以适用于不同类型的数据，提高了代码的灵活性和可重用性。</p></li><li><p><strong>代码简洁性</strong>：使用泛型可以减少手动的类型转换代码，使代码更加简洁和易读。</p></li></ol><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>一个包内的类可以互相访问，即它们之间的访问级别是包级别（默认级别）。在Java中，默认情况下，如果没有明确指定访问修饰符，类、方法和变量的访问级别就是包级别。</p><p>这意味着同一包内的类可以相互访问彼此的包级别成员。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 com.example.myapp 包中的 MyClass.java 文件</span><br><span class="hljs-keyword">package</span> com.example.myapp;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 包级别的成员变量</span><br>    <span class="hljs-type">int</span> packageLevelVariable;<br><br>    <span class="hljs-comment">// 包级别的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">packageLevelMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 可以访问同一包内的其他类的包级别成员</span><br>        <span class="hljs-type">AnotherClass</span> <span class="hljs-variable">anotherClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnotherClass</span>();<br>        anotherClass.anotherClassMethod();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 com.example.myapp 包中的 AnotherClass.java 文件</span><br><span class="hljs-keyword">package</span> com.example.myapp;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-comment">// 包级别的成员变量</span><br>    <span class="hljs-type">int</span> anotherClassVariable;<br><br>    <span class="hljs-comment">// 包级别的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">anotherClassMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 可以访问同一包内的其他类的包级别成员</span><br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        System.out.println(myClass.packageLevelVariable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>MyClass</code>和<code>AnotherClass</code>都位于<code>com.example.myapp</code>包内，因此它们可以访问对方的包级别成员。</p><h2 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h2><p>Java提供了丰富的数据结构和集合类库，这些类库位于<code>java.util</code>包下。以下是Java中一些常用的数据结构和集合：</p><ol><li><p><strong>ArrayList：</strong> 动态数组，可以根据需要动态增长或缩小的数组。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>LinkedList：</strong> 双向链表，支持快速的插入和删除操作。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br>LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>linkedList.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>HashMap：</strong> 键值对的散列表实现，提供快速的查找和插入。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><br>HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>HashSet：</strong> 基于HashMap的集合，不允许重复元素。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><br>HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>set.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>TreeMap：</strong> 基于红黑树的有序映射，按照键的自然顺序或自定义顺序排序。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br>TreeMap&lt;String, Integer&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>treeMap.put(<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">1</span>);<br>treeMap.put(<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>TreeSet：</strong> 基于TreeMap的有序集合，不允许重复元素。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br>TreeSet&lt;String&gt; treeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>treeSet.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>treeSet.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>Queue接口和LinkedList：</strong> 队列的实现，通常用于先进先出（FIFO）的场景。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>queue.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>Stack：</strong> 栈的实现，通常用于后进先出（LIFO）的场景。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br>Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>stack.push(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>stack.push(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>PriorityQueue：</strong> 优先队列，基于堆实现，可以按照元素的优先级进行排序。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br>PriorityQueue&lt;Integer&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>priorityQueue.add(<span class="hljs-number">3</span>);<br>priorityQueue.add(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p>Java集合框架提供了一套强大且灵活的数据结构和算法，用于存储、检索、操作和处理集合数据。这个框架包含了一系列的接口、实现类和算法，主要位于<code>java.util</code>包中。以下是Java集合框架的主要部分：</p><ul><li><strong>接口（Interfaces）：</strong></li></ul><ol><li><strong>Collection接口：</strong> 是集合框架的根接口，表示<strong>一组对象的集合</strong>。<code>List</code>、<code>Set</code> 和 <code>Queue</code> 都继承自 <code>Collection</code> 接口。</li></ol><ul><li><code>List</code>：有序的集合，允许重复元素。常用实现类有 <code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>。<ul><li><code>Set</code>：不允许重复元素的集合。常用实现类有 <code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code>。</li><li><code>Queue</code>：代表一组元素的队列，通常用于实现先进先出（FIFO）的数据结构。常用实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。</li></ul></li></ul><ol start="2"><li><strong>Map接口：</strong> 表示<strong>键值对的集合</strong>，每个键都映射到一个值。常用实现类有 <code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>。</li></ol><ul><li><strong>实现类（Classes）：</strong></li></ul><ol><li><p><strong>List接口的实现类：</strong></p><ul><li><code>ArrayList</code>：动态数组实现，支持随机访问，适用于快速查找和遍历。</li><li><code>LinkedList</code>：双向链表实现，支持快速插入和删除，适用于频繁操作集合元素的场景。</li><li><code>Vector</code>：类似于 <code>ArrayList</code>，但是是线程安全的。</li></ul></li><li><p><strong>Set接口的实现类：</strong></p><ul><li><code>HashSet</code>：基于哈希表实现，不保证顺序。</li><li><code>LinkedHashSet</code>：基于哈希表和链表实现，按照元素插入顺序保证顺序。</li><li><code>TreeSet</code>：基于红黑树实现，按照元素的自然顺序或自定义顺序排序。</li></ul></li><li><p><strong>Queue接口的实现类：</strong></p><ul><li><code>LinkedList</code>：实现了 <code>Queue</code> 接口，可用于实现队列。</li></ul></li><li><p><strong>Map接口的实现类：</strong></p><ul><li><code>HashMap</code>：基于哈希表实现，键值对无序。</li><li><code>LinkedHashMap</code>：基于哈希表和链表实现，按照键值对插入顺序保证顺序。</li><li><code>TreeMap</code>：基于红黑树实现，按照键的自然顺序或自定义顺序排序。</li></ul></li><li><p><strong>其他常用类：</strong></p><ul><li><code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code> 等都实现了 <code>Set</code> 接口。</li><li><code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code> 等都实现了 <code>Map</code> 接口。</li></ul></li></ol><ul><li><p><strong>工具类（Utilities）：</strong></p><ul><li><strong>Collections类：</strong> 提供了一系列静态方法，用于对集合进行操作和算法处理，如排序、反转、洗牌等。</li><li><strong>Arrays类：</strong> 提供了一系列静态方法，用于操作数组，如排序、二分查找等。</li></ul></li><li><p><strong>并发集合（Concurrent Collections）：</strong></p><ul><li><code>ConcurrentHashMap</code>：线程安全的哈希表实现。</li><li><code>CopyOnWriteArrayList</code>：线程安全的动态数组实现，适用于读多写少的场景。</li><li><code>CopyOnWriteArraySet</code>：线程安全的集合，基于 <code>CopyOnWriteArrayList</code> 实现。</li></ul></li></ul><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><p>在Java中，线程相关的操作和指令主要涉及到以下方面：</p><ol><li><p><strong>创建线程：</strong></p><ul><li><p>使用 <code>Thread</code> 类或实现 <code>Runnable</code> 接口创建线程。</p></li><li><p>例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>线程调度和控制：</strong></p><ul><li><code>Thread.sleep(long millis)</code>：使当前线程休眠指定的毫秒数。</li><li><code>Thread.yield()</code>：暂停当前正在执行的线程，允许其他线程执行。</li><li><code>join()</code>：等待一个线程终止。</li><li><code>interrupt()</code>：中断线程的执行。</li></ul></li><li><p><strong>同步和互斥：</strong></p><ul><li><code>synchronized</code> 关键字：用于同步代码块或方法，确保在同一时刻只有一个线程可以访问。</li><li><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>：在对象上进行等待和唤醒其他线程的操作，通常与<code>synchronized</code>一起使用。</li></ul></li><li><p><strong>线程状态控制：</strong></p><ul><li><code>getState()</code>：获取线程的状态。</li><li><code>isAlive()</code>：判断线程是否处于活动状态。</li></ul></li><li><p><strong>并发集合和工具类：</strong></p></li></ol><ul><li><code>java.util.concurrent</code> 包提供了一些并发集合和工具类，如 <code>ConcurrentHashMap</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code> 等，用于更方便地进行多线程编程。</li></ul><ol start="6"><li><strong>线程池：</strong></li></ol><ul><li><code>ExecutorService</code> 和 <code>ThreadPoolExecutor</code> 等类用于管理线程池，提高线程的复用性和效率。</li></ul><ol start="7"><li><strong>原子操作和CAS（Compare and Swap）：</strong></li></ol><ul><li><code>java.util.concurrent.atomic</code> 包提供了一系列原子操作类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等，用于在多线程环境中执行原子操作。</li></ul><ol start="8"><li><p><strong>并行流：</strong></p><ul><li>Java 8 引入的并行流框架允许在多个线程上同时处理流的元素。</li></ul></li></ol><p>这些指令和类库提供了Java中进行多线程编程的基本工具和机制。在编写多线程代码时，要注意线程安全性、死锁和性能等问题，以确保程序的正确性和效率。</p><p>这几个方法的具体用法如下：</p><ol><li><p><strong>Thread.sleep(long millis)：</strong></p><ul><li><p>使当前线程休眠指定的毫秒数，进入阻塞状态。</p></li><li><p>用法示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 休眠1秒</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Thread.yield()：</strong></p><ul><li><p>暂停当前正在执行的线程，允许其他线程执行。</p></li><li><p><code>yield</code> 是一个静态方法，通过调用 <code>Thread.yield()</code> 可以提示调度器当前线程愿意让出CPU资源。</p></li><li><p>用法示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// 暂停当前线程，让出CPU资源</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>join()：</strong></p><ul><li><p>等待一个线程终止，即等待被调用 <code>join</code> 方法的线程执行完毕。</p></li><li><p>用法示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 线程执行的逻辑</span><br>&#125;);<br>thread.start();<br><span class="hljs-keyword">try</span> &#123;<br>    thread.join(); <span class="hljs-comment">// 主线程等待 thread 线程执行完毕</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>interrupt()：</strong></p><ul><li><p>中断线程的执行，给线程发送中断信号。</p></li><li><p>被中断的线程需要通过检查 <code>Thread.interrupted()</code> 或 <code>isInterrupted()</code> 方法来判断是否被中断，并做相应处理。</p></li><li><p>用法示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>        <span class="hljs-comment">// 线程执行的逻辑</span><br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;线程被中断&quot;</span>);<br>&#125;);<br>myThread.start();<br><br><span class="hljs-comment">// 在其他地方中断线程</span><br>myThread.interrupt();<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>一些关键字和方法主要用于实现线程之间的协调和同步，确保多个线程能够安全地共享资源。以下是它们的具体用法：</p><ol><li><p><strong>synchronized 关键字：</strong></p><ul><li><p>用于同步代码块或方法，确保在同一时刻只有一个线程可以访问被 synchronized 修饰的代码块或方法。</p></li><li><p>对象级别的同步：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步的代码块或方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>代码块级别的同步：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>        <span class="hljs-comment">// 同步的代码块</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>wait()、notify()、notifyAll()：</strong></p><ul><li><p>这些方法通常与 synchronized 一起使用，用于实现线程之间的协调和通信。</p></li><li><p><code>wait()</code>：使当前线程进入等待状态，并释放对象锁，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lockObject.wait(); <span class="hljs-comment">// 等待其他线程唤醒</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>notify()</code>：唤醒在相同对象上等待的一个线程。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    lockObject.notify(); <span class="hljs-comment">// 唤醒一个等待线程</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>notifyAll()</code>：唤醒在相同对象上等待的所有线程。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    lockObject.notifyAll(); <span class="hljs-comment">// 唤醒所有等待线程</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>这些机制可以帮助线程之间进行协同工作，避免竞争条件和确保资源的正确共享。需要注意的是，使用 wait()、notify()、notifyAll() 时，必须在同步块或同步方法中调用，否则会抛出 <code>IllegalMonitorStateException</code> 异常。</p><h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I&#x2F;O"></a>Java I&#x2F;O</h2><p>在Java中，流（Stream）是用于处理输入和输出（I&#x2F;O）操作的重要概念。流主要分为输入流和输出流，它们分别用于从外部数据源读取数据和将数据写入到外部目标。</p><p>以下是Java流的一些关键概念和总结：</p><ol><li><p><strong>输入流和输出流：</strong></p><ul><li><strong>输入流（InputStream）：</strong> 用于从外部数据源（例如文件、网络、内存等）读取数据。</li><li><strong>输出流（OutputStream）：</strong> 用于向外部目标（例如文件、网络、内存等）写入数据。</li></ul></li><li><p><strong>字节流和字符流：</strong></p><ul><li><strong>字节流：</strong> 处理字节数据，主要用于处理二进制文件。例如，<code>FileInputStream</code>和<code>FileOutputStream</code>。</li><li><strong>字符流：</strong> 处理字符数据，适用于文本文件。例如，<code>FileReader</code>和<code>FileWriter</code>。字符流使用了字符集，可以更好地处理文本文件中的字符编码。</li></ul></li><li><p><strong>节点流和包装流：</strong></p><ul><li><strong>节点流：</strong> 直接连接到数据源或目标的流。例如，<code>FileInputStream</code>和<code>FileOutputStream</code>。</li><li><strong>包装流（或处理流）：</strong> 对节点流进行包装，提供额外的功能，如缓冲、压缩、解压等。例如，<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>。</li></ul></li><li><p><strong>字符集和编码：</strong></p><ul><li>字符流使用字符集来处理字符编码，以确保正确的字符转换。</li><li>常见的字符集包括UTF-8、UTF-16、ISO-8859-1等。</li></ul></li><li><p><strong>处理流的装饰器模式：</strong></p><ul><li>处理流通常通过装饰器模式实现。你可以通过组合多个处理流，以获得更丰富的功能。</li></ul></li><li><p><strong>对象流：</strong></p><ul><li><code>ObjectInputStream</code>和<code>ObjectOutputStream</code>允许直接读写Java对象。这对于序列化和反序列化对象很有用。</li></ul></li><li><p><strong>标准I&#x2F;O：</strong></p><ul><li><code>System.in</code>、<code>System.out</code>和<code>System.err</code>分别代表标准输入、标准输出和标准错误输出。这些流通常用于从控制台读取输入和输出结果。</li></ul></li><li><p><strong>try-with-resources：</strong></p><ul><li>Java 7引入了<code>try-with-resources</code>语句，使得资源的管理更加简便。可以在<code>try</code>语句中自动关闭实现<code>AutoCloseable</code>接口的资源。</li></ul></li></ol><h2 id="Java错误和异常"><a href="#Java错误和异常" class="headerlink" title="Java错误和异常"></a>Java错误和异常</h2><p>在 Java 中，错误（Errors）和异常（Exceptions）是用于处理程序运行期间出现的问题的机制。它们都是从 <code>Throwable</code> 类派生的，但在处理方式和用途上有所区别。下面是对 Java 错误和异常的总结：</p><ol><li><p><strong>错误（Errors）</strong>：</p><ul><li>错误表示严重的问题，通常是无法恢复的情况，例如虚拟机错误、系统错误、内存溢出等。</li><li>错误由 JVM 抛出，并且一般<strong>不应该被程序捕获和处理</strong>。</li><li><code>Error</code> 类及其子类是用于表示错误的类型，例如 <code>OutOfMemoryError</code>、<code>StackOverflowError</code> 等。</li></ul></li><li><p><strong>异常（Exceptions）</strong>：</p><ul><li>异常是程序在运行过程中遇到的非正常情况，<strong>可以被捕获和处理</strong>，以便程序继续执行。</li><li>异常分为两种类型：<strong>已检查异常</strong>（Checked Exceptions）和<strong>运行时异常</strong>（Unchecked Exceptions）。</li><li>已检查异常是在编译时强制要求处理的异常，例如 <code>IOException</code>、<code>SQLException</code> 等。对于已检查异常，要么在方法中使用 <code>throws</code> 声明抛出，要么使用 <code>try-catch</code> 块进行捕获和处理。</li><li>运行时异常是指那些可以在运行时检测到的异常，不需要在编译时进行处理。例如，<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code> 等。通常情况下，运行时异常是由程序错误导致的，应该尽量避免发生，但并不强制要求捕获和处理。</li></ul></li></ol><p>在处理异常时，可以使用以下几种关键字和机制：</p><ul><li><code>try-catch</code> 块：用于捕获和处理异常。<code>try</code> 块中放置可能抛出异常的代码，而 <code>catch</code> 块用于捕获和处理对应的异常类型。</li><li><code>throws</code> 关键字：用于在方法签名中声明可能抛出的异常类型，将异常传递给调用者处理。</li><li><code>finally</code> 块：在 <code>try-catch</code> 块之后使用，用于执行无论是否发生异常都需要执行的代码块，例如资源的释放。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识</title>
    <link href="/2024/01/28/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/01/28/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Linux"><a href="#初识Linux" class="headerlink" title="初识Linux"></a>初识Linux</h1><p>🍾 基础知识笔记一篇~ 加入联创的第0期新人任务就是安装并使用archlinux~ 🙋‍包括常用文件操作命令、文件权限、进程等知识点</p><span id="more"></span><h2 id="常用文件操作命令"><a href="#常用文件操作命令" class="headerlink" title="常用文件操作命令"></a>常用文件操作命令</h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a><strong>cd</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 目录<br></code></pre></td></tr></table></figure><ul><li>切换用户当前工作目录</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span>    <span class="hljs-comment"># 进入用户主目录；</span><br><span class="hljs-keyword">cd</span> /  <span class="hljs-comment"># 进入根目录</span><br><span class="hljs-keyword">cd</span> ~  <span class="hljs-comment"># 进入用户主目录；</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span>  <span class="hljs-comment"># 返回上级目录（若当前目录为“/“，则执行完后还在“/&quot;；&quot;..&quot;为上级目录的意思）；</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">../..</span>  <span class="hljs-comment"># 返回上两级目录；</span><br></code></pre></td></tr></table></figure><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a><strong>ls</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> 选项 目录<br></code></pre></td></tr></table></figure><ul><li><code>ls</code>就是list的缩写，用来显示目标列表</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a: 显示所有文件，包括隐藏文件</span><br><span class="hljs-deletion">-l: 详细信息显示</span><br><span class="hljs-deletion">-h: 人性化显示，文件大小以B、K、M显示</span><br><span class="hljs-deletion">-i: 显示Linux对于每个文件的id</span><br><span class="hljs-deletion">-t: 按时间信息排序</span><br><span class="hljs-deletion">-d: 显示目录属性</span><br></code></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 组合使用多个命令</span><br>[root<span class="hljs-symbol">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-5</span>-centos redis<span class="hljs-number">-6.2</span><span class="hljs-number">.4</span>]<span class="hljs-meta"># ls -alhit</span><br></code></pre></td></tr></table></figure><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><strong>mkdir</strong></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir 选项 目录<br></code></pre></td></tr></table></figure><ul><li>用来创建目录</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-m: 建立目录的同时设置目录的权限</span><br><span class="hljs-deletion">-p: 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录</span><br></code></pre></td></tr></table></figure><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmdir 选项 目录<br></code></pre></td></tr></table></figure><ul><li>删除空目录</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">p</span>：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；<br></code></pre></td></tr></table></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> 选项 文件<br></code></pre></td></tr></table></figure><ul><li>创建新的空文件</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> 选项 文件<br></code></pre></td></tr></table></figure><ul><li>删除文件或目录</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f：强制删除，没有提示是否确认删除</span><br><span class="hljs-deletion">-r：递归删除，在删除目录时使用</span><br><span class="hljs-deletion">-i：删除已有文件或目录之前先询问用户</span><br></code></pre></td></tr></table></figure><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">cp</span> 选项 原文件或目录 目标文件或目录<br></code></pre></td></tr></table></figure><ul><li>将原文件或目录复制到目标文件或目录中</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-r 递归复制，用于复制目录</span><br><span class="hljs-deletion">-p 保留原有文件属性</span><br></code></pre></td></tr></table></figure><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> 原文件或目录 目标文件或目录<br></code></pre></td></tr></table></figure><ul><li>移动文件或者重命名</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> 选项 文件<br></code></pre></td></tr></table></figure><ul><li>显示文件内容</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-n 显示行号</span><br></code></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">more</span> 文件名<br></code></pre></td></tr></table></figure><ul><li>分页显示文件内容</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">运行命令进入查看页面后，可以进行如下操作：<br><br>空格 或 f：向下翻页<br><span class="hljs-selector-tag">b</span>：向上翻页<br>Enter：换行<br><span class="hljs-selector-tag">q</span>或<span class="hljs-selector-tag">Q</span>：退出<br></code></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> 选项 文件名<br></code></pre></td></tr></table></figure><ul><li>显示文件前几行，默认显示前10行</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-n：指定显示行数</span><br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">find <span class="hljs-selector-attr">[path]</span> <span class="hljs-selector-attr">[expression]</span><br></code></pre></td></tr></table></figure><p><strong>常用的expression:</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">-name pattern：按文件名查找，支持使用通配符 * 和 ?。<br>-<span class="hljs-keyword">type</span> <span class="hljs-keyword">type</span>：按文件类型查找，可以是 f（普通文件）、d（目录）、l（符号链接）等。<br>-size [+-]size[cwbkMG]：按文件大小查找，支持使用 + 或 - 表示大于或小于指定大小，单位可以是 c（字节）、w（字数）、b（块数）、k（KB）、M（MB）或 G（GB）。<br>-mtime days：按修改时间查找，支持使用 + 或 - 表示在指定天数前或后，days 是一个整数表示天数。<br>-<span class="hljs-keyword">user</span> <span class="hljs-title">username</span>：按文件所有者查找。<br>-<span class="hljs-keyword">group</span> <span class="hljs-title">groupname</span>：按文件所属组查找<br></code></pre></td></tr></table></figure><h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li>读取（r）： 允许查看文件内容，显示目录列表</li><li>写入（w）： 允许修改文件内容，允许在目录中新建、删除、移动文件或者子目录</li><li>可执行（x）： 允许运行程序，切换目录</li><li>无权限（-）： 没有权限</li></ul><p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为 <strong>d</strong> 则是目录</li><li>当为 <strong>-</strong> 则是文件；</li><li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li><li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。如果用 <strong>-</strong> 字符表示，则没有执行权限</p><p><img src="/img/linux2.jpg" alt="文件权限"></p><h3 id="文件属主与属组"><a href="#文件属主与属组" class="headerlink" title="文件属主与属组"></a>文件属主与属组</h3><ul><li><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p></li><li><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p></li><li><p>文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。</p></li><li><p>Linux系统按<strong>文件所有者</strong>、<strong>文件所有者同组用户</strong>和<strong>其他用户</strong>来规定了不同的文件访问权限。</p></li></ul><h3 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h3><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><ul><li><strong>更改文件属组</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chgrp</span> [-R] 属组名 文件名<br></code></pre></td></tr></table></figure><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><ul><li><p><strong>change owner 修改所属用户与组</strong></p></li><li><p><strong>更改文件属主，也可以同时更改文件属组</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> [–R] 属主名 文件名<br><span class="hljs-built_in">chown</span> [-R] 属主名：属组名 文件名<br></code></pre></td></tr></table></figure><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><ul><li><p><strong>change mode 修改用户的权限</strong></p></li><li><p><strong>更改文件9个属性</strong></p></li></ul><p>各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [-R] xyz 文件或目录<br></code></pre></td></tr></table></figure><ul><li><strong>xyz</strong> : 就是刚刚提到的数字类型的权限属性，为 <strong>rwx</strong> 属性数值的相加。</li><li><strong>-R</strong> : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更</li></ul><h2 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h2><p>**进程(process)**是指正在执行的程序；是程序正在运行的一个实例。它由程序指令，和从文件、其它程序中读取的数据或系统用户的输入组成</p><h3 id="进程的类型"><a href="#进程的类型" class="headerlink" title="进程的类型"></a>进程的类型</h3><ul><li><strong>前台进程</strong>（也称为<strong>交互式进程</strong>） - 这些进程由终端会话初始化和控制。换句话说，需要有一个连接到系统中的用户来启动这样的进程；它们不是作为系统功能&#x2F;服务的一部分自动启动。</li><li><strong>后台进程</strong>（也称为<strong>非交互式&#x2F;自动进程</strong>） - 这些进程没有连接到终端；它们不需要任何用户输入。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局 | CSS</title>
    <link href="/2024/01/28/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2024/01/28/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="flex布局-全面且简洁"><a href="#flex布局-全面且简洁" class="headerlink" title="flex布局 | 全面且简洁"></a>flex布局 | 全面且简洁</h2><p>💡常用但常忘的知识点 🤔 小小总结一下吧</p><span id="more"></span><h3 id="flex模型说明"><a href="#flex模型说明" class="headerlink" title="flex模型说明"></a>flex模型说明</h3><p><img src="/img/flex_terms.png" alt="flex模型说明"></p><ul><li><strong>主轴</strong>（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li><li><strong>交叉轴</strong>（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li><li>设置了 <code>display: flex</code> 的<strong>父元素</strong>被称之为 <strong>flex 容器（flex container）。</strong></li><li>在 flex 容器中表现为弹性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）</li></ul><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><strong>规定主轴(<code>main axis</code>)的方向</strong></p><ul><li><code>row</code></li><li><code>row-reverse</code></li><li><code>column</code></li><li><code>column-reverse</code></li></ul><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>flex-wrap是CSS中用于<strong>控制Flex容器中的子元素如何换行</strong>的属性。它决定了当子元素在主轴方向上无法一行容纳时是否换行，并且指定了换行的方式。</p><ul><li><p><strong><code>nowrap</code>（默认值）</strong>：子元素不换行，尽量在一行容纳所有子元素。如果子元素的总宽度超过了容器的宽度，子元素可能会被缩小以适应容器。</p></li><li><p><strong><code>wrap</code><strong>：子元素允许换行，当子元素在主轴方向上无法一行容纳时，会</strong>换行显示</strong>。换行后的子元素将会从新的行开始排列。</p></li><li><p>**<code>wrap-reverse</code>**：子元素允许换行，与wrap相似，但换行后的子元素的排列顺序将会反转。</p></li></ul><h3 id="flew-flow"><a href="#flew-flow" class="headerlink" title="flew-flow"></a>flew-flow</h3><p><code>flex-direction</code>和<code>flex-wrap</code>的缩写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row;<br><span class="hljs-attribute">flex-wrap</span>: wrap;<br>//等价于<br><span class="hljs-attribute">flex-flow</span>: row wrap;<br></code></pre></td></tr></table></figure><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>用于指定子元素<strong>在可用空间增加时的扩展比例</strong>。它的值为一个非负整数，默认为 0。</p><ul><li>如果所有的子元素的 flex-grow 值都为 0，它们将不会扩展，宽度将根据它们的内容或固定宽度来确定。</li><li>如果一个子元素的 flex-grow 值大于 0，而其他子元素的值为 0，那么这个子元素将占据剩余的可用空间，其占据空间的比例为 flex-grow 值与其他子元素的和的比例。</li></ul><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>用于指定子元素<strong>在空间不足时的缩小比例</strong>。它的值为一个非负整数，默认为 1。</p><ul><li>如果所有的子元素的 flex-shrink 值都为 1，它们将按比例缩小，以适应容器的可用空间。</li><li>如果一个子元素的 flex-shrink 值为 0，而其他子元素的值为 1，当空间不足时，其他子元素将缩小，而这个子元素将保持其原始大小</li></ul><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>用于指定<strong>子元素在主轴上的初始大小</strong>。它的值可以是一个<strong>长度值（如像素、百分比等）</strong>，或者<strong>关键字 auto</strong>。</p><ul><li>如果设置为一个长度值（如 flex-basis: 100px;），子元素将具有固定的初始大小。</li><li>如果设置为关键字 auto（如 flex-basis: auto;），子元素的大小将根据其内容或固有大小来确定。</li></ul><h3 id="动态尺寸"><a href="#动态尺寸" class="headerlink" title="动态尺寸"></a>动态尺寸</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br>这表示“每个 <span class="hljs-attribute">flex</span> 项将首先给出 <span class="hljs-number">200px</span> 的可用空间，然后，剩余的可用空间将根据分配的比例共享”。<br></code></pre></td></tr></table></figure><h3 id="属性缩写"><a href="#属性缩写" class="headerlink" title="属性缩写"></a>属性缩写</h3><p>当使用flex属性的缩写形式时，可以指定最多三个不同值：<code>flex-grow</code>、<code>flex-shrink</code>和<code>flex-basis</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.flex-item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="水平和垂直对齐"><a href="#水平和垂直对齐" class="headerlink" title="水平和垂直对齐"></a>水平和垂直对齐</h3><ul><li><p><strong><code>align-items</code></strong> 控制flex项在交叉轴 <code>cross axis</code>上的位置</p><ul><li>默认值是<code>stretch</code></li><li><code>center</code>居中常用</li><li><code>flex-start``flex-end</code>设置对齐开始结束</li><li><code>align-self</code>某个元素覆盖<code>align-items</code></li></ul></li><li><p><strong><code>justify-content</code></strong> 控制flex项在主轴 <code>main axis</code>上的位置</p><ul><li><code>flex-start</code> <code>flex-end</code></li><li><code>center</code></li><li><code>space-around</code>   沿着主轴均匀分布，任意一端留有空间</li><li><code>space-between</code>   沿着主轴均匀分布，两端不会留有空间</li></ul></li></ul><h3 id="flex排序"><a href="#flex排序" class="headerlink" title="flex排序"></a>flex排序</h3><ul><li>flex的默认<code>order</code>是0</li><li><code>order</code>值大的显示顺序更靠后</li><li>可设置负值排在前面</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础知识</title>
    <link href="/2024/01/28/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/01/28/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>笔记详尽版 👊 是2023夏天在by夏令营做的笔记… 原谅是初学者不太清楚的都想cv，内容很多…也是可以凑合当个复习基础知识的小百科全书惹</p><span id="more"></span><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>应用程序接口（Application Programming Interfaces</strong>（<strong>API</strong>）</p><h3 id="浏览器-API"><a href="#浏览器-API" class="headerlink" title="浏览器 API"></a>浏览器 API</h3><p>内建于 web 浏览器中，它们可以将数据从周边计算机环境中筛选出来，还可以做实用的复杂工作。例如：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model"><code>文档对象模型 API（DOM（Document Object Model）API）</code></a> 能通过创建、移除和修改 HTML，为页面动态应用新样式等手段来操作 HTML 和 CSS。比如当某个页面出现了一个弹窗，或者显示了一些新内容（像上文小 demo 中看到那样），这就是 DOM 在运行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation"><code>地理位置 API（Geolocation API）</code></a> 获取地理信息。这就是为什么 <a href="https://www.google.cn/maps">谷歌地图</a> 可以找到你的位置，而且标示在地图上。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API"><code>画布（Canvas）</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API"><code>WebGL</code></a> API 可以创建生动的 2D 和 3D 图像。人们正运用这些 web 技术制作令人惊叹的作品。参见 <a href="https://www.chromeexperiments.com/webgl">Chrome Experiments</a> 以及 <a href="https://webglsamples.org/">webglsamples</a>。</li><li>诸如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API"><code>WebRTC</code></a> 等 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Audio_and_video_delivery">影音类 API</a> 让你可以利用多媒体做一些非常有趣的事，比如在网页中直接播放音乐和影片，或用自己的网络摄像头获取录像，然后在其他人的电脑上展示（试用简易版 <a href="http://chrisdavidmills.github.io/snapshot/">截图 demo</a> 以理解这个概念）。</li></ul><h3 id="第三方-API"><a href="#第三方-API" class="headerlink" title="第三方 API"></a>第三方 API</h3><p>并没有默认嵌入浏览器中，一般要从网上取得它们的代码和信息。比如：</p><ul><li><a href="https://dev.twitter.com/overview/documentation">Twitter API</a>、<a href="https://open.weibo.com/">新浪微博 API</a> 可以在网站上展示最新推文之类。</li><li><a href="https://developers.google.com/maps/">谷歌地图 API</a>、<a href="https://lbs.amap.com/">高德地图 API</a> 可以在网站嵌入定制的地图等等</li></ul><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="解释代码-vs-编译代码"><a href="#解释代码-vs-编译代码" class="headerlink" title="解释代码 vs 编译代码"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript#%E8%A7%A3%E9%87%8A%E4%BB%A3%E7%A0%81_vs_%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81">解释代码 vs 编译代码</a></h3><p>作为程序员，你或许听说过这两个术语：<strong>解释</strong>（interpret）和 <strong>编译</strong>（compile）。在解释型语言中，代码自上而下运行，且实时返回运行结果。代码在由浏览器执行前，不需要将其转化为其他形式。代码将直接以文本格式（text form）被接收和处理。</p><p>相对的，编译型语言需要先将代码转化（编译）成另一种形式才能运行。比如 C&#x2F;C++ 先被编译成汇编语言，然后才能由计算机运行。程序将以二进制的格式运行，这些二进制内容是由程序源代码产生的。</p><p>JavaScript 是轻量级解释型语言。浏览器接受到 JavaScript 代码，并以代码自身的文本格式运行它。技术上，几乎所有 JavaScript 转换器都运用了一种叫做即时编译（just-in-time compiling）的技术；当 JavaScript 源代码被执行时，它会被编译成二进制的格式，使代码运行速度更快。尽管如此，JavaScript 仍然是一门解释型语言，因为编译过程发生在代码运行中，而非之前。</p><p>两种类型的语言各有优势，这个问题我们暂且不谈。</p><h3 id="服务器端代码-vs-客户端代码"><a href="#服务器端代码-vs-客户端代码" class="headerlink" title="服务器端代码 vs 客户端代码"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81_vs_%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81">服务器端代码 vs 客户端代码</a></h3><p>你或许还听说过<strong>服务器端（server-side）</strong>和 **客户端（client-side）**代码这两个术语，尤其是在 web 开发时。客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。这就是**客户端 JavaScript**。</p><p>而服务器端代码在服务器上运行，接着运行结果才由浏览器下载并展示出来。流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！JavaScript 也可用作服务器端语言，比如现在流行的 Node.js 环境，你可以在我们的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side">动态网页 - 服务器端编程</a> 主题中找到更多关于服务器端 JavaScript 的知识。</p><h3 id="动态代码-vs-静态代码"><a href="#动态代码-vs-静态代码" class="headerlink" title="动态代码 vs 静态代码"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81_vs_%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81">动态代码 vs 静态代码</a></h3><p>“<strong>动态</strong>”一词既适用于客户端 JavaScript，又适用于描述服务器端语言。是指通过按需生成新内容来更新 web 页面 &#x2F; 应用，使得不同环境下显示不同内容。服务器端代码会在服务器上动态生成新内容，例如从数据库中提取信息。而客户端 JavaScript 则在用户端浏览器中动态生成新内容，比如说创建一个新的 HTML 表格，用从服务器请求到的数据填充，然后在网页中向用户展示这个表格。两种情况的意义略有不同，但又有所关联，且两者（服务器端和客户端）经常协同作战。</p><p>没有动态更新内容的网页叫做“<strong>静态</strong>”页面<strong>，</strong>所显示的内容不会改变。</p><h2 id="脚本调用策略"><a href="#脚本调用策略" class="headerlink" title="脚本调用策略"></a>脚本调用策略</h2><h3 id="内部脚本"><a href="#内部脚本" class="headerlink" title="内部脚本"></a>内部脚本</h3><p>“内部”示例使用了以下结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  . . .<br>&#125;);<br></code></pre></td></tr></table></figure><p>这是一个事件监听器，它监听浏览器的 “<code>DOMContentLoaded</code>“ 事件，即 HTML 文档体加载、解释完毕事件。事件触发时将调用 “ <code>. . .</code>“ 处的代码，从而避免了错误发生（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">事件</a> 的概念稍后学习）。</p><h3 id="外部脚本"><a href="#外部脚本" class="headerlink" title="外部脚本"></a>外部脚本</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>“外部”示例中使用了 JavaScript 的一项现代技术（<code>async</code> “异步”属性）来解决这一问题，它告知浏览器在遇到 <code>&lt;script&gt;</code> 元素时不要中断后续 HTML 内容的加载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述情况下，脚本和 HTML 将一并加载，代码将顺利运行。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加 <code>defer</code> 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 <code>jquery.js</code> 必定加载于 <code>script2.js</code> 和 <code>script3.js</code> 之前，同时 <code>script2.js</code> 必定加载于 <code>script3.js</code> 之前。</p><p><strong>脚本调用策略小结：</strong></p><ul><li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li><li>如果脚本需要等待页面解析，且依赖于其他脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li></ul><h2 id="一、Javascript基础要件"><a href="#一、Javascript基础要件" class="headerlink" title="一、Javascript基础要件"></a>一、Javascript基础要件</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>String</p></li><li><p>Number</p></li><li><p>Boolean</p></li><li><p>Array</p></li><li><p>Object</p><p>  对象：JavaScript 里一切皆对象，一切皆可储存在变量里。这一点要牢记于心</p></li></ul><h4 id="var和let"><a href="#var和let" class="headerlink" title="var和let"></a>var和let</h4><p>如果你编写一个声明并初始化变量的多行 JavaScript 程序，你可以在初始化一个变量之后用 <code>var</code> 声明它，它仍然可以工作。</p><p>其次，当你使用 <code>var</code> 时，可以根据需要多次声明相同名称的变量，但是 <code>let</code> 不能。</p><p>出于这些以及其他原因，我们建议您在代码中尽可能多地使用 <code>let</code>，而不是 <code>var</code>.</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="和"><a href="#和" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;</strong></h4><p>在 JavaScript 中，<code>==</code> 和 <code>===</code> 都是用于比较两个值的操作符，但它们之间有一些重要的区别。</p><ol><li><p><code>==</code>（相等运算符）：它用于比较两个值是否相等，但在进行比较之前会进行类型转换。</p><ul><li>如果比较的两个值类型不同，JavaScript 会尝试将它们转换为相同的类型，然后再进行比较。</li><li>如果比较的两个值都是字符串、数字、布尔值或 null，则会执行常规的相等性检查。</li><li>如果一个值是 <code>undefined</code> 或 <code>null</code>，而另一个值是 <code>null</code> 或 <code>undefined</code>，则它们被视为相等。</li><li>如果比较的两个值都是对象，则比较它们的引用，只有在引用指向同一个对象时才被认为是相等的。</li></ul><p> 以下是一些示例：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">javascriptCopy code5 == <span class="hljs-number">5</span>    <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;5&#x27;</span> == <span class="hljs-number">5</span>  <span class="hljs-comment">// true (进行类型转换后，字符串 &#x27;5&#x27; 变成了数字 5)</span><br><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>  <span class="hljs-comment">// true</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]   <span class="hljs-comment">// false (两个数组的引用不同)</span><br></code></pre></td></tr></table></figure></li><li><p><code>===</code>（严格相等运算符）：它用于比较两个值是否完全相等，包括类型和值。</p><ul><li>如果比较的两个值类型不同，它们被视为不相等。</li><li>如果比较的两个值都是字符串、数字、布尔值、null 或 undefined，它们必须具有相同的类型和相同的值才被视为相等。</li><li>如果比较的两个值都是对象或数组，它们必须引用同一个对象才被视为相等。</li></ul><p> 以下是一些示例：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">javascriptCopy code5 === <span class="hljs-number">5</span>    <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;5&#x27;</span> === <span class="hljs-number">5</span>  <span class="hljs-comment">// false (类型不同)</span><br><span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>  <span class="hljs-comment">// false (类型不同)</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] === [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]   <span class="hljs-comment">// false (两个数组的引用不同)</span><br></code></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li><code>==</code> 运算符在比较之前进行类型转换，可以在某些情况下自动转换类型。</li><li><code>===</code> 运算符进行严格的类型和值比较，要求类型和值都完全相等。</li></ul><p>通常建议使用 <code>===</code> 运算符，因为它可以避免因类型转换而导致的意外结果。只有在特定的情况下，比如明确需要进行类型转换时，才使用 <code>==</code> 运算符。</p><h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="+运算符"></a>+运算符</h4><p>你也可以使用 <code>+</code> 运算符将文本字符串连接在一起（术语“串联”（<em>concatenation</em>））。尝试依次输入以下几行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Bingo&#x27;</span>;<br>name;<br><span class="hljs-keyword">const</span> hello = <span class="hljs-string">&#x27; says hello!&#x27;</span>;<br>hello;<br><span class="hljs-keyword">const</span> greeting = name + hello;<br>greeting;<br></code></pre></td></tr></table></figure><table><thead><tr><th><code>**</code></th><th>幂</th><th>取底数的指数次方，即指数所指定的底数相乘。它在 EcmaScript 2016 中首次引入。</th><th><code>5 ** 5</code> (返回 3125，相当于 <code>5 * 5 * 5 * 5 * 5</code> 。)</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h3><h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">displayMessage</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>匿名函数是一种在编程中没有名称标识符的函数。它是一种可以被定义和使用，但没有特定名称的函数。</p><p>在 JavaScript 中，匿名函数可以使用函数表达式或箭头函数语法来创建。</p><ol><li>函数表达式的匿名函数：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myFunction = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码中，<code>myFunction</code> 是一个变量，它引用了一个匿名函数。你可以通过调用 <code>myFunction()</code> 来执行这个函数。</p><ol><li>箭头函数的匿名函数：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myFunction</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码中，<code>myFunction</code> 是一个变量，它引用了一个箭头函数的匿名函数。同样，你可以通过调用 <code>myFunction()</code> 来执行这个函数。</p><p>匿名函数在许多情况下非常有用，特别是当你只需要定义一个函数来作为其他函数的参数或临时执行某些操作时。你可以直接将匿名函数传递给其他函数，或在需要时立即执行它。</p><p>以下是一个示例，展示了如何使用匿名函数作为参数传递给 <code>setTimeout</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个匿名函数作为 <code>setTimeout</code> 函数的第一个参数，它将在延迟 1000 毫秒后执行。</p><p>匿名函数的好处之一是可以避免污染全局命名空间，因为它们没有特定的名称。它们可以在需要的地方定义和使用，而无需考虑名称冲突的问题。</p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p><code>() =&gt;</code> 是 JavaScript 中的箭头函数（Arrow Function）的语法表示。</p><p>箭头函数是在 ES6（ECMAScript 2015）中引入的一种新的函数定义方式，它提供了更简洁的语法形式和改变了函数内部的 <code>this</code> 绑定规则。</p><p>箭头函数的基本语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数可以没有参数，或者带有一个或多个参数。当只有一个参数时，可以省略参数的括号。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">x =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br><br><span class="hljs-comment">// 或</span><br><br>(x, y) =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数的主要优点是它们的简洁性和对 <code>this</code> 关键字的处理方式。在箭头函数内部，<code>this</code> 的值会继承自外部作用域，而不是在函数被调用时绑定新的值。</p><p>以下是箭头函数的一些示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 没有参数的箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;;<br><span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出: Hello!</span><br><br><span class="hljs-comment">// 带有参数的箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> a * b;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiply</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出: 6</span><br><br><span class="hljs-comment">// 箭头函数的简写形式（隐式返回）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">square</span> = x =&gt; x * x;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">square</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出: 16</span><br></code></pre></td></tr></table></figure><p>需要注意的是，箭头函数没有自己的 <code>this</code> 值，它会继承外部作用域的 <code>this</code> 值。这意味着箭头函数不适用于需要动态绑定 <code>this</code> 的场景，例如作为对象方法或构造函数。</p><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>btn.<span class="hljs-property">onclick</span> = displayMessage;  注意函数名之后没有括号<br></code></pre></td></tr></table></figure><p>在函数名后面的这个括号叫做“函数调用运算符”（function invocation operator）。你只有在想直接调用函数的地方才这么写。同样要重视的是，匿名函数里面的代码也不是直接运行的，只要代码在函数作用域内。（否则加上括号之后没有按按钮也会显示）</p><h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>     btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>         <span class="hljs-title function_">displayMessage</span>(<span class="hljs-string">&#x27;Woo,great!&#x27;</span>);<br>     &#125;;<br>     <span class="hljs-comment">// 如果我们要在点击事件里面绑定这个新函数，我们不能直接使用（btn.onclick = displayMessage(&#x27;Woo, this is a different message!&#x27;);）前面已经讲过— 我们要把它放在一个匿名函数里面，不然函数会直接调用，而不是按钮点击之后才会调用，这不是我们想要的结果。</span><br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">displayMessage</span>(<span class="hljs-params">msgText,msgType</span>) &#123;<br>         <span class="hljs-keyword">const</span> html = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>);<br><br>         <span class="hljs-keyword">const</span> panel = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>         panel.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;msgBox&#x27;</span>);<br>         html.<span class="hljs-title function_">appendChild</span>(panel);<br><br>         <span class="hljs-keyword">const</span> msg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br>         msg.<span class="hljs-property">textContent</span> = msgText;<br>         panel.<span class="hljs-title function_">appendChild</span>(msg);<br><br>         <span class="hljs-keyword">const</span> closeBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>         closeBtn.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;x&#x27;</span>;<br>         panel.<span class="hljs-title function_">appendChild</span>(closeBtn);<br><br>         closeBtn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>             panel.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(panel);<br>         &#125;<br>         <br>         <span class="hljs-keyword">if</span> (msgType === <span class="hljs-string">&#x27;warning&#x27;</span>) &#123;<br>             msg.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(icons/warning.png)&#x27;</span>;<br>             panel.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msgType === <span class="hljs-string">&#x27;chat&#x27;</span>) &#123;<br>             msg.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(icons/chat.png)&#x27;</span>;<br>             panel.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;aqua&#x27;</span>;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             msg.<span class="hljs-property">style</span>.<span class="hljs-property">paddingLeft</span> = <span class="hljs-string">&#x27;20px&#x27;</span>;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><h3 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h3><p>侦听事件发生的结构称为<strong>事件监听器</strong>（Event Listener），响应事件触发而运行的代码块被称为<strong>事件处理器</strong>（Event Handler）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;html&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;别戳我，我怕疼。&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>将事件与元素绑定有许多方法。在这里选用了 <html> 元素，然后调用了它的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a> 方法，将事件名称（<code>&#39;click&#39;</code>）以及其回调函数（当事件发生时，调用该函数）传入该函数中作为调用参数。</p><p>刚刚我们传递给 <code>addEventListener()</code> 的函数被称为<em><strong>匿名函数</strong></em>，因为它没有名字。匿名函数还有另一种我们称之为<em><strong>箭头函数</strong></em>的写法，箭头函数使用 <code>() =&gt;</code> 代替 <code>function ()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;别戳我，我怕疼。&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以下是一些常见的事件类型：</p><ul><li>鼠标事件：如点击（click）、双击（dblclick）、鼠标移动（mousemove）等。</li><li>键盘事件：如按键按下（keydown）、按键松开（keyup）等。</li><li>表单事件：如提交表单（submit）、输入变化（input）等。</li><li>文档加载事件：如文档加载完成（DOMContentLoaded）等。</li><li>窗口事件：如窗口大小改变（resize）、窗口关闭（beforeunload）等。</li></ul><p>每个事件都有其对应的事件对象，并且事件对象的属性和方法可能会根据事件类型的不同而有所不同。</p><p>因此，当你编写事件处理函数时，你可以通过访问 <code>event</code> 对象来获取有关事件的信息，无论是鼠标点击还是其他类型的事件。这样，你就可以根据事件的类型和目标元素来执行相应的操作。</p><h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h4><p><code>addEventListener</code> 是 JavaScript 中用于<strong>添加事件监听器</strong>的方法。它允许你为特定的事件类型注册一个回调函数，以便在事件发生时执行相应的操作。</p><p><code>addEventListener</code> 的语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">target.<span class="hljs-title function_">addEventListener</span>(type, listener[, options]);<br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要添加事件监听器的目标元素。</li><li><code>type</code>：要监听的事件类型，如 “click”、”keydown”、”mouseover” 等。</li><li><code>listener</code>：要执行的回调函数，也称为事件处理函数。当指定的事件类型发生时，该函数将被调用。</li><li><code>options</code>（可选）：一个包含附加选项的对象，用于指定有关事件监听的更多详细信息，例如 <code>capture</code>（是否在捕获阶段触发）、<code>once</code>（是否只触发一次）等。</li></ul><p>以下是一个简单的示例，演示如何使用 <code>addEventListener</code> 添加事件监听器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button id=<span class="hljs-string">&quot;myButton&quot;</span>&gt;<span class="hljs-title class_">Click</span> me&lt;/button&gt;<br><span class="hljs-keyword">var</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myButton&quot;</span>);<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button clicked!&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上述示例中，我们首先使用 <code>document.getElementById</code> 方法获取具有 id “myButton” 的按钮元素，并将其存储在变量 <code>button</code> 中。</p><p>然后，我们使用 <code>addEventListener</code> 方法为按钮添加一个 “click” 事件监听器。在这个示例中，匿名函数作为事件处理函数传递给 <code>addEventListener</code>。当按钮被点击时，匿名函数将被调用，输出 “Button clicked!” 到控制台。</p><p>通过使用 <code>addEventListener</code>，你可以为目标元素添加多个不同类型的事件监听器，并在事件发生时执行相应的操作。这是处理交互和用户操作的关键技术之一。</p><h4 id="removeEventListener"><a href="#removeEventListener" class="headerlink" title="removeEventListener()"></a>removeEventListener()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, changeBackground);<br></code></pre></td></tr></table></figure><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>有时候在事件处理函数内部，你可能会看到一个固定指定名称的参数，例如 <code>event</code>、<code>evt</code> 或 <code>e</code>。这被称为<strong>事件对象</strong>，它被自动传递给事件处理函数，以提供额外的功能和信息。例如，让我们稍稍重写一遍我们的随机颜色示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">random</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (number + <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">`rgb(<span class="hljs-subst">$&#123;random(<span class="hljs-number">255</span>)&#125;</span>, <span class="hljs-subst">$&#123;random(<span class="hljs-number">255</span>)&#125;</span>, <span class="hljs-subst">$&#123;random(<span class="hljs-number">255</span>)&#125;</span>)`</span>;<br>  e.<span class="hljs-property">target</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;<br><br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, bgChange);<br></code></pre></td></tr></table></figure><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><p>事件从被点击的最里面的元素<strong>冒泡</strong>而出。</p><h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><p>事件不是先在最内层的目标元素上发生，然后在连续较少的嵌套元素上发生，而是先在<em>最小嵌套</em>元素上发生，然后在连续更多的嵌套元素上发生，直到达到目标。</p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>当我们想在用户与大量的子元素中的任何一个互动时运行一些代码时，我们在它们的父元素上设置事件监听器，让发生在它们身上的事件冒泡到它们的父元素上，而不必在每个子元素上单独设置事件监听器。</p><h3 id="循环-Loop"><a href="#循环-Loop" class="headerlink" title="循环 Loop"></a>循环 Loop</h3><h3 id="字符串string"><a href="#字符串string" class="headerlink" title="字符串string"></a>字符串string</h3><h4 id="length"><a href="#length" class="headerlink" title=".length"></a>.length</h4><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf( )"></a>indexOf( )</h4><p>indexOf() 方法<strong>可返回某个指定的字符串值在字符串中首次出现的位置</strong>（索引）。 如果没有找到匹配的字符串则返回-1。</p><h4 id="slice"><a href="#slice" class="headerlink" title="slice(  )"></a>slice(  )</h4><p>slice() 方法可从已有的数组中<strong>返回选定的元素</strong>。</p><p>slice() 方法可<strong>提取字符串的某个部分</strong>，并以新的字符串返回被提取的部分。</p><p><strong>注意：</strong> slice() 方法不会改变原始数组。</p><p>当你知道字符串中的子字符串开始的位置，以及想要结束的字符时，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/slice"><code>slice()</code></a>可以用来提取 它。尝试以下：<strong>（含前不含后）</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">browserType</span>.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>此外，如果您知道要在某个字符之后提取字符串中的所有剩余字符，则不必包含第二个参数，而只需要包含要从中提取的字符位置 字符串中的其余字符。尝试以下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType.slice(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="toLowerCase-toUpperCase"><a href="#toLowerCase-toUpperCase" class="headerlink" title="toLowerCase()   toUpperCase()"></a>toLowerCase()   toUpperCase()</h4><p>字符串并将所有字符分别转换为小写或大写</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>它需要两个参数 - 要被替换下的字符串和要被替换上的字符串。尝试这个例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;moz&#x27;</span>,<span class="hljs-string">&#x27;van&#x27;</span>);<br></code></pre></td></tr></table></figure><p>注意，在实际程序中，想要真正更新 <code>browserType</code> 变量的值，您需要设置变量的值等于刚才的操作结果；它不会自动更新子串的值。所以事实上你需要这样写：<code>browserType = browserType.replace(&#39;moz&#39;,&#39;van&#39;);</code>。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>您可以将任何类型的元素存储在数组中 - 字符串，数字，对象，另一个变量，甚至另一个数组。您也可以混合和匹配项目类型 - 它们并不都是数字，字符串等。</p><h4 id="字符串与数组之间的转换"><a href="#字符串与数组之间的转换" class="headerlink" title="字符串与数组之间的转换"></a>字符串与数组之间的转换</h4><p><strong>字符串–&gt;数组</strong></p><h5 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h5><p>在其最简单的形式中，这需要一个参数，您要将字符串分隔的字符，并返回分隔符之间的子串，作为数组中的项。</p><p><strong>数组–&gt;字符串</strong></p><h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><h4 id="添加和删除数组项"><a href="#添加和删除数组项" class="headerlink" title="添加和删除数组项"></a>添加和删除数组项</h4><h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><p>要在数组末尾添加或删除一个项目，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a>。</p><h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><h5 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h5><h2 id="二、Javascript对象介绍"><a href="#二、Javascript对象介绍" class="headerlink" title="二、Javascript对象介绍"></a>二、Javascript对象介绍</h2><h3 id="对象基础"><a href="#对象基础" class="headerlink" title="对象基础"></a>对象基础</h3><h4 id="点表示法"><a href="#点表示法" class="headerlink" title="点表示法"></a>点表示法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">person[<span class="hljs-string">&#x27;age&#x27;</span>]<br>person[<span class="hljs-string">&#x27;name&#x27;</span>][<span class="hljs-string">&#x27;first&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="括号表示法"><a href="#括号表示法" class="headerlink" title="括号表示法"></a>括号表示法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">person[<span class="hljs-string">&#x27;age&#x27;</span>]<br>person[<span class="hljs-string">&#x27;name&#x27;</span>][<span class="hljs-string">&#x27;first&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="设置对象成员"><a href="#设置对象成员" class="headerlink" title="设置对象成员"></a>设置对象成员</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">person.<span class="hljs-property">age</span> = <span class="hljs-number">45</span><br>person[<span class="hljs-string">&#x27;name&#x27;</span>][<span class="hljs-string">&#x27;last&#x27;</span>] = <span class="hljs-string">&#x27;Cratchit&#x27;</span><br><br>person[<span class="hljs-string">&#x27;eyes&#x27;</span>] = <span class="hljs-string">&#x27;hazel&#x27;</span><br>person.<span class="hljs-property">farewell</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Bye everybody!&quot;</span>) &#125;<br><br><span class="hljs-keyword">var</span> myDataName = nameInput.<span class="hljs-property">value</span><br><span class="hljs-keyword">var</span> myDataValue = nameValue.<span class="hljs-property">value</span><br>person[myDataName] = myDataValue<br><br></code></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person1 = &#123;<br>  name : <span class="hljs-string">&#x27;Chris&#x27;</span>,<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;.&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person2 = &#123;<br>  name : <span class="hljs-string">&#x27;Brian&#x27;</span>,<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;.&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h3><h4 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h4><p>JavaScript 中所有的对象都有一个内置属性，称为它的 <strong>prototype</strong>（原型）。它本身是一个对象，故原型对象也会有它自己的原型，逐渐构成了<strong>原型链</strong>。原型链终止于拥有 <code>null</code> 作为其原型的对象上。</p><p>访问对象原型的标准方法是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf()</code></a></p><p>有个对象叫 <code>Object.prototype</code>，它是最基础的原型，所有对象默认都拥有它。<code>Object.prototype</code> 的原型是 <code>null</code>，所以它位于原型链的终点</p><p>在 JavaScript 中，构造函数是一种特殊的函数，用于创建对象实例。通过使用 <code>new</code> 关键字调用构造函数，可以创建一个新的对象，这个对象会自动与构造函数的原型建立关联。</p><p>每个构造函数都有一个 <code>prototype</code> 属性，它是一个对象，也被称为构造函数的原型对象。构造函数的原型对象是用于存储可以被该构造函数创建的所有实例共享的属性和方法。</p><p>当你创建一个对象实例时，它会自动关联到构造函数的原型对象。这意味着对象实例可以访问构造函数原型对象上定义的属性和方法。</p><p>通过原型链的机制，对象实例可以沿着原型链向上查找属性和方法，直到找到或者到达原型链的顶端。</p><p>构造函数和原型对象的关系可以总结如下：</p><ol><li>构造函数用于创建对象实例。</li><li>构造函数的 <code>prototype</code> 属性指向该构造函数的原型对象。</li><li>原型对象中存储了可以被构造函数创建的所有实例共享的属性和方法。</li><li>对象实例通过原型链可以访问构造函数原型对象上定义的属性和方法。</li></ol><p>通过构造函数和原型对象的结合使用，可以实现对象的创建、共享属性和方法的定义，以及对象之间的继承关系。</p><p>请注意，每个构造函数和原型对象都是独立的，它们可以创建不同的对象实例，并且每个实例都有自己的属性。但是，它们共享原型对象上的方法和属性，这样可以实现代码的重用和节省内存。</p><p><img src="/img/js1.png" alt="对象原型"></p><p><strong>原型 <code>prototype</code> 和 <code>__proto__</code></strong></p><ul><li><p>每个对象都有一个<code>__proto__</code>属性，并且指向它的<code>prototype</code>原型对象</p></li><li><p>每个<a href="https://www.zhihu.com/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2235790971%22%7D">构造函数</a>都有一个<code>prototype</code>原型对象</p></li><li><ul><li><code>prototype</code>原型对象里的<code>constructor</code>指向构造函数本身</li></ul></li></ul><p><strong>原型链</strong></p><p>每个对象都有一个<code>__proto__</code>，它指向它的<code>prototype</code>原型对象，而<code>prototype</code>原型对象又具有一个自己的<code>prototype</code>原型对象，就这样层层往上直到一个对象的原型<code>prototype</code>为<code>null</code></p><p>这个查询的路径就是<code>原型链</code></p><h4 id="JavaScript-中的继承"><a href="#JavaScript-中的继承" class="headerlink" title="JavaScript 中的继承"></a><strong>JavaScript 中的继承</strong></h4><ul><li>属性继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name, age) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><br><span class="hljs-comment">// 方法定义在构造函数的原型上</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Teacher</span> (name, age, subject) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age)<br>    <span class="hljs-comment">//属性的继承是通过在一个类内执行另外一个类的构造函数，通过call指定this为当前执行环境，这样就可以得到另外一个类的所有属性。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subject</span> = subject<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Teacher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-title class_">Teacher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Teacher</span><br></code></pre></td></tr></table></figure><h4 id="属性遮蔽"><a href="#属性遮蔽" class="headerlink" title="属性遮蔽"></a>属性遮蔽</h4><p>当该对象不具备这个属性时，才会检查原型</p><h4 id="设置原型"><a href="#设置原型" class="headerlink" title="设置原型"></a>设置原型</h4><p><code>Object.create()</code> 方法创建一个新的对象，并允许你指定一个将被<strong>用作新对象原型</strong>的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> personPrototype = &#123;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello!&quot;</span>);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> carl = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(personPrototype);<br>carl.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// hello!</span><br><br>这里我们创建了一个 personPrototype 对象，它有一个 <span class="hljs-title function_">greet</span>() 方法。然后我们使用 <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>() 来创建一个以 personPrototype 为原型的新对象。现在我们可以在新对象上调用 <span class="hljs-title function_">greet</span>()，而原型提供了它的实现<br></code></pre></td></tr></table></figure><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> personPrototype = &#123;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我的名字是 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>！`</span>);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, personPrototype);<br><span class="hljs-comment">// 或</span><br><span class="hljs-comment">// Person.prototype.greet = personPrototype.greet;</span><br><br></code></pre></td></tr></table></figure><p>这里我们：</p><ul><li>创建了一个 <code>personPrototype</code> 对象，它具有 <code>greet()</code> 方法</li><li>创建了一个 <code>Person()</code> 构造函数，它初始化了要创建人物对象的名字</li></ul><p>然后我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 将 <code>personPrototype</code> 中定义的方法绑定到 <code>Person</code> 函数的 <code>prototype</code> 属性上。</p><p>在这段代码之后，使用 <code>Person()</code> 创建的对象将获得 <code>Person.prototype</code> 作为其原型，其中自动包含 <code>greet</code> 方法。</p><h4 id="自有属性"><a href="#自有属性" class="headerlink" title="自有属性"></a>自有属性</h4><p><strong>方法是在原型上定义的</strong>，<strong>但数据属性是在构造函数中定义的</strong></p><p>直接在对象中定义的属性，如这里的<code>name</code>，被称为<strong>自有属性</strong>，你可以使用静态方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn"><code>Object.hasOwn()</code></a> 检查一个属性是否是自有属性：</p><h3 id="面向对象编程OOP"><a href="#面向对象编程OOP" class="headerlink" title="面向对象编程OOP"></a>面向对象编程OOP</h3><p>面向对象编程将一个系统抽象为许多对象的集合，每一个对象代表了这个系统的特定方面。对象包括函数（方法）和数据。一个对象可以向其他部分的代码提供一个公共接口，而其他部分的代码可以通过公共接口执行该对象的特定操作，系统的其他部分不需要关心对象内部是如何完成任务的，这样保持了对象自己内部状态的私有性。</p><h4 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h4><p>类并不做任何事情，类只是一种用于创建具体对象的模板。<code>Professor</code> 类可以创建一个具体的教授，我们称这样创建出来的具体教授为 <code>Professor</code> 类的<strong>实例</strong>。由类创建实例的过程是由一个特别的函数——<strong>构造函数</strong>所完成的。开发人员将类所需要的值传入构造函数，构造函数即可根据传入的值初始化实例的内部状态。</p><p>通常来说，需要将构造函数作为类定义的一部分明确声明，并且构造函数通常具有和类名相同的函数名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Professor</span><br>    properties<br>        name<br>        teaches<br>    constructor<br>        <span class="hljs-title class_">Professor</span>(name, teaches)<br>    methods<br>        <span class="hljs-title function_">grade</span>(paper)<br>        <span class="hljs-title function_">introduceSelf</span>()<br></code></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>    properties<br>        name<br>    constructor<br>        <span class="hljs-title class_">Person</span>(name)<br>    methods<br>        <span class="hljs-title function_">introduceSelf</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Professor</span> : <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span><br>    properties<br>        teaches<br>    constructor<br>        <span class="hljs-title class_">Professor</span>(name, teaches)<br>    methods<br>        <span class="hljs-title function_">grade</span>(paper)<br>        <span class="hljs-title function_">introduceSelf</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span><br>    properties<br>        year<br>    constructor<br>        <span class="hljs-title class_">Student</span>(name, year)<br>    methods<br>        <span class="hljs-title function_">introduceSelf</span>()<br></code></pre></td></tr></table></figure><p>在这种情况下，我们称 <code>Person</code> 类是 <code>Professor</code> 类和 <code>Student</code> 类的<strong>超类</strong>（superclass）或<strong>父类</strong>（parent class）。反之，我们称 <code>Professor</code> 类和 <code>Student</code> 类是 <code>Person</code> 类的<strong>子类</strong>（subclass 或 child class）</p><p>当一个方法拥有相同的函数名，但是在不同的类中可以具有不同的实现时，我们称这一特性为<strong>多态</strong>（polymorphism）。当一个方法在子类中替换了父类中的实现时，我们称之为子类<strong>重写&#x2F;重载</strong>（override）了父类中的实现。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>当其他部分的代码想要执行对象的某些操作时，可以借助对象向外部提供的接口完成操作，借此，对象保持了自身的内部状态不会被外部代码随意修改。也就是说，对象的内部状态保持了私有性，而外部代码只能通过对象所提供的接口访问和修改对象的内部状态，不能直接访问和修改对象的内部状态。保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这些特性称之为<strong>封装</strong>（encapsulation）。</p><p>在许多面向对象编程语言中，我们可以使用 <code>private</code> 关键字标记对象的私有部分，也就是外部代码无法直接访问的部分。如果一个属性在被标记为 <code>private</code> 的情况下，外部代码依旧尝试访问该属性，那么通常来说，计算机会抛出一个错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span><br>    properties<br>       year<br>    constructor<br>        <span class="hljs-title class_">Student</span>(name, year)<br>    methods<br>       <span class="hljs-title function_">introduceSelf</span>()<br>       <span class="hljs-title function_">canStudyArchery</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> &gt; <span class="hljs-number">1</span> &#125;<br>           <br><span class="hljs-keyword">if</span> (student.<span class="hljs-title function_">canStudyArchery</span>()) &#123;<br>  <span class="hljs-comment">// 允许学生选修弓箭课课</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span><br>    properties<br>       private year<br>    constructor<br>        <span class="hljs-title class_">Student</span>(name, year)<br>    methods<br>       <span class="hljs-title function_">introduceSelf</span>()<br>       <span class="hljs-title function_">canStudyArchery</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> &gt; <span class="hljs-number">1</span> &#125;<br><br>student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;Weber&#x27;</span>, <span class="hljs-number">1</span>)<br>student.<span class="hljs-property">year</span> <span class="hljs-comment">// 错误：&#x27;year&#x27;是学生类的私有属性</span><br></code></pre></td></tr></table></figure><h4 id="OOP与JavaScript"><a href="#OOP与JavaScript" class="headerlink" title="OOP与JavaScript"></a>OOP与JavaScript</h4><ul><li><strong>构造函数</strong>：在 JavaScript 中，构造函数可以实现类的定义，帮助我们在一个地方描述类的“形状”，包括定义类的方法。不过，原型也可以用于实现类的定义。例如，如果一个方法定义于构造函数的 <code>prototype</code> 属性中，那么所有由该构造函数创造出来的对象都可以通过原型使用该方法，而我们也不再需要将它定义在构造函数中。</li><li><strong>原型链</strong>：原型链很自然地实现了继承特性。例如，如果我们由 <code>Person</code> 原型构造了一个 <code>Student</code> 类，那么我们可以继承 <code>Person</code> 类的 <code>name</code> 属性，重写 <code>introduceSelf()</code> 方法。</li></ul><p><strong>类和对象</strong></p><p>对象通常是由类创造出来的实例。由此，定义类的方式（定义类的语法）和实例化对象的方式（构造函数）也是不同的。</p><p>而在 JavaScript 中，我们经常会使用函数或对象字面量创建对象，也就是说，JavaScript 可以在没有特定的类定义的情况下创建对象。相对于基于类的面向对象编程来说，这种方式更为轻量，帮助我们更为方便地使用对象。</p><p><strong>原型链和继承</strong></p><p>在继承方式下，当一个子类完成继承时，由该子类所创建的对象既具有其子类中单独定义的属性，又具有其父类中定义的属性（以及父类的父类，依此类推）。而在原型链中，每一个层级都代表了一个不同的对象，不同的对象之间通过 <code>__proto__</code> 属性链接起来。原型链的行为并不太像是继承，而更像是<strong>委派</strong>（delegation）。委派同样是对象中的一种编程模式。当我们要求对象执行某项任务时，在委派模式下，对象可以自己执行该项任务，或者要求另一个对象（委派的对象）以其自己的方式执行这项任务。在许多方面，相对于继承来说，委派可以更为灵活地在许多对象之间建立联系（例如，委派模式可以在程序运行时改变、甚至完全替换委派对象）。</p><h3 id="JavaScript中的类"><a href="#JavaScript中的类" class="headerlink" title="JavaScript中的类"></a>JavaScript中的类</h3><h4 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>  name;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">introduceSelf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi! I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">const</span> giles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Giles&#x27;</span>);<br><br>giles.<span class="hljs-title function_">introduceSelf</span>(); <span class="hljs-comment">// Hi! I&#x27;m Giles</span><br><br></code></pre></td></tr></table></figure><p><strong>省略构造函数</strong></p><p>如果你不需要任何特殊的初始化内容，你可以省略构造函数，默认的构造函数会被自动生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;zzzzzzz&#x27;</span>);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">const</span> spot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br><br>spot.<span class="hljs-title function_">sleep</span>(); <span class="hljs-comment">// &#x27;zzzzzzz&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Professor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br><br>  teaches;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, teaches</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">teaches</span> = teaches;<br>  &#125;<br><br>  <span class="hljs-title function_">introduceSelf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, and I will be your <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.teaches&#125;</span> professor.`</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">grade</span>(<span class="hljs-params">paper</span>) &#123;<br>    <span class="hljs-keyword">const</span> grade = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (<span class="hljs-number">5</span> - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grade);<br>  &#125;<br><br>&#125;<br><br> 如果子类有任何自己的初始化内容需要完成，它也必须先使用 <span class="hljs-variable language_">super</span>() 来调用父类的构造函数，并传递父类构造函数期望的任何参数。<br></code></pre></td></tr></table></figure><h4 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br><br>  #year;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, year</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);<br>    <span class="hljs-variable language_">this</span>.#year = year;<br>  &#125;<br><br><br>  <span class="hljs-title function_">introduceSelf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi! I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, and I&#x27;m in year <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.#year&#125;</span>.`</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">canStudyArchery</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#year &gt; <span class="hljs-number">1</span>;<br>  &#125;<br><br>&#125;<br>私有数据属性必须在类的声明中声明，而且其名称需以 # 开头。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><br>  <span class="hljs-title function_">somePublicMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">somePrivateMethod</span>();<br>  &#125;<br><br>  #<span class="hljs-title function_">somePrivateMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;You called me?&#x27;</span>);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">const</span> myExample = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<br><br>myExample.<span class="hljs-title function_">somePublicMethod</span>(); <span class="hljs-comment">// &#x27;You called me?&#x27;</span><br><br>myExample.#<span class="hljs-title function_">somePrivateMethod</span>(); <span class="hljs-comment">// SyntaxError</span><br><br>与私有数据属性一样，你也可以声明私有方法。而且名称也是以 # 开头，只能在类自己的方法中调用<br></code></pre></td></tr></table></figure><h3 id="使用JSON"><a href="#使用JSON" class="headerlink" title="使用JSON"></a>使用JSON</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/JSON">JSON</a> 是一种按照 JavaScript 对象语法的<strong>数据格式</strong></p><p>JSON 可以作为一个对象或者字符串存在，前者用于解读 JSON 中的数据，后者用于通过网络传输 JSON 数据。这不是一个大事件——JavaScript 提供一个全局的 可访问的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON">JSON</a> 对象来对这两种数据进行转换。</p><p>一个 JSON 对象可以被储存在它自己的文件中，这基本上就是一个文本文件，扩展名为 <code>.json</code>，还有 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/MIME_type">MIME type</a> 用于 <code>application/json</code>.</p><h4 id="JSON结构"><a href="#JSON结构" class="headerlink" title="JSON结构"></a>JSON结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;squadName&quot;</span> : <span class="hljs-string">&quot;Super hero squad&quot;</span>,<br>  <span class="hljs-string">&quot;homeTown&quot;</span> : <span class="hljs-string">&quot;Metro City&quot;</span>,<br>  <span class="hljs-string">&quot;formed&quot;</span> : <span class="hljs-number">2016</span>,<br>  <span class="hljs-string">&quot;secretBase&quot;</span> : <span class="hljs-string">&quot;Super tower&quot;</span>,<br>  <span class="hljs-string">&quot;active&quot;</span> : <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;members&quot;</span> : [<br>    &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Molecule Man&quot;</span>,<br>      <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">29</span>,<br>      <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Dan Jukes&quot;</span>,<br>      <span class="hljs-string">&quot;powers&quot;</span> : [<br>        <span class="hljs-string">&quot;Radiation resistance&quot;</span>,<br>        <span class="hljs-string">&quot;Turning tiny&quot;</span>,<br>        <span class="hljs-string">&quot;Radiation blast&quot;</span><br>      ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Madame Uppercut&quot;</span>,<br>      <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">39</span>,<br>      <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Jane Wilson&quot;</span>,<br>      <span class="hljs-string">&quot;powers&quot;</span> : [<br>        <span class="hljs-string">&quot;Million tonne punch&quot;</span>,<br>        <span class="hljs-string">&quot;Damage resistance&quot;</span>,<br>        <span class="hljs-string">&quot;Superhuman reflexes&quot;</span><br>      ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Eternal Flame&quot;</span>,<br>      <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">1000000</span>,<br>      <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Unknown&quot;</span>,<br>      <span class="hljs-string">&quot;powers&quot;</span> : [<br>        <span class="hljs-string">&quot;Immortality&quot;</span>,<br>        <span class="hljs-string">&quot;Heat Immunity&quot;</span>,<br>        <span class="hljs-string">&quot;Inferno&quot;</span>,<br>        <span class="hljs-string">&quot;Teleportation&quot;</span>,<br>        <span class="hljs-string">&quot;Interdimensional travel&quot;</span><br>      ]<br>    &#125;<br>  ]<br>&#125;<br><br>superHeroes[<span class="hljs-string">&quot;members&quot;</span>][<span class="hljs-number">1</span>][<span class="hljs-string">&quot;powers&quot;</span>][<span class="hljs-number">2</span>]<br><br></code></pre></td></tr></table></figure><h4 id="JSON数组"><a href="#JSON数组" class="headerlink" title="JSON数组"></a>JSON数组</h4><p>数组对象也是一种合法的 JSON 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Molecule Man&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">29</span>,<br>    <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Dan Jukes&quot;</span>,<br>    <span class="hljs-string">&quot;powers&quot;</span> : [<br>      <span class="hljs-string">&quot;Radiation resistance&quot;</span>,<br>      <span class="hljs-string">&quot;Turning tiny&quot;</span>,<br>      <span class="hljs-string">&quot;Radiation blast&quot;</span><br>    ]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Madame Uppercut&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">39</span>,<br>    <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Jane Wilson&quot;</span>,<br>    <span class="hljs-string">&quot;powers&quot;</span> : [<br>      <span class="hljs-string">&quot;Million tonne punch&quot;</span>,<br>      <span class="hljs-string">&quot;Damage resistance&quot;</span>,<br>      <span class="hljs-string">&quot;Superhuman reflexes&quot;</span><br>    ]<br>  &#125;<br>]<br>上面是完全合法的 <span class="hljs-title class_">JSON</span>。您只需要通过数组索引就可以访问数组元素，如 [<span class="hljs-number">0</span>][<span class="hljs-string">&quot;powers&quot;</span>][<span class="hljs-number">0</span>]。<br></code></pre></td></tr></table></figure><h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/JSON#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">其他注意事项</a></h4><ul><li>JSON 是一种<strong>纯数据格式</strong>，它<strong>只包含属性</strong>，<strong>没有方法</strong>。</li><li>JSON 要求在字符串和属性名称周围<strong>使用双引号</strong>。<strong>单引号无效</strong>。</li><li>甚至一个错位的逗号或分号就可以导致 JSON 文件出错。您应该小心的检查您想使用的数据 (虽然计算机生成的 JSON 很少出错，只要生成程序正常工作)。您可以通过像 <a href="http://jsonlint.com/">JSONLint</a> 的应用程序来检验 JSON。</li><li>JSON 可以将任何标准合法的 JSON 数据格式化保存，不只是数组和对象。比如，一个单一的字符串或者数字可以是合法的 JSON 对象。虽然不是特别有用处……</li><li>与 JavaScript 代码中对象属性可以不加引号不同，<strong>JSON 中只有带引号的字符串可以用作属性</strong>。</li></ul><h4 id="对象和文本间的转换"><a href="#对象和文本间的转换" class="headerlink" title="对象和文本间的转换"></a>对象和文本间的转换</h4><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>parse()</code></a>: 以文本字符串形式接受 JSON 对象作为参数，并返回相应的对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> jsonStr = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;city&quot;:&quot;New York&quot;&#125;&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonStr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出 &quot;John&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出 30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">city</span>); <span class="hljs-comment">// 输出 &quot;New York&quot;</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>stringify()</code></a>: 接收一个对象作为参数，返回一个对应的 JSON 字符串。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;New York&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> jsonStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonStr); <span class="hljs-comment">// 输出 &#x27;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;city&quot;:&quot;New York&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>localStorage 存储的数据都是以<strong>字符串的形式存储</strong>的。无论是存储字符串、数字、对象还是数组，它们在存储到 localStorage 时都会被自动转换为字符串。</p><p>当你使用 <code>localStorage.setItem(key, value)</code> 方法设置键值对时，<code>value</code> 会被自动转换为字符串。如果 <code>value</code> 是一个对象或数组，它会被转换为 JSON 字符串表示形式。</p><p>当你使用 <code>localStorage.getItem(key)</code> 方法获取键对应的值时，返回的值始终是一个字符串。如果键不存在，则返回 <code>null</code>。</p><p>为了存储和读取非字符串类型的数据（如对象和数组），通常会使用 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 来在存储和检索数据时进行转换。</p><p><code>JSON.stringify()</code> 将数据转换为 JSON 字符串，<code>JSON.parse()</code> 将 JSON 字符串解析为对应的 JavaScript 对象或数组。</p><p><strong>LocalStorage语法</strong></p><p><code>localStorage</code>是JavaScript提供的一种在客户端浏览器中存储数据的机制。它可以用于在浏览器会话之间持久保存数据，即使用户关闭浏览器或重新启动电脑，数据也将保留。</p><p><code>localStorage</code>使用简单，以下是其常见的语法和用法：</p><ol><li><strong>设置数据：</strong> 使用<code>localStorage.setItem(key, value)</code>方法来设置数据，其中<code>key</code>是要保存的数据的名称，<code>value</code>是要保存的数据的值。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>获取数据：</strong> 使用<code>localStorage.getItem(key)</code>方法来获取存储在<code>localStorage</code>中的数据。传入要获取的数据的名称<code>key</code>，它将返回对应的值。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> username = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(username); <span class="hljs-comment">// 输出：John</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>移除数据：</strong> 使用<code>localStorage.removeItem(key)</code>方法来从<code>localStorage</code>中移除指定的数据。传入要移除的数据的名称<code>key</code>即可。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>清空数据：</strong> 使用<code>localStorage.clear()</code>方法可以将<code>localStorage</code>中的所有数据清空。这将删除所有保存的数据，所以要谨慎使用。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><p>需要注意的是，存储在<code>localStorage</code>中的数据以键值对的形式存在，其中键和值都必须是字符串。如果要存储非字符串类型的数据（如对象或数组），可以使用<code>JSON.stringify()</code>将其转换为字符串进行存储，并在需要时使用<code>JSON.parse()</code>将其转换回原始类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-comment">// 存储对象</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(user));<br><br><span class="hljs-comment">// 获取对象</span><br><span class="hljs-keyword">const</span> storedUser = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(storedUser.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出：John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(storedUser.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出：30</span><br></code></pre></td></tr></table></figure><p>请注意，<code>localStorage</code>只能存储有限的数据量（通常为几MB），具体取决于浏览器和用户的设置。因此，不应将大量数据存储在<code>localStorage</code>中，以免影响性能和用户体验。</p><h2 id="三、异步JavaScript"><a href="#三、异步JavaScript" class="headerlink" title="三、异步JavaScript"></a>三、异步JavaScript</h2><h3 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h3><p>在编程中，选择使用异步或同步操作取决于特定的需求和场景。</p><p>异步操作通常用于处理耗时的任务、网络请求、文件读写等操作。它们<strong>不会阻塞程序的执行</strong>，而是通过<strong>回调函数</strong>、<strong>Promise</strong>、<strong>async&#x2F;await</strong> 等机制来处理结果或执行后续操作。异步操作可以提高程序的<strong>并发性和响应性</strong>，使得程序能够同时处理多个任务。</p><p>然而，在某些情况下，同步操作可能更加合适。同步操作会阻塞程序的执行，直到操作完成并返回结果。同步操作通常用于需要<strong>确保顺序执行</strong>、<strong>依赖前一步操作结果的情况</strong>，或者需要在操作完成之前暂停程序执行的场景。</p><p>选择异步还是同步操作取决于你的需求和程序的特点。在处理复杂的任务、并发操作、用户交互等场景下，异步操作通常更加合适。而在简单的、线性执行的任务中，同步操作可能更加简单和直观。重要的是理解两者的差异，并根据具体情况做出合适的选择。</p><p>当涉及到网络请求时，异步操作非常常见。例如，当你需要从服务器获取数据时，使用异步操作可以避免阻塞程序的执行。你可以发起一个异步的网络请求，继续执行其他任务，而无需等待服务器的响应。一旦服务器返回响应，你可以通过回调函数、Promise 或 async&#x2F;await 来处理返回的数据。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用异步操作发送 GET 请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理返回的数据</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br><br><span class="hljs-comment">// 继续执行其他任务，不需要等待服务器响应</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;继续执行其他任务...&#x27;</span>);<br></code></pre></td></tr></table></figure><p>另一个例子是处理耗时的任务，如图像处理、文件读写等。使用异步操作可以在任务执行期间允许程序继续执行其他操作，提高程序的并发性和响应性。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 异步读取文件</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><br><span class="hljs-comment">// 继续执行其他任务，不需要等待文件读取完成</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;继续执行其他任务...&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在某些情况下，同步操作更加合适。例如，当需要确保顺序执行或依赖前一步操作的结果时，同步操作可以提供简单的控制流程。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 同步读取文件</span><br><span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br><br><span class="hljs-comment">// 在文件读取完成之前，不会执行下面的代码</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;继续执行其他任务...&#x27;</span>);<br></code></pre></td></tr></table></figure><p>需要注意的是，在使用同步操作时，如果操作耗时较长或阻塞了程序的执行，可能会导致程序在此期间无法响应其他任务或用户操作。因此，同步操作应谨慎使用，以避免阻塞程序的执行。</p><p>JavaScript中大部分是同步执行的 异步的有：</p><p>使用 <strong>setTimeout，AJAX 请求、定时器、事件监听</strong>等。这些方法都可以让程序在执行到某个异步操作时继续执行后面的代码，而不需要等待异步操作完成。</p><p>除了异步操作外，还有一些语句或操作可以改变程序的执行流程，例如条件语句（<code>if</code>、<code>switch</code>）、循环语句（<code>for</code>、<code>while</code>）、函数调用等。通过合理使用这些语句和操作，可以控制代码的执行顺序和跳过特定的语句。</p><p>需要注意的是，在 JavaScript 中，异步操作是一种常见的编程模式，可以提高程序的性能和用户体验。通过合理地使用异步操作，可以避免阻塞程序执行，提高程序的响应能力。</p><p><a href="https://www.freecodecamp.org/chinese/news/asynchronous-javascript-explained/">异步javascript简介</a></p><h3 id="使用Promise"><a href="#使用Promise" class="headerlink" title="使用Promise"></a>使用Promise</h3><p><strong>Promise</strong> 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象可以让我们操作最终完成时对其进行处理（无论成功还是失败）。</p><ul><li><code>new Promise</code>: 这是创建一个新的 Promise 对象的关键字。</li><li><code>(resolve, reject) =&gt; &#123; ... &#125;</code>: 这是一个箭头函数，它是 Promise 构造函数的参数。在这个箭头函数中，你可以定义异步操作的逻辑，同时也要决定何时将 Promise 标记为已解决（resolve）或拒绝（reject）。</li><li><code>&#123; ... &#125;</code>: 这是箭头函数的函数体，你可以在这里编写异步操作的逻辑。比如，在异步操作成功时调用 <code>resolve</code>，在异步操作失败时调用 <code>reject</code>。</li><li><code>resolve</code>: 这是一个函数，用于将 Promise 标记为已解决状态。它的参数将作为 Promise 的解决值。例如，<code>resolve(&#39;Success&#39;)</code> 将 Promise 解决为字符串 ‘Success’。</li><li><code>reject</code>: 这是一个函数，用于将 Promise 标记为拒绝状态。它的参数将作为 Promise 的拒绝原因。例如，<code>reject(&#39;Error&#39;)</code> 将 Promise 拒绝，并将字符串 ‘Error’ 作为拒绝原因。</li></ul><p>所以，整个代码块的意义是：创建一个新的 Promise 对象，它有两个内置函数 <code>resolve</code> 和 <code>reject</code>，用于在异步操作成功或失败时标记 Promise 的状态。在这个 Promise 内部，你可以执行异步操作，当操作完成时，调用 <code>resolve</code> 标记为成功，或者在操作失败时调用 <code>reject</code> 标记为失败。</p><p>这种方式让你能够更好地处理异步操作的结果，并且能够更好地控制代码的执行流程。</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>当我们浏览网页时，经常会看到一些无需刷新整个页面就能获取数据或更新页面内容的情况。这就是通过 Ajax 实现的。Ajax（Asynchronous JavaScript and XML）是一种用于在网页中进行异步通信的技术。</p><p>在传统的网页中，要获取新的数据或更新页面内容，通常需要刷新整个页面。但是，使用 Ajax 技术，我们可以在后台向服务器发送请求，获取数据并将其插入到当前页面的特定部分，而不需要刷新整个页面。这使得网页更加流畅、快速，并提供了更好的用户体验。</p><p>Ajax 的重要性体现在以下几个方面：</p><ol><li><p><strong>实时性：</strong> Ajax 允许网页与服务器之间进行异步通信，使得数据的获取和更新可以在后台进行，而不需要刷新整个页面。这使得网页能够以实时或接近实时的方式展示数据的变化，例如实时聊天、动态加载内容等。</p></li><li><p><strong>交互性：</strong> Ajax 技术可以通过与服务器进行交互，实现更多的用户交互功能。例如，在一个表单中输入数据后，可以使用 Ajax 将数据发送到服务器进行验证，然后根据服务器的响应动态地更新页面，而无需刷新整个页面。</p></li><li><p><strong>性能优化：</strong> 通过使用 Ajax，可以减少对服务器的请求次数，仅获取需要更新的数据，而不是整个页面的内容。这减轻了服务器的负担，并减少了网络带宽的消耗，从而提高了网页的性能和加载速度。</p></li><li><p><strong>无缝集成：</strong> Ajax 可以与其他前端技术（如JavaScript、HTML、CSS）无缝集成，使得开发者可以更加灵活地处理网页的各种操作和交互。它可以与现有的网页技术和框架结合使用，为开发者提供更多的选择和自由度。</p></li></ol><p>总而言之，Ajax 技术通过在后台进行异步通信，使网页能够以实时、动态和交互性强的方式与服务器进行数据交换，从而提升了用户体验、性能和功能的灵活性。</p><h2 id="四、Node-js"><a href="#四、Node-js" class="headerlink" title="四、Node.js"></a>四、Node.js</h2><h3 id="node运行程序"><a href="#node运行程序" class="headerlink" title="node运行程序"></a>node运行程序</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">C:\Workspace&gt;<span class="hljs-keyword">node</span> D:<span class="hljs-title">\desktop</span>\try\guidance\<span class="hljs-keyword">node</span><span class="hljs-title">,js</span>\<span class="hljs-number">01</span>-hello.js<br><br>运行文件<br></code></pre></td></tr></table></figure><h3 id="node交互环境和直接运行的区别"><a href="#node交互环境和直接运行的区别" class="headerlink" title="node交互环境和直接运行的区别"></a>node交互环境和直接运行的区别</h3><p>在命令行模式运行<code>.js</code>文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。直接运行JavaScript文件，想要输出结果，必须自己用<code>console.log()</code>打印出来</p><p>直接输入<code>node</code>进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。</p><p>直接运行<code>node hello.js</code>文件相当于启动了Node解释器，然后一次性把<code>hello.js</code>文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</p><h3 id="使用严格模式"><a href="#使用严格模式" class="headerlink" title="使用严格模式"></a>使用严格模式</h3><p>如果在JavaScript文件开头写上<code>&#39;use strict&#39;;</code>，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上<code>&#39;use strict&#39;;</code>很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">--use_strict</span> ×××.js<br></code></pre></td></tr></table></figure><p>后续代码，如无特殊说明，我们都会直接给Node传递<code>--use_strict</code>参数来开启严格模式。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>要在模块中对外输出变量，用：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">module.exports</span> = variable<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>输出的变量可以是任意对象、函数、数组等等。</p><p>要引入其他模块输出的对象，用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">var foo</span> = require(<span class="hljs-string">&#x27;other_module&#x27;</span>);<br></code></pre></td></tr></table></figure><p>引入的对象具体是什么，取决于引入模块输出的对象。</p><p>JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p><p><strong>导出多个函数</strong> <strong>变量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">///file1</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">function1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 函数1的逻辑</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">function2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 函数2的逻辑</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> variable1 = <span class="hljs-string">&quot;变量1&quot;</span>;<br><span class="hljs-keyword">const</span> variable2 = <span class="hljs-string">&quot;变量2&quot;</span>;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  function1,<br>  function2,<br>  variable1,<br>  variable2<br>&#125;;<br><br><span class="hljs-comment">///file2</span><br><span class="hljs-keyword">const</span> exportedFunctions = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./file1&#x27;</span>);<br><br>exportedFunctions.<span class="hljs-title function_">function1</span>(); <span class="hljs-comment">// 调用导出的函数1</span><br>exportedFunctions.<span class="hljs-title function_">function2</span>(); <span class="hljs-comment">// 调用导出的函数2</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(exportedFunctions.<span class="hljs-property">variable1</span>); <span class="hljs-comment">// 访问导出的变量1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(exportedFunctions.<span class="hljs-property">variable2</span>); <span class="hljs-comment">// 访问导出的变量2</span><br><br></code></pre></td></tr></table></figure><h3 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h3><h4 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h4><p>Node.js内置的<code>fs</code>模块就是文件系统模块，负责读写文件。</p><p><strong>异步读文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;sample.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    &#125;<br>&#125;);<br><br><br>异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为<span class="hljs-literal">null</span>，data参数为读取到的<span class="hljs-title class_">String</span>。当读取发生错误时，err参数代表一个错误对象，data为<span class="hljs-literal">undefined</span>。这也是<span class="hljs-title class_">Node</span>.<span class="hljs-property">js</span>标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。<br><br>由于err是否为<span class="hljs-literal">null</span>就是判断是否出错的标志，所以通常的判断逻辑总是：<br><span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-comment">// 出错了</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 正常</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">如果我们要读取的文件不是文本文件，而是二进制文件.下面的例子演示了如何读取一个图片文件<br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;sample.png&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span> + <span class="hljs-string">&#x27; bytes&#x27;</span>);<br>    &#125;<br>&#125;);<br><br>当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个<span class="hljs-title class_">Buffer</span>对象。在<span class="hljs-title class_">Node</span>.<span class="hljs-property">js</span>中，<span class="hljs-title class_">Buffer</span>对象就是一个包含零个或任意个字节的数组（注意和<span class="hljs-title class_">Array</span>不同）。<br><br><span class="hljs-title class_">Buffer</span>对象可以和<span class="hljs-title class_">String</span>作转换，例如，把一个<span class="hljs-title class_">Buffer</span>对象转换成<span class="hljs-title class_">String</span><br><span class="hljs-comment">// Buffer -&gt; String</span><br><span class="hljs-keyword">var</span> text = data.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text);<br><br>或者把一个<span class="hljs-title class_">String</span>转换成<span class="hljs-title class_">Buffer</span>：<br><br><span class="hljs-comment">// String -&gt; Buffer</span><br><span class="hljs-keyword">var</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(text, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf);<br></code></pre></td></tr></table></figure><p><strong>同步读文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<span class="hljs-title class_">Sync</span>后缀，并且不接收回调函数，函数直接返回结果。<br><br>用fs模块同步读取一个文本文件的代码如下：<br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">var</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;sample.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br><br>如果同步读取文件发生错误，则需要用<span class="hljs-keyword">try</span>...<span class="hljs-keyword">catch</span>捕获该错误：<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;sample.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-comment">// 出错了</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>写文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">将数据写入文件是通过fs.<span class="hljs-title function_">writeFile</span>()实现的：<br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;Hello, Node.js&#x27;</span>;<br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>, data, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ok.&#x27;</span>);<br>    &#125;<br>&#125;);<br><br><br>和<span class="hljs-title function_">readFile</span>()类似，<span class="hljs-title function_">writeFile</span>()也有一个同步方法，叫<span class="hljs-title function_">writeFileSync</span>()：<br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;Hello, Node.js&#x27;</span>;<br>fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>, data);<br></code></pre></td></tr></table></figure><p><strong>stat</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">如果我们要获取文件大小，创建时间等信息，可以使用fs.<span class="hljs-title function_">stat</span>()，它返回一个<span class="hljs-title class_">Stat</span>对象，能告诉我们文件或目录的详细信息：<br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">&#x27;sample.txt&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, stat</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 是否是文件:</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isFile: &#x27;</span> + stat.<span class="hljs-title function_">isFile</span>());<br>        <span class="hljs-comment">// 是否是目录:</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isDirectory: &#x27;</span> + stat.<span class="hljs-title function_">isDirectory</span>());<br>        <span class="hljs-keyword">if</span> (stat.<span class="hljs-title function_">isFile</span>()) &#123;<br>            <span class="hljs-comment">// 文件大小:</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;size: &#x27;</span> + stat.<span class="hljs-property">size</span>);<br>            <span class="hljs-comment">// 创建时间, Date对象:</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;birth time: &#x27;</span> + stat.<span class="hljs-property">birthtime</span>);<br>            <span class="hljs-comment">// 修改时间, Date对象:</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;modified time: &#x27;</span> + stat.<span class="hljs-property">mtime</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="六、一些其他的points"><a href="#六、一些其他的points" class="headerlink" title="六、一些其他的points"></a>六、一些其他的points</h2><h4 id="一些-DOM-对象方法"><a href="#一些-DOM-对象方法" class="headerlink" title="一些 DOM 对象方法"></a>一些 DOM 对象方法</h4><p>这里提供一些您将在本教程中学到的常用方法：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getElementById()</td><td align="left">返回带有指定 ID 的元素。</td></tr><tr><td align="left">getElementsByTagName()</td><td align="left">返回包含带有指定标签名称的所有元素的节点列表（集合&#x2F;节点数组）。</td></tr><tr><td align="left">getElementsByClassName()</td><td align="left">返回包含带有指定类名的所有元素的节点列表。</td></tr><tr><td align="left">appendChild()</td><td align="left">把新的子节点添加到指定节点。</td></tr><tr><td align="left">removeChild()</td><td align="left">删除子节点。</td></tr><tr><td align="left">replaceChild()</td><td align="left">替换子节点。</td></tr><tr><td align="left">insertBefore()</td><td align="left">在指定的子节点前面插入新的子节点。</td></tr><tr><td align="left">createAttribute()</td><td align="left">创建属性节点。</td></tr><tr><td align="left">createElement()</td><td align="left">创建元素节点。</td></tr><tr><td align="left">createTextNode()</td><td align="left">创建文本节点。</td></tr><tr><td align="left">getAttribute()</td><td align="left">返回指定的属性值。</td></tr><tr><td align="left">setAttribute()</td><td align="left">把指定属性设置或修改为指定的值。</td></tr></tbody></table><h4 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h4><p><code>classList</code> 是 JavaScript 中用于操作元素的类列表的属性，它提供了一组方法来添加、移除、切换和检查类名。</p><p><code>classList</code> 属性是一个只读属性，返回一个 <code>DOMTokenList</code> 对象。<code>DOMTokenList</code> 是一个类数组对象，它包含了元素的类名作为字符串。</p><p>以下是一些常用的 <code>classList</code> 方法：</p><ul><li><code>add(className)</code>：向元素的类列表中添加一个或多个类名。</li><li><code>remove(className)</code>：从元素的类列表中移除一个或多个类名。</li><li><code>toggle(className)</code>：如果类名存在，则从元素的类列表中移除它；如果类名不存在，则向元素的类列表中添加它。</li><li><code>contains(className)</code>：检查元素的类列表中是否包含指定的类名，返回布尔值。</li></ul><p>以下是一个示例，演示如何使用 <code>classList</code> 操作元素的类列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;myElement&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;<span class="hljs-title class_">Hello</span>&lt;/div&gt;<br><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myElement&quot;</span>);<br><br><span class="hljs-comment">// 添加类名</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;highlight&quot;</span>);<br><br><span class="hljs-comment">// 移除类名</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;box&quot;</span>);<br><br><span class="hljs-comment">// 切换类名</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&quot;active&quot;</span>);<br><br><span class="hljs-comment">// 检查是否包含类名</span><br><span class="hljs-keyword">var</span> hasClass = element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&quot;highlight&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hasClass); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><p>在上述示例中，我们首先通过 <code>document.getElementById</code> 方法获取具有 id “myElement” 的 <code>&lt;div&gt;</code> 元素，并将其存储在变量 <code>element</code> 中。</p><p>然后，我们使用 <code>classList</code> 的方法来添加、移除、切换和检查类名。在示例中，我们添加了 “highlight” 类名，移除了 “box” 类名，切换了 “active” 类名，并检查了是否包含 “highlight” 类名。</p><p>通过使用 <code>classList</code>，你可以方便地操作元素的类列表，添加或移除类名，实现样式的动态变化和交互效果。</p><h4 id="stopPropagation"><a href="#stopPropagation" class="headerlink" title="stopPropagation()"></a>stopPropagation()</h4><p>当在一个事件处理器中调用时，可以防止事件向任何其他元素传递。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">在这个示例中，我们的页面包含一个视频，最初它为隐藏状态；还有一个标记为“显示视频”的按钮。我们希望有如下交互：<br><br>当用户单击“显示视频”按钮时，显示包含视频的盒子，但不要开始播放视频。<br>当用户在视频上单击时，开始播放视频。<br>当用户单击盒子内视频以外的任何区域时，隐藏盒子。<br><br><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> video = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;video&quot;</span>);<br><br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;hidden&quot;</span>));<br><br>video.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">stopPropagation</span>();<br>  video.<span class="hljs-title function_">play</span>();<br>&#125;);<br><br>box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;hidden&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="this-1"><a href="#this-1" class="headerlink" title="this"></a>this</h4><p>在 JavaScript 中，<code>this</code> 关键字用于引用当前执行代码的上下文。它的值取决于函数的调用方式。</p><p>在事件处理程序中，<code>this</code> 指向触发事件的元素，也就是<strong>绑定了事件监听器的元素</strong>。因此，在 <code>handleDelete</code> 函数中，<code>this</code> 就是指向 <code>destroyButton</code> 元素。</p><p>所以，当你在 <code>destroyButton</code> 的点击事件处理程序中使用 <code>this</code>，它就代表了当前点击的 <code>destroyButton</code> 元素本身。</p><p>值得注意的是，如果你在箭头函数中使用 <code>this</code>，它将捕获外层的上下文，而不是绑定到触发事件的元素。因此，在使用箭头函数时，可能需要使用其他方式来访问触发事件的元素。</p><p><code>this</code> 和 <code>event.target</code> 都与事件处理相关，但它们表示不同的东西。</p><ul><li><code>this</code> 是当前执行代码的上下文，指向绑定了事件监听器的元素。在事件处理程序中，<code>this</code> 引用触发事件的元素。</li><li><code>event.target</code> 是事件对象中的属性，表示触发事件的目标元素。它是事件冒泡过程中的当前目标，即接收事件的元素。</li></ul><p>区别在于，<code>this</code> 是绑定事件监听器的元素，而 <code>event.target</code> 是触发事件的元素。</p><p>举个例子来说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 输出绑定事件监听器的元素</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>); <span class="hljs-comment">// 输出触发事件的元素</span><br>&#125;<br><br><span class="hljs-keyword">var</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleClick);<br></code></pre></td></tr></table></figure><p>在上面的代码中，当按钮被点击时，<code>handleClick</code> 函数被调用。在函数中，<code>this</code> 指向按钮元素，而 <code>event.target</code> 指向触发点击事件的元素，可能是按钮自身或其内部的子元素。</p><p>总结来说，<code>this</code> 引用绑定事件监听器的元素，而 <code>event.target</code> 引用触发事件的元素。</p><h4 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h4><h5 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h5><p><code>call</code> 方法是 JavaScript 中函数对象的一个方法，它允许你在指定的作用域中调用一个函数，并且可以指定函数执行时的上下文对象（即 <code>this</code> 值）和参数列表。</p><p><code>call</code> 方法的语法如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">function</span>.<span class="hljs-keyword">call</span>(thisArg, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>function</code> 是要调用的函数对象。</li><li><code>thisArg</code> 是函数执行时的上下文对象，即在函数内部可以通过 <code>this</code> 关键字访问的对象。</li><li><code>arg1</code>, <code>arg2</code>, … 是传递给函数的参数列表。</li></ul><p>当调用 <code>call</code> 方法时，它会立即执行函数，并将指定的上下文对象绑定到函数内部的 <code>this</code>。这样，函数内部可以通过 <code>this</code> 访问该上下文对象的属性和方法。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call#using_call_to_invoke_a_function_and_specifying_the_this_value">Using call() to invoke a function and specifying the this value</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">animal</span>, <span class="hljs-string">&quot;typically sleep between&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">sleepDuration</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">animal</span>: <span class="hljs-string">&quot;cats&quot;</span>,<br>  <span class="hljs-attr">sleepDuration</span>: <span class="hljs-string">&quot;12 and 16 hours&quot;</span>,<br>&#125;;<br><br>greet.<span class="hljs-title function_">call</span>(obj); <span class="hljs-comment">// cats typically sleep between 12 and 16 hours</span><br><br></code></pre></td></tr></table></figure><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call#using_call_to_invoke_a_function_without_specifying_the_first_argument">Using call() to invoke a function without specifying the first argument</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">globalThis.<span class="hljs-property">globProp</span> = <span class="hljs-string">&quot;Wisen&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`globProp value is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.globProp&#125;</span>`</span>);<br>&#125;<br><br>display.<span class="hljs-title function_">call</span>(); <span class="hljs-comment">// Logs &quot;globProp value is Wisen&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h5><p><code>Object.create()</code> 是 JavaScript 中用于创建一个新对象，并将新对象的原型设置为指定的原型对象的方法。它的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto, [propertiesObject])<br></code></pre></td></tr></table></figure><p>其中，<code>proto</code> 是新对象的原型对象，它可以是任何对象或 <code>null</code>。<code>propertiesObject</code> 是一个可选参数，用于定义新对象的可枚举属性。</p><p><code>Object.create()</code> 的作用是创建一个新对象，该对象的原型链将继承自指定的原型对象。新对象将拥有原型对象的属性和方法，并且可以在新对象上添加或覆盖属性。</p><p>下面是一些示例用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个原型为 null 的新对象</span><br><span class="hljs-keyword">var</span> obj1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 创建一个原型为 Object.prototype 的新对象</span><br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// 创建一个原型为自定义对象的新对象</span><br><span class="hljs-keyword">var</span> parent = &#123;<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">greeting</span>); <span class="hljs-comment">// 输出: Hello</span><br><br><span class="hljs-comment">// 在创建对象时指定属性</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br>  <span class="hljs-attr">name</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">age</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>通过使用 <code>Object.create()</code>，你可以基于现有对象创建新对象，并将新对象与现有对象建立原型链继承关系。这种继承方式非常灵活，允许你创建具有特定属性和方法的对象，并在原型链上共享通用的属性和方法。</p><p>总之括号里的是原型，新创建的可以继承原型的属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Shape</span>(<span class="hljs-params">x, y, velX, velY, exists</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velX</span> = velX;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velY</span> = velY;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exists</span> = exists;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Ball</span>(<span class="hljs-params">x, y, velX, velY, exists, color, size</span>) &#123;<br>    <span class="hljs-title class_">Shape</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,x, y, velX, velY, exists);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = size;<br>&#125;<br><br><span class="hljs-title class_">Ball</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Shape</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Ball</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Ball</span>;<br><br><br><br><span class="hljs-string">`Shape.call(this, x, y, velX, velY, exists)`</span> 是为了在 <span class="hljs-string">`Ball`</span> 构造函数中调用父构造函数 <span class="hljs-string">`Shape`</span>，并将当前实例作为上下文（<span class="hljs-string">`this`</span>）传递给父构造函数。这样做的目的是为了在创建 <span class="hljs-string">`Ball`</span> 实例时，将父构造函数 <span class="hljs-string">`Shape`</span> 中的属性初始化到 <span class="hljs-string">`Ball`</span> 实例中。<br><br>然而，这只是初始化实例的属性，并没有涉及到原型对象的继承。通过 <span class="hljs-string">`Shape.call(this, x, y, velX, velY, exists)`</span>，我们只是将属性赋值给当前实例，并没有实现原型链上的继承关系。<br><br>所以，需要使用 <span class="hljs-string">`Object.create(Shape.prototype)`</span> 来设置子构造器 <span class="hljs-string">`Ball`</span> 的原型对象，以确保 <span class="hljs-string">`Ball`</span> 实例可以继承父构造器 <span class="hljs-string">`Shape`</span> 原型对象中的方法和属性。<br>同时，为了确保子构造器的原型对象的 constructor 属性指向正确的构造函数，需要执行 <span class="hljs-title class_">Ball</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Ball</span> 这句代码，将 constructor 属性重置为子构造器 <span class="hljs-title class_">Ball</span>。<br><br>这样做的目的是为了保持对象的完整性和一致性。在继承关系中，通过正确设置原型和构造函数，可以确保对象在实例化和调用方法时具有正确的行为和标识。<br><br>综上所述，这两步是必要的，一步是为了属性的初始化，另一步是为了实现原型链上的继承。<br></code></pre></td></tr></table></figure><h4 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h4><p>伪类（Pseudo-classes）是用于选择元素的特定状态或状态变化的关键词。它们以<code>:</code>开头，如<code>:hover</code>、<code>:active</code>、<code>:focus</code>等。伪类选择器应用于元素的特定状态。</p><p>伪元素（Pseudo-elements）则是在文档树中创建的虚拟元素，用于在选定元素的内容前、后或内部插入特定样式。伪元素以<code>::</code>开头，如<code>::before</code>、<code>::after</code>等。伪元素可以在元素的内容前后插入内容，并且可以通过 CSS 设置其样式。</p><p>总结一下：</p><ul><li><code>:</code>用于伪类，用于选中元素的特定状态。</li><li><code>::</code>用于伪元素，用于在选定元素的内容前、后或内部插入生成的内容。</li></ul><p>需要注意的是，根据不同的 CSS 规范版本和浏览器支持，某些伪元素可能也可以使用单个冒号（<code>:</code>）作为前缀。因此，在实际使用中，请查阅相关规范并检查浏览器兼容性。</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p><code>forEach</code>是数组的一个方法，用于遍历数组中的每个元素并执行指定的操作。以下是使用<code>forEach</code>的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><br>fruits.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">fruit</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruit);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上述代码会输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apple</span><br><span class="hljs-attribute">banana</span><br><span class="hljs-attribute">orange</span><br></code></pre></td></tr></table></figure><p>在<code>forEach</code>方法中，我们传递了一个回调函数作为参数，该回调函数将在每个数组元素上被调用。回调函数接受当前迭代的元素作为参数（在示例中是<code>fruit</code>），我们可以在回调函数中对元素进行处理。</p><p>如果需要使用箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fruits.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fruit</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruit);<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意：<code>forEach</code>方法只能用于数组，不能用于类似对象等其他数据结构。</p><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>在编程中，<code>map()</code>是一种常用的函数或方法，用于处理数组或类似结构（如列表）的元素，并返回一个新的数组，其中包含根据指定的转换规则对原始数组中的每个元素进行处理后的结果。</p><p><code>map()</code>方法的基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> newArray = originalArray.<span class="hljs-title function_">map</span>(callbackFunction);<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>originalArray</code> 是要处理的原始数组。</li><li><code>callbackFunction</code> 是一个回调函数，用于指定如何对原始数组中的每个元素进行处理。回调函数接收三个参数：<ol><li><code>currentValue</code>：当前正在处理的元素的值。</li><li><code>index</code>：当前正在处理的元素的索引（可选）。</li><li><code>array</code>：原始数组（可选）。</li></ol></li></ul><p><code>map()</code>方法会依次遍历原始数组的每个元素，并将每个元素传递给回调函数进行处理。回调函数返回的值将被添加到新的数组中，最终形成一个新的数组。原始数组保持不变，而新数组包含了根据回调函数处理后的元素。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// 使用map()方法将数组中的每个元素乘以2，并创建新的数组</span><br><span class="hljs-keyword">const</span> doubledNumbers = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> num * <span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubledNumbers); <span class="hljs-comment">// Output: [2, 4, 6, 8, 10]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>map()</code>方法将<code>numbers</code>数组中的每个元素乘以2，并将处理后的结果放入新的数组<code>doubledNumbers</code>。原始数组<code>numbers</code>保持不变。</p><p><code>map()</code>方法对于需要处理数组中的每个元素，并且生成一个新的数组的情况非常有用，比如进行转换、格式化或提取数据等操作。</p><h4 id="querySelector和getElementsBy…"><a href="#querySelector和getElementsBy…" class="headerlink" title="querySelector和getElementsBy…"></a>querySelector和getElementsBy…</h4><p><code>querySelector</code> 和 <code>getElementsBy</code> 系列方法都用于在文档中查找元素，但它们返回的结果有一些区别。</p><ol><li><p><strong>返回类型</strong>：</p><ul><li><code>querySelector</code> <strong>返回匹配的第一个元素</strong>，如果没有匹配的元素，则返回 <code>null</code>。</li><li><code>getElementsBy</code> 系列方法<strong>返回一个类数组对象</strong>，称为 HTMLCollection 或 NodeList（具体取决于方法），其中包含匹配的所有元素。</li></ul></li><li><p><strong>查找范围</strong>：</p><ul><li><code>querySelector</code> 在整个文档中查找匹配的元素。</li><li><code>getElementsBy</code> 系列方法在指定的元素集合（如 <code>document</code>、特定元素或特定节点列表）中查找匹配的元素。</li></ul></li><li><p><strong>使用灵活性</strong>：</p><ul><li><code>querySelector</code> 支持更灵活的选择器语法，可以使用类似 CSS 选择器的语法来选择元素。例如，<code>.class</code>、<code>#id</code>、<code>element</code> 等。</li><li><code>getElementsBy</code> 系列方法接受的参数是一个简单的标记名称（例如 <code>&#39;div&#39;</code>）或类名（例如 <code>&#39;className&#39;</code>），不支持复杂的选择器语法。</li></ul></li><li><p><strong>实时性</strong>：</p><ul><li><code>querySelector</code> 返回的是一个静态的结果。即使文档发生更改，它也不会自动更新匹配的元素。</li><li><code>getElementsBy</code> 系列方法返回的是一个动态的结果。如果文档发生更改，它会自动更新匹配的元素。</li></ul></li></ol><p>综上所述，<code>querySelector</code> 提供了更强大和灵活的选择器功能，并且更适合于单个元素的选择。而 <code>getElementsBy</code> 系列方法适合于在指定的元素集合中查找匹配的元素。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是即便外部函数已经不存在，也可以获取作用域链上变量的函数。</p><p><strong>闭包的特性</strong></p><ul><li>即便外部函数不再存在，闭包也可以获取父函数中的变量。</li><li>闭包不可以获取外部函数中的形参&#96;args·。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">buttonProps</span> = (<span class="hljs-params">borderRadius</span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createVariantButtonProps</span> = (<span class="hljs-params">variant, color</span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> newProps = &#123;<br>borderRadius,<br>variant,<br>color<br>&#125;;<br><span class="hljs-keyword">return</span> newProps;<br>&#125;<br><span class="hljs-keyword">return</span> createVariantButtonProps;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>闭包的优点</strong></p><ul><li>可以借助闭包在执行上下文中添加变量。</li><li>可以使用闭包中的变量保存状态，之后使用。</li><li>闭包提供数据封装。</li><li>使用闭包可以删除多余的代码。</li><li>可以使用闭包维护模块化代码。</li></ul><p><strong>闭包的缺点</strong></p><p>过度使用闭包会引发两大问题：</p><ul><li>闭包内声明的变量不能被垃圾回收。</li><li>应用中存在过多的闭包会影响应用运行速度，因为闭包会造成内存中保留重复的代码。</li></ul><h2 id="六、遇到的问题"><a href="#六、遇到的问题" class="headerlink" title="六、遇到的问题"></a>六、遇到的问题</h2><h4 id="事件委托棒棒哒"><a href="#事件委托棒棒哒" class="headerlink" title="事件委托棒棒哒"></a>事件委托棒棒哒</h4><p>比如在自己编写的todoList代码中</p><p>为每个 <li> 元素添加双击事件监听器——这种方法是不行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> todoListItems = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.todo-list li&#x27;</span>);<br>todoListItems.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>  item.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;dblclick&#x27;</span>, startEditing);<br>&#125;);<br></code></pre></td></tr></table></figure><p>将双击事件监听器绑定在父元素上——–正确做法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> todoList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.todo-list&#x27;</span>);<br>todoList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;dblclick&#x27;</span>, startEditing);<br></code></pre></td></tr></table></figure><p>原因如下：<br>在实现双击编辑功能时，使用事件委托（event delegation）的方式将双击事件监听器绑定在父元素上有以下几个好处：</p><ul><li><p>动态添加的元素也能够受到事件监听器的影响：当你通过 JavaScript 动态地添加新的 <li> 元素时，<strong>这些新元素没有直接绑定事件监听器</strong>。但是，如果你将监听器绑定在它们的父元素上，那么新添加的元素也会受到监听器的影响。这样可以避免在每次添加新元素时都要为它们单独设置事件监听器的麻烦。</p></li><li><p>提高性能和内存效率：将监听器绑定在父元素上可以减少事件监听器的数量。相对于为每个 <li> 元素都绑定监听器，只绑定一个监听器到父元素上可以提高性能和内存效率，特别是在大量元素存在的情况下。</p></li><li><p>方便处理事件委托：事件委托可以让你在父元素上捕获事件，然后根据事件的目标元素（即触发事件的元素）来执行相应的操作。在双击编辑功能的情况下，你可以通过检查事件的目标元素是否为 <label> 元素，来确定是否触发双击编辑功能。这样，你无需为每个 <li> 元素单独设置双击事件监听器，而是统一在父元素上处理。</p></li></ul><p>综上所述，使用事件委托将事件监听器绑定在父元素上具有更好的灵活性、性能和内存效率，尤其适用于需要处理大量动态添加元素的情况。</p><h4 id="关于”提升”"><a href="#关于”提升”" class="headerlink" title="关于”提升”"></a>关于”提升”</h4><h5 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h5><p>在执行代码之前，JavaScript解释器会进行函数的解析，并将函数定义提升到作用域的顶部。</p><p>函数提升的机制使得函数在定义之前就可以进行调用，这在某些情况下非常方便。然而，尽管函数调用可以在定义之前，但是最佳实践是将函数的调用放在函数定义的后面，以提高代码的可读性和可维护性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数调用</span><br><span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出：Hello!</span><br><br><span class="hljs-comment">// 函数定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是可行的</p><h5 id="函数表达式提升-×"><a href="#函数表达式提升-×" class="headerlink" title="函数表达式提升 ×"></a>函数表达式提升 ×</h5><p>函数表达式不会被提升。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 抛出错误：sayHello is not a function</span><br><br><span class="hljs-keyword">var</span> sayHello = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，由于变量 <code>sayHello</code> 的声明和赋值是通过函数表达式完成的，而非函数声明，所以它不会被提升。因此，在调用函数之前，变量 <code>sayHello</code> 还未被赋值，导致抛出错误。</p><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><p>关于变量提升，JavaScript 会将变量声明提升到作用域的顶部，但不会提升赋值操作。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 输出：undefined</span><br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，变量 <code>x</code> 被提升，但它的值在声明之前是 <code>undefined</code>。因此，当我们尝试在赋值之前输出它时，会得到 <code>undefined</code>。</p><p><strong>总结</strong>：函数声明会被提升，函数表达式和变量赋值操作不会被提升。为了避免潜在的错误和代码可读性问题，建议在使用之前先进行函数声明和变量赋值操作。如果可能，将函数的调用放在函数定义之后，以提高代码的清晰性和可维护性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">以下是错误经历：<br><span class="hljs-keyword">var</span> evilcircle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvilCircle</span> (<br>......<br>);<br>evilcircle.<span class="hljs-title function_">setControls</span>();<br><span class="hljs-title class_">EvilCircle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setControls</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>&#125;<br>正确的应该先定义后调用，否则setControls的方法没有赋给<span class="hljs-title class_">EvilCircle</span>的原型<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS运行机制 | JS</title>
    <link href="/2024/01/28/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/01/28/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h2><p> 深入剖析底层原理 🤔 本篇笔记涉及进程和线程，JS单线程机制，浏览器机制，宏任务微任务，async&#x2F;await等内容</p><span id="more"></span><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li><strong>什么是进程</strong><ul><li><code>进程</code>是<code>CPU</code>资源分配的最小单位</li><li><code>进程</code>包括运行中的程序和程序所使用到的内存和系统资源</li></ul></li><li><strong>什么是线程</strong><ul><li><code>线程</code>是<code>CPU</code>调度的最小单位</li><li><code>线程</code>是建立在<code>进程</code>基础上的一次程序运行单位 <strong>程序中的一个执行流</strong><ul><li>单线程：一个进程中只有一个执行流</li><li>多线程：一个进程中有多个执行流</li></ul></li></ul></li><li><strong>进程和线程的区别</strong><ul><li>进程是<strong>操作系统分配资源的最小单位</strong>，线程是<strong>程序执行的最小单位</strong></li><li><strong>一个进程由一个或多个线程组成</strong>，线程可以理解为是一个进程中代码的不同执行路线</li><li>进程之间相互独立，但同一进程下的各个线程间<strong>共享</strong>程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)</li><li>调度和切换：线程上下文切换比进程上下文切换要<strong>快得多</strong></li></ul></li><li><strong>多进程和多线程</strong><ul><li><strong>多进程</strong>：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态</li><li><strong>多线程</strong>：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</li></ul></li></ul><h3 id="JS的单线程机制"><a href="#JS的单线程机制" class="headerlink" title="JS的单线程机制"></a>JS的单线程机制</h3><ul><li>脚本语言 与用户互动 操作DOM</li><li>不是单线程会有同步问题</li></ul><hr><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><strong>浏览器是多进程的</strong></p><h4 id="浏览器包含的进程"><a href="#浏览器包含的进程" class="headerlink" title="浏览器包含的进程"></a>浏览器包含的进程</h4><ul><li><strong>Browser进程</strong><ul><li>浏览器的<strong>主进程</strong>(负责协调、主控)，该进程只有一个</li><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li><strong>第三方插件进程</strong><ul><li>每种类型的插件对应一个进程，当使用该插件时才创建</li></ul></li><li><strong>GPU进程</strong><ul><li>该进程也只有一个，用于<strong>3D绘制</strong>等等</li></ul></li><li><strong>渲染进程(重)</strong><ul><li>即通常所说的浏览器内核(<strong>Renderer进程</strong>，内部是多线程)</li><li>每个Tab页面都有一个渲染进程，互不影响</li><li>主要作用为<strong>页面渲染，脚本执行，事件处理</strong>等</li></ul></li></ul><hr><h4 id="渲染进程Renderer"><a href="#渲染进程Renderer" class="headerlink" title="渲染进程Renderer"></a>渲染进程Renderer</h4><h5 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h5><ul><li>负责渲染浏览器界面，<strong>解析HTML，CSS</strong>，<strong>构建DOM树和RenderObject树</strong>，<strong>布局和绘制</strong>等<ul><li>解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree</li><li>解析css，生成CSSOM(CSS规则树)</li><li>把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)</li></ul></li><li>当我们修改了一些元素的颜色或者背景色，页面就会<strong>重绘(Repaint)</strong></li><li>当我们修改元素的尺寸，页面就会<strong>回流(Reflow)</strong></li><li>当页面需要Repaing和Reflow时GUI线程执行，绘制页面</li><li>回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免Reflow和Repaint</li><li><strong>GUI渲染线程与JS引擎线程是互斥的</strong><ul><li>当JS引擎执行时GUI线程会被挂起(相当于被冻结了)</li><li>GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</li></ul></li></ul><h5 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h5><ul><li>JS引擎线程就是<strong>JS内核</strong>，负责处理Javascript脚本程序(例如V8引擎)</li><li>JS引擎线程负责<strong>解析Javascript脚本，运行代码</strong></li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理<ul><li>浏览器同时只能有一个JS引擎线程在运行JS程序，所以<strong>js是单线程运行的</strong></li><li>一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序</li></ul></li><li>GUI渲染线程与JS引擎线程是<strong>互斥</strong>的，js引擎线程会阻塞GUI渲染线程<ul><li>就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)</li><li>例如浏览器渲染的时候遇到<code>&lt;script&gt;</code>标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况</li></ul></li></ul><h5 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h5><ul><li><strong>属于浏览器</strong>而不是JS引擎，用来<strong>控制事件循环</strong>，并且<strong>管理着一个事件队列(task queue)</strong></li><li>当js执行碰到<strong>事件绑定</strong>和一些<strong>异步操作</strong>(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程<strong>将对应的事件添加到对应的线程中</strong>(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的<strong>回调操作添加到事件队列</strong>，等待js引擎线程空闲时来处理。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理</li></ul><h5 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h5><ul><li><code>setInterval</code>与<code>setTimeout</code>所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的(因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)</li><li><strong>通过单独线程来计时并触发定时</strong>(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程</li><li>W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms</li></ul><h5 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h5><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行</li><li>简单说就是当执行到一个http异步请求时，就把<strong>异步请求事件添加到异步请求线程</strong>，等收到响应(准确来说应该是http状态变化)，再把<strong>回调函数添加到事件队列</strong>，等待js引擎线程来执行</li></ul><hr><h4 id="事件循环Event-Loop"><a href="#事件循环Event-Loop" class="headerlink" title="事件循环Event Loop"></a>事件循环Event Loop</h4><ul><li>js分为<strong>同步任务</strong>和<strong>异步任务</strong></li><li>同步任务都在主线程 ，形成一个<strong>执行栈</strong></li><li>事件触发线程管理着一个<strong>任务队列</strong>， 异步任务有结果之后放一个事件回调</li><li>执行栈执行完毕后，读取任务队列添加到执行栈中开始执行</li></ul><p>JS引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的<strong>事件循环(Event Loop)</strong></p><blockquote><p>总之就是 js线程控制执行着执行栈中的任务</p><p>事件触发线程控制着任务队列, js有空的时候才执行任务队列里面的</p><p>定时器触发线程是单独一个线程用来计时,到时间之后添加到任务队列里面等待</p><p>异步http请求线程是单独一个线程请求资源,请求成功之后添加到任务队列里面等待</p></blockquote><p><strong>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</strong></p><p>事件循环的基本流程如下：</p><ul><li>执行<strong>同步代码</strong>，将Promise对象的<code>executor</code>函数立即执行。</li><li>如果<code>executor</code>中包含异步操作（比如<code>setTimeout</code>），它们会被放入宏任务队列。</li><li>当执行栈为空时，JavaScript会检查微任务队列，<strong>执行微任务</strong>。微任务包括Promise的回调。then</li><li>接着，JavaScript会检查宏任务队列，<strong>执行宏任务</strong>。宏任务包括<code>setTimeout</code>等。</li></ul><hr><h3 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务&amp;微任务"></a>宏任务&amp;微任务</h3><h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p><strong>macrotask</strong> (<strong>task</strong>)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">宏任务 <span class="hljs-punctuation">-&gt;</span> GUI渲染 <span class="hljs-punctuation">-&gt;</span> 宏任务 <span class="hljs-punctuation">-&gt;</span> GUI ...<br></code></pre></td></tr></table></figure><ul><li><strong>常见的宏任务</strong><ul><li>主代码块</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul></li></ul><h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p><strong>microtask</strong>(<strong>jobs</strong>)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">宏任务 <span class="hljs-punctuation">-&gt;</span> 微任务 <span class="hljs-punctuation">-&gt;</span> GUI渲染 <span class="hljs-punctuation">-&gt;</span> 宏任务 <span class="hljs-punctuation">-&gt;</span> ...<br></code></pre></td></tr></table></figure><ul><li>常见微任务<ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul></li></ul><h4 id="简单区分"><a href="#简单区分" class="headerlink" title="简单区分"></a>简单区分</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:black&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:red&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:blue&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:pink&#x27;</span>;<br><br><span class="hljs-comment">//页面直接变成pink 因为这是一次宏任务 都结束后才渲染</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:blue&#x27;</span>;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:black&#x27;</span><br>&#125;,<span class="hljs-number">200</span>)<br><br><span class="hljs-comment">//先blue再马上black 属于两次宏任务 之间有渲染</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:blue&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:pink&#x27;</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//输出 1 3 2 then是异步执行</span><br><span class="hljs-comment">//直接变成pink因为宏任务执行后执行Promise.then微任务 之后再渲染</span><br></code></pre></td></tr></table></figure><blockquote><p>首先执行一个宏任务，执行结束后判断是否存在微任务</p><p>有微任务先执行所有的微任务，再渲染，没有微任务则直接渲染</p><p>然后再接着执行下一个宏任务</p></blockquote><ul><li>执行顺序<ul><li>执行当前宏任务的<strong>同步代码</strong></li><li>执行当前宏任务中的<strong>所有微任务</strong></li><li>执行<strong>下一个宏任务</strong></li></ul></li></ul><hr><h3 id="关于Promise"><a href="#关于Promise" class="headerlink" title="关于Promise"></a>关于Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">//输出 1 3 2 </span><br><span class="hljs-comment">//new Promise()是一个构造函数 同步任务</span><br><span class="hljs-comment">//.then()是一个异步微任务</span><br></code></pre></td></tr></table></figure><p><img src="/img/timer.png" alt="定时器情况"></p><h3 id="关于async-await"><a href="#关于async-await" class="headerlink" title="关于async&#x2F;await"></a>关于async&#x2F;await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-title function_">test</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">//输出 1 2 3 4</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// timer1</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><br><span class="hljs-title function_">test</span>();<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// timer2</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// timer3</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>  &#125;, <span class="hljs-number">100</span>)<br>  <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// timer4</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">// 1 4 8 7 3 6 5 2</span><br></code></pre></td></tr></table></figure><h4 id="某道学长的面试题"><a href="#某道学长的面试题" class="headerlink" title="某道学长的面试题"></a>某道学长的面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">B</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>); <span class="hljs-comment">//这里可能需要注意一下，是放入微任务队列</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">444</span>);<br><span class="hljs-title function_">A</span>();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">555</span>);<br>&#125;,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">666</span>);<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">777</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">888</span>);<br><br><span class="hljs-comment">//444 111 333 666 888 222 777 555</span><br></code></pre></td></tr></table></figure><ul><li>当<code>await</code>关键字遇到一个<code>Promise</code>时，它会将<strong>后续的代码</strong>（在这种情况下是打印222）<strong>放入微任务队列</strong>，以便在<code>Promise</code>解析为已完成状态后执行。</li><li>微任务队列是一个异步任务队列，其中的任务会在主事件循环之前执行。这确保了<code>await</code>后面的代码可以尽快执行，而不会被其他任务阻塞。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>底层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何写好prompt | LLM</title>
    <link href="/2024/01/28/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BDprompt/"/>
    <url>/2024/01/28/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BDprompt/</url>
    
    <content type="html"><![CDATA[<h1 id="设计prompt的小tips"><a href="#设计prompt的小tips" class="headerlink" title="设计prompt的小tips"></a>设计prompt的小tips</h1><p>💡如何写好prompt获取更优质的回答呢？（本文总结于openai官网教程）</p><span id="more"></span><h3 id="01-写出清晰的指令"><a href="#01-写出清晰的指令" class="headerlink" title="01 写出清晰的指令"></a>01 写出清晰的指令</h3><ul><li>尽可能详细的描述，完整的上下文</li><li>让模型充当某种角色</li><li>使用分隔符清晰划分输入</li><li>指定完成任务需要的步骤</li><li>提供例子 few-shot</li><li>指定输出的长度</li></ul><h3 id="02-提供参考文本"><a href="#02-提供参考文本" class="headerlink" title="02 提供参考文本"></a>02 提供参考文本</h3><ul><li>模型使用参考文本作答</li><li>模型引用参考文本作答</li></ul><h3 id="03-复杂任务拆分成子任务"><a href="#03-复杂任务拆分成子任务" class="headerlink" title="03 复杂任务拆分成子任务"></a>03 复杂任务拆分成子任务</h3><ul><li>使用意图分类</li><li>总结或过滤先前对话</li><li>分段递归总结长文档</li></ul><h3 id="04-给模型时间思考-CoT"><a href="#04-给模型时间思考-CoT" class="headerlink" title="04 给模型时间思考 CoT"></a>04 给模型时间思考 CoT</h3><ul><li>首先让大模型自己解决问题，不要直接判断是否正确</li><li>内心独白增强模型推理过程，多次和api通讯</li><li>询问模型在之前内容是否遗漏某些内容</li></ul><h3 id="05-使用外部工具"><a href="#05-使用外部工具" class="headerlink" title="05 使用外部工具"></a>05 使用外部工具</h3><ul><li>使用基于嵌入的搜索，实现高效知识检索</li><li>执行代码进行更准确的计算，或者调用外部API</li><li>给模型提供特定功能</li></ul><h3 id="06-系统测试变更"><a href="#06-系统测试变更" class="headerlink" title="06 系统测试变更"></a>06 系统测试变更</h3><p>编写程序判断优化系统是否有效 for开发者</p><p><img src="/img/prompt1.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Welcome to Rey&#39;s world!</title>
    <link href="/2024/01/20/Introduction/"/>
    <url>/2024/01/20/Introduction/</url>
    
    <content type="html"><![CDATA[<p> 大家好 ❤ </p><p> 欢迎光临我的小世界 🌸</p><span id="more"></span><h3 id="about-me"><a href="#about-me" class="headerlink" title="about me"></a>about me</h3><p>🦋    <strong>mbti</strong> : <strong>INFP</strong> </p><p>🏫<strong>university : HUST</strong></p><p>💻<strong>major : Software Engineering</strong></p><p>😊    <strong>hobbies</strong> ：<strong>dancing</strong>💃    <strong>sleeping</strong>💤    <strong>eating</strong>😋    <strong>daydreaming☁</strong></p><p>🔑    <strong>github</strong> : <strong><a href="https://github.com/JerryC66">https://github.com/JerryC66</a></strong></p><p>📧<strong>gmail</strong> : <strong><a href="mailto:&#x6a;&#101;&#114;&#114;&#121;&#46;&#99;&#99;&#x2e;&#x65;&#99;&#x68;&#111;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x6a;&#101;&#114;&#114;&#121;&#46;&#99;&#99;&#x2e;&#x65;&#99;&#x68;&#111;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></strong> </p><h3 id="about-blog"><a href="#about-blog" class="headerlink" title="about blog"></a>about blog</h3><p>很久很久以前就想搭建自己的博客，拖延症晚期患者就是一拖再拖，这几天终于开始捣鼓，现在终于初具雏形。</p><p>心里有一种难以名状的踏实感，满足感… 终于可以在一个独属于自己的地方记录一些独属于自己的东西了。</p><p>感觉俺想写博客也不是抱着什么目的性。</p><p>学到个新东西的时候马上记录一下，算是督促自己好好理解以后不时回来看看。</p><p>有什么小想法的时候马上记录一下，算是在时间轴上多多少少留下一些痕迹吧。</p><p>当然一次次实践也让我明白一些道理，不要害怕自己没尝试的事情，也不要美化自己没走过的路。</p><p>很开心你来到我的秘密基地，一起成为自己想成为的人吧。</p><p>加油，一切还未知 🌅</p><p><img src="/img/test1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
