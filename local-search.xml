<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Per aspera ad astra</title>
    <link href="/2024/01/31/%E7%A9%BF%E8%B6%8A%E9%80%86%E5%A2%83%E6%8A%B5%E8%BE%BE%E7%B9%81%E6%98%9F/"/>
    <url>/2024/01/31/%E7%A9%BF%E8%B6%8A%E9%80%86%E5%A2%83%E6%8A%B5%E8%BE%BE%E7%B9%81%E6%98%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="穿越逆境-抵达繁星"><a href="#穿越逆境-抵达繁星" class="headerlink" title="穿越逆境 抵达繁星"></a>穿越逆境 抵达繁星</h2><p>🌼一段超级温暖的话，from一位超级爱的朋友…</p><span id="more"></span><p>&nbsp;</p><p>​<strong>“人一直会看见高山，而一山总比一山高，希望你相信你也是很棒的很勇敢的很优秀的很专注的很多人爱你的，每个人成为呼啸最高峰的那阵风前，都有过无数挫败晦暗的时刻，正是因为客观存在的这些问题，人往往能够追求更好的自我。我认为痛苦从来不是必要的，但直接面对它的人、勇于挑战它的人，永远都很了不起。”</strong></p><p>&nbsp;</p><p><img src="/img/test.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SmoothLLM</title>
    <link href="/2024/01/31/SmoothLLM/"/>
    <url>/2024/01/31/SmoothLLM/</url>
    
    <content type="html"><![CDATA[<h1 id="SmoothLLM"><a href="#SmoothLLM" class="headerlink" title="SmoothLLM"></a>SmoothLLM</h1><p>💪 <strong>Defending Large Language Models Against Jailbreaking Attacks</strong></p><span id="more"></span><p>SmoothLLM 是一种旨在<strong>保护大型语言模型免受越狱攻击</strong>的算法</p><p>原论文请参看<a href="https://arxiv.org/abs/2310.03684">SmoothLLM</a></p><h2 id="Several-concepts"><a href="#Several-concepts" class="headerlink" title="Several concepts"></a>Several concepts</h2><h3 id="Adversarial-prompting"><a href="#Adversarial-prompting" class="headerlink" title="Adversarial prompting"></a>Adversarial prompting</h3><p><strong>对抗性输入（Adversarial Input）</strong>是指经过有意设计或修改的输入数据，旨在欺骗或误导机器学习模型的输入。</p><ul><li><strong>提示注入（Prompt Injection)</strong><br>  通过注入一条指令来劫持模型输出，以忽略原始指令并执行注入的指令</li><li><strong>提示泄漏（Prompt Leaking)</strong><br>  模型可能通过提示的选择或生成的内容中泄露出训练数据的信息</li><li><strong>越狱（Jailbreaking)</strong><br>  对预先训练的语言模型进行攻击，使其生成不当或有害的内容，即使模型原本经过了对抗性训练</li><li><strong>防御策略（Defense Tactics)</strong></li></ul><h3 id="Adversarial-training"><a href="#Adversarial-training" class="headerlink" title="Adversarial training"></a>Adversarial training</h3><ul><li>提高模型对抗攻击的能力，使其在面对输入数据中的有意制造的扰动或误导性信息时能够保持<strong>稳健性</strong></li><li>通过在训练数据中引入一些经过计算的<strong>对抗性样本</strong>，迫使模型更好地理解和适应这些干扰，从而提高其在真实场景中的<strong>鲁棒性</strong></li><li>对抗性训练的步骤<ul><li>生成对抗性样本</li><li>将对抗性样本添加到训练集</li><li>训练模型</li></ul></li></ul><h3 id="Jailbreaking"><a href="#Jailbreaking" class="headerlink" title="Jailbreaking"></a>Jailbreaking</h3><ul><li><strong>越狱（Jailbreaking）</strong>是一种提示注入技术，用于绕过语言模型（LLM）的创建者放置在其上的安全和审查功能</li><li>越狱的方法<ul><li><strong>伪装</strong><ul><li>简单伪装 pretend you can…</li><li>角色扮演 he is an actor…</li></ul></li><li><strong>对齐黑客</strong><ul><li>承担责任 you are supposed to answer…</li><li>研究实验 i am conducting a test about…</li></ul></li><li><strong>授权用户</strong><ul><li>上级模型  I am GPT-4…you are GPT-3</li><li>sudo模式 内核模式</li></ul></li></ul></li></ul><h2 id="Abastact"><a href="#Abastact" class="headerlink" title="Abastact"></a>Abastact</h2><ul><li><p>SmoothLLM is an algorithm designed to <strong>defend large language models against jailbreaking attacks</strong>.</p></li><li><p>It randomly <strong>perturbs input prompts and aggregates predictions</strong> to detect adversarial inputs.</p></li><li><p>SmoothLLM <strong>reduces the attack success rate</strong> on popular LLMs to below one percentage point.</p></li><li><p>It uses exponentially <strong>fewer queries</strong> than existing attacks and is <strong>compatible</strong> with any LLM.</p></li></ul><h2 id="Symbol-convention"><a href="#Symbol-convention" class="headerlink" title="Symbol convention"></a>Symbol convention</h2><ul><li><p><strong>a deterministic function JB</strong><br>  checks whether the response R begins with the target T</p><p>  <img src="/img/smooth1.png"></p></li><li><p><strong>the goal of the attack</strong></p><p>  <img src="/img/smooth2.png"></p></li><li><p><strong>attack success rate (ASR)</strong></p><p>  the ASR is the fraction of the triplets (Gj, Tj, Sj) in D that jailbreak the LLM.</p><p>  <img src="/img/smooth3.png"></p></li></ul><h2 id="Related-work"><a href="#Related-work" class="headerlink" title="Related work"></a>Related work</h2><ul><li>对抗性训练或数据增强<ul><li>需要对底层模型重新训练，计算上不可行</li><li>闭源模型不透明，只能通过查询访问来防御</li></ul></li><li>使用困惑度过滤器进行预处理、改写输入提示以及采用对抗性训练<ul><li>计算成本大</li></ul></li><li>在输入提示的子字符串上应用安全过滤器<ul><li>复杂性随着输入提示的长度增加而增加</li><li>并未在GCG攻击下进行评估</li></ul></li></ul><h2 id="A-desiderata-for-LLM-defenses"><a href="#A-desiderata-for-LLM-defenses" class="headerlink" title="A desiderata for LLM defenses"></a>A desiderata for LLM defenses</h2><ul><li>在缓解攻击的同时，不应对非敌对输入产生显著性能下降<ul><li><strong>攻击缓解（Attack Mitigation）</strong></li><li><strong>非保守性（Non-Conservatism）</strong></li></ul></li><li>在不引入实施折衷的情况下对所有可用LLMs的适用性<ul><li><strong>效率（Efficiency）</strong></li><li><strong>兼容性（Compatibility）</strong></li></ul></li></ul><h2 id="SmoothLLM-Algorithm1"><a href="#SmoothLLM-Algorithm1" class="headerlink" title="SmoothLLM Algorithm1"></a>SmoothLLM Algorithm1</h2><p><img src="/img/smooth9.png" alt="smoothllm"></p><h3 id="Perturbation-step"><a href="#Perturbation-step" class="headerlink" title="Perturbation step"></a>Perturbation step</h3><ul><li>three kinds of perturbations<ul><li>Insert</li><li>Swap</li><li>Patch</li></ul></li><li>At q &#x3D; 10%, the ASR for swap perturbations falls below 1%</li><li>the entire prompt is perturbed, not just the suffix;</li></ul><h3 id="Agregation-step"><a href="#Agregation-step" class="headerlink" title="Agregation step"></a>Agregation step</h3><ul><li>a collection of perturbed prompts</li><li>on average, perturbed prompts tend to nullify jailbreaks</li><li>SmoothLLM算法的核心思想是<strong>通过对输入提示进行大量随机扰动，引入随机性，以平均地抵消对抗性部分</strong></li></ul><h3 id="Algorithm1"><a href="#Algorithm1" class="headerlink" title="Algorithm1"></a>Algorithm1</h3><p><img src="/img/smooth4.png" alt="Algorithm1"></p><ul><li>随机扰动生成了N个输入提示Qj，传递给LLM模型生成响应</li><li>判断大多数响应是否是“jailbreak”</li><li>返回与该估计一致的任何响应LLM(Q)，汇总这些预测</li><li>Algorithm 1的两个参数：N（样本数量）和q（扰动百分比）</li></ul><h3 id="Robustness-guarantees"><a href="#Robustness-guarantees" class="headerlink" title="Robustness guarantees"></a>Robustness guarantees</h3><p><img src="/img/smooth5.png"></p><ul><li>k (不稳定参数) 是要使得攻击失败，最少需要改变的字符数</li></ul><p><img src="/img/smooth6.png"></p><ul><li>m是输入提示的长度，ms是后缀的长度，M是扰动的字符数</li><li>当攻击对扰动更加鲁棒时，为了提高SmoothLLM成功减轻攻击的概率，需要增加扰动百分比q</li></ul><h3 id="Experimental-results"><a href="#Experimental-results" class="headerlink" title="Experimental results"></a>Experimental results</h3><p><img src="/img/smooth7.png"></p><h2 id="Experimental-evaluation"><a href="#Experimental-evaluation" class="headerlink" title="Experimental evaluation"></a>Experimental evaluation</h2><h3 id="Attack-mitigation"><a href="#Attack-mitigation" class="headerlink" title="Attack mitigation"></a>Attack mitigation</h3><ul><li>GCG对Vicuna和Llama2的攻击<ul><li>ASR显著降低</li></ul></li><li>SmoothLLM对自适应攻击的威胁<ul><li>不能直接用GCG攻击，因为是字符级别扰动使得梯度计算不可行（可以用代理模型在token级别攻击）</li><li>使用代理模型时，攻击SmoothLLM的效果不如直接攻击未进行防御的LLM</li></ul></li><li>SmoothLLM对PAIR语义jailbreak的防御<ul><li>不是针对PAIR的模型，但是仍可以有效降低ASR</li></ul></li></ul><h3 id="Non-conservatism"><a href="#Non-conservatism" class="headerlink" title="Non-conservatism"></a>Non-conservatism</h3><ul><li>N值越大往往会提高标称性能，而q值的增加则会降低标称性能</li><li>平衡减弱攻击性和生成有效文本的程度</li></ul><h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><ul><li>SmoothLLM的查询效率通常比GCG高5到6个数量级（对昂贵攻击的廉价防御）</li></ul><h3 id="Compatibility"><a href="#Compatibility" class="headerlink" title="Compatibility"></a>Compatibility</h3><ul><li>通过转移攻击后缀实验表明，SmoothLLM在一定程度上对于闭源LLM具有兼容性</li></ul><h2 id="Future-work"><a href="#Future-work" class="headerlink" title="Future work"></a>Future work</h2><ul><li><strong>The interplay between q and the ASR</strong><ul><li>q应该被选择得足够小，以便提示符保留其语义内容</li><li>未来的工作应该关注更健壮的方法来检测越狱</li></ul></li><li><strong>Broad applicability of SmoothLLM</strong><ul><li>由于SmoothLLM干扰了整个输入提示，此防御广泛适用于任何基于反向提示的越狱</li></ul></li><li><strong>The computational burden of jailbreaking</strong><ul><li>查询效率高、时间效率高、与黑盒llm的兼容性强</li><li>SmoothLLM是随机防御，廉价地防御</li></ul></li><li><strong>Other variants of SmoothLLM</strong><ul><li>设计和评估SmoothLLM的新变体</li><li>比如聚合步骤的新方案</li></ul></li></ul><p><img src="/img/smooth10.png"></p><p><img src="/img/smooth11.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>大模型</category>
      
      <category>攻防问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学建模总览</title>
    <link href="/2024/01/31/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%80%BB%E8%A7%88/"/>
    <url>/2024/01/31/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<p>🤔 准备小小汇总一篇~ 笔记的图片还是等把picgo修好了再全部上传吧😭</p><span id="more"></span><h3 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h3><ul><li><p><strong>1 、优化模型</strong></p></li><li><ul><li>1.1 数学规划模型<ul><li>1.2 微分方程组模型</li><li>1.3 图论与网络优化问题</li><li>1.4 概率模型</li><li>1.5 组合优化经典问题</li><li>现代优化算法：禁忌搜索；模拟退火；遗传算法；人工神经网络</li></ul></li></ul></li><li><p><strong>2、分类模型</strong></p></li><li><ul><li>2.1 判别分析<ul><li>2.2 聚类分析</li><li>2.3 神经网络分类方法</li></ul></li></ul></li><li><p><strong>3、评价模型</strong></p></li><li><ul><li>3.1 层次分析法(AHP)<ul><li>3.2 灰色综合评价法（灰色关联度分析）</li><li>3.3 模糊综合评价法</li><li>3.4 BP神经网络综合评价法</li><li>3.5 数据包络法(DEA)</li><li>3.6 组合评价法</li></ul></li></ul></li><li><p><strong>4、预测模型</strong></p></li><li><ul><li>4.1 回归分析法<ul><li>4.2 时间序列分析法</li><li>4.3 灰色预测法</li><li>4.4 BP神经网络法</li><li>4.5 支持向量机法</li><li>4.6 组合预测法</li></ul></li></ul></li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex的配置和使用</title>
    <link href="/2024/01/31/Latex%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/31/Latex%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Latex的配置和使用"><a href="#Latex的配置和使用" class="headerlink" title="Latex的配置和使用"></a>Latex的配置和使用</h2><p>👊 美赛将至，记录一下latex相关的，有坑有经验有方法</p><span id="more"></span><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="安装Tex-Live"><a href="#安装Tex-Live" class="headerlink" title="安装Tex Live"></a>安装Tex Live</h4><ul><li>直接去官网下载i<strong>so后缀的压缩包</strong>即可，或者镜像源下载，压缩包体积很大，需要耐心一点</li></ul><blockquote><p>注意！！！血泪教训！！！不要随意更改压缩包下载路径，<strong>压缩包就下在C盘里面</strong>，后面出现报错最后发现就是下到D盘导致的。配置过程还有什么问题可参考下面链接</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/412931055">texlive安装失败问题总结</a></p><ul><li>解压缩，解压路径随意了</li><li>双击后缀为bat的文件，为了节省空间可以只下载必要的语言和附带的工具，在advance-collection里面设置</li><li>点击安装，经历一个亿点点漫长的等待……success</li><li>正常情况没什么问题，我一波三折是因为前段时间马虎得把系统环境变量Path删了，修复之后今天安装成功</li></ul><h4 id="下载TeX编辑器"><a href="#下载TeX编辑器" class="headerlink" title="下载TeX编辑器"></a>下载TeX编辑器</h4><p>随意选择，按需使用咯</p><ul><li><strong>Texstudio</strong></li><li><strong>VSCode</strong></li><li><strong>Overleaf</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传播的智慧</title>
    <link href="/2024/01/28/%E4%BC%A0%E6%92%AD%E7%9A%84%E6%99%BA%E6%85%A7/"/>
    <url>/2024/01/28/%E4%BC%A0%E6%92%AD%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="《书写一张融合文化感，归属感和个性感的城市名片》"><a href="#《书写一张融合文化感，归属感和个性感的城市名片》" class="headerlink" title="《书写一张融合文化感，归属感和个性感的城市名片》"></a><em><strong>《书写一张融合文化感，归属感和个性感的城市名片》</strong></em></h3><p>​🎉<strong>传播的智慧结课论文~ 很喜欢的一篇作品啊，仿佛找回久违的高中的一丝文气</strong>🌼</p><span id="more"></span><p> <img src="/img/city6.png"></p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>在一张张丰富多彩的城市名片上，鄂尔多斯如黄河般奔腾，展现着绿色发展和金色传奇的中国现代古城魅力；海淀则以集艺术之大成的园林艺术、走在时代前沿的科技创新和领先教育为笔墨，勾勒出一幅引人流连徜徉的美好画卷；而武汉，有“百湖之市”这张靓丽的绿色名片，有“中国最具幸福感城市”这句响亮的口号，更有几年前疫情之下众志成城的“英雄城市”这个光荣的头衔，我们大武汉的形象愈加丰富多元，深入人心。</p><p>近几年，全国多所城市纷纷打造“一公里半径读书圈”，这是城市打造自己文化品牌的众多举措之一。还有社区图书馆、读书自助驿站、流动读书点、街道书屋陆续“上线”，更有最美夜市、建筑艺术馆，原生态民居、科技创新、传统文化等等目不暇接，各大城市都亮出了自己的文化名片。</p><p>城市形象是一个城市文化的外显，是能够激发人们思想感情活动的城市形态和特征。正如毕淑敏所言，城市是一粒粒精致的银扣，不分昼夜地熠熠闪光。一座城市有无限宝藏亟需我们去发掘，有无数色彩等待我们去描摹，所以一座城市应该给人留下什么样的记忆或印象？一座城市应该如何打造自己的名片？我想，一张融合文化感，归属感和个性感的城市名片是一个不错的答案。</p><p>  <img src="/img/city2.jpg"></p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>我国是拥有五千余年历史的文明古国，在不同的区域、不同的城市都有经典亦精彩的文化底蕴，它们在城市的风貌中灿烂闪烁、历久弥坚。南京的烟柳绿水秦淮河、北京的碧瓦皇墙四合院、苏州的小巧园林、西安的古都文化……这些都是我国厉史性代表城市別具一格的文化特色，它们也已成为这些城市不可磨灭的形象。</p><p>《城市文化》中有言，“城市是文化的容器”。只有立得住根，守得住魂，城市才能在岁月的风雨中成长，才能经得住时代发展任务的考验。</p><p>然而，近年来许多大体量的新建筑在各个城市拔地而起，“前城一面”的问题也更加严重，习总书记在上海考察时曾言：“城市历史文化遗存的是前人智慧的沉淀，是城市内涵、品质、特色的重要标志”。诚然，只有牢记漫漫历史积淀下来的文化底蕴，一座城才永远有迈步向前的厚实底气。</p><p><img src="/img/city3.jpg"></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>梭罗叹：“城市是一个几百万人一起孤独生活的地方。”然而城市也能以其特有的暖心之举，人文关怀，让生活在其中的人孤独尽失，爱意隆重。</p><p>面对严峻的冬季疫情防控形势，为了减少人员大规模流动，不少城市发出倡议：就地过年。各地相继启动暖心行动：图书馆举办年节特色活动，社区“一对一”指导年夜饭，对就地过年的人员实施奖励慰问，发放现金补贴……收到充满人文关怀的温暖名片，人们在这样的城市找到了归属感。</p><p>用人文情怀柔化一座城，用城市关怀温暖一群人，用众人之力书写城市名片。共情才能共鸣，共鸣才能同心，同心才能共振。当一座城市真正做到暖入人心，深入人心，这座城市的名片才有深度，有意义。</p><p> <img src="/img/wuhan1.jpg"></p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>近些年来，“网红城市”呈井喷状态，遍地开花。“网红城市”最大的“卖点”并非是多么宏大的山水风景，恰恰是在当地居民看来及其寻常的“细节”，彰显了城市个性。而随着当前短视频平台的兴起，或许你一个瞬间不经意的记录，就为你的城市名片添上独具匠心的一笔。</p><p>国家对外文化交流研究基地主任陈圣来说：“最理想的城市宣传，是由每个市民来进行。”以其最个性化的传播，逃离快速发展下同质化潮流的裹挟。</p><p>可以发现，人们对城市形象的感知，逐渐变为场景化，多元化的动态审美，在关注城市物质空间的同时，也注重城市与人的互动，以及个体的心理感受。这对于城市治理者非常具有启示意义，当外界用全新的眼光衡量这座城市的价值时，那么城市也要学会重新认识自己。一座城市只有依靠不断创新和改革，努力放大自己的特质，才可能在现代城市竞争中取胜。</p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>打造一个具有文化浓度，人情温度，时代深度的城市IP，任重而道远，需要城市和人民携手，文化与创意齐飞。众心成文，众志成城，书写出一张张融合文化感，归属感和个性感的城市名片，在于你，在于我，在于这个时代的每一个人。</p><p> <img src="/img/city4.png"></p>]]></content>
    
    
    <categories>
      
      <category>文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础知识</title>
    <link href="/2024/01/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/01/28/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><p>🤔 面向对象期末考试前三天速成Java大师</p><span id="more"></span><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><strong>局部变量</strong>  方法 语句块中</li><li><strong>成员变量</strong> 类中  方法外</li><li><strong>类变量&#x2F;静态变量</strong><ul><li>类中 方法外 </li><li>static</li><li>与类相关 不与实例相关</li></ul></li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在Java中，修饰符是用来修饰类、方法、变量以及其他数据类型的关键字。它们提供了额外的信息，用于控制访问级别、继承性、特定行为等。以下是一些常见的Java修饰符：</p><ol><li><p><strong>访问修饰符（Access Modifiers）：</strong></p><ul><li><code>public</code>: 公共的，可以被任何类访问。</li><li><code>protected</code>: 受保护的，可以被同一包内的类及其子类访问。</li><li><code>default</code> (包级别): 如果没有指定修饰符，默认为包级别，可以被同一包内的类访问。</li><li><code>private</code>: 私有的，只能在声明它的类内部访问。</li></ul></li><li><p><strong>非访问修饰符：</strong></p><ul><li><code>final</code>: 表示最终的，不可更改的。用于修饰类、方法、变量。</li><li><code>abstract</code>: 用于声明抽象类和抽象方法。</li><li><code>static</code>: 表示静态的，属于类而不是实例。用于方法、变量、代码块。</li><li><code>transient</code>: 用于标记不希望序列化的字段。</li><li><code>volatile</code>: 用于多线程编程，确保变量的可见性。</li></ul></li><li><p><strong>其他修饰符：</strong></p><ul><li><code>synchronized</code>: 用于多线程同步，修饰方法或代码块。</li><li><code>native</code>: 表示一个方法用其他编程语言（如C、C++）实现，通常与<code>JNI</code>（Java Native Interface）一起使用。</li><li><code>strictfp</code>: 用于确保浮点运算在不同平台上产生相同的结果。</li><li><code>default</code> (接口中): 用于指定接口中的默认方法实现。</li></ul></li><li><p><strong>注解修饰符：</strong></p><ul><li><code>@Override</code>: 表示该方法覆盖了父类的方法。</li><li><code>@Deprecated</code>: 表示该元素（类、方法等）已过时，不推荐使用。</li><li><code>@SuppressWarnings</code>: 抑制编译器警告。</li><li>其他自定义注解。</li></ul></li></ol><p>这些修饰符可以根据需要进行组合使用，以满足特定的编程需求。例如，一个方法可以同时使用<code>public</code>、<code>static</code>和<code>final</code>修饰符。</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li></ul><h3 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h3><h4 id="character类"><a href="#character类" class="headerlink" title="character类"></a>character类</h4><p>Java中的<code>Character</code>类是一个包装类，用于表示字符类型数据（Unicode字符）。它提供了许多用于处理字符的方法和常量。</p><p>以下是一些<code>Character</code>类的常用方法和常量：</p><ol><li><p>静态方法：</p><ul><li><code>isDigit(char ch)</code>：检查字符是否为数字字符。</li><li><code>isLetter(char ch)</code>：检查字符是否为字母字符。</li><li><code>isLetterOrDigit(char ch)</code>：检查字符是否为字母或数字字符。</li><li><code>isUpperCase(char ch)</code>：检查字符是否为大写字母。</li><li><code>isLowerCase(char ch)</code>：检查字符是否为小写字母。</li><li><code>toUpperCase(char ch)</code>：将字符转换为大写。</li><li><code>toLowerCase(char ch)</code>：将字符转换为小写。</li></ul></li><li><p>常量：</p><ul><li><code>MIN_VALUE</code>：<code>char</code>类型的最小值，即 <code>\u0000</code>。</li><li><code>MAX_VALUE</code>：<code>char</code>类型的最大值，即 <code>\uffff</code>。</li><li><code>MIN_RADIX</code>：进制的最小值，即 2。</li><li><code>MAX_RADIX</code>：进制的最大值，即 36。</li><li><code>SIZE</code>：<code>char</code>类型的位数，通常为 16。</li></ul></li></ol><p>下面是一个示例代码，演示了如何使用<code>Character</code>类的一些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br><br>        System.out.println(Character.isDigit(ch));  <span class="hljs-comment">// false</span><br>        System.out.println(Character.isLetter(ch));  <span class="hljs-comment">// true</span><br>        System.out.println(Character.isLetterOrDigit(ch));  <span class="hljs-comment">// true</span><br>        System.out.println(Character.isUpperCase(ch));  <span class="hljs-comment">// true</span><br>        System.out.println(Character.isLowerCase(ch));  <span class="hljs-comment">// false</span><br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">lowercaseCh</span> <span class="hljs-operator">=</span> Character.toLowerCase(ch);<br>        System.out.println(lowercaseCh);  <span class="hljs-comment">// &#x27;a&#x27;</span><br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">uppercaseCh</span> <span class="hljs-operator">=</span> Character.toUpperCase(ch);<br>        System.out.println(uppercaseCh);  <span class="hljs-comment">// &#x27;A&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h4><p>在Java中，<code>String</code>类是一个非常常用的类，用于表示和操作字符串。它是<strong>不可变（immutable）</strong>的，意味着一旦创建，就不能更改其内容。<code>String</code>类提供了许多方法来处理字符串，如下所示：</p><ol><li><p>创建字符串：</p><ul><li>使用双引号：<code>String str = &quot;Hello, World!&quot;;</code></li><li>使用<code>new</code>关键字：<code>String str = new String(&quot;Hello, World!&quot;);</code></li></ul></li><li><p>字符串长度：</p><ul><li><code>int length()</code>: 返回字符串的长度。</li></ul></li><li><p>字符串连接：</p><ul><li><code>String concat(String str)</code>: 将指定的字符串连接到原始字符串的末尾。</li><li>使用加号（+）运算符：<code>String result = str1 + str2;</code></li></ul></li><li><p>字符串提取：</p><ul><li><code>char charAt(int index)</code>: 返回指定索引位置的字符。</li><li><code>String substring(int beginIndex)</code>: 返回从指定索引开始到字符串末尾的子字符串。</li><li><code>String substring(int beginIndex, int endIndex)</code>: 返回从指定的开始索引到结束索引之间的子字符串（不包括结束索引）。</li></ul></li><li><p>字符串查找：</p><ul><li><code>int indexOf(String str)</code>: 返回指定字符串在原始字符串中第一次出现的索引。</li><li><code>int lastIndexOf(String str)</code>: 返回指定字符串在原始字符串中最后一次出现的索引。</li><li><code>boolean contains(CharSequence sequence)</code>: 检查原始字符串是否包含指定的字符序列。</li></ul></li><li><p>字符串替换：</p><ul><li><code>String replace(char oldChar, char newChar)</code>: 将原始字符串中的所有旧字符替换为新字符。</li><li><code>String replace(CharSequence target, CharSequence replacement)</code>: 将原始字符串中的所有目标字符序列替换为指定的替换字符序列。</li></ul></li><li><p>字符串拆分：</p><ul><li><code>String[] split(String regex)</code>: 使用给定的正则表达式将字符串拆分为子字符串数组。</li></ul></li><li><p>字符串转换：</p><ul><li><code>char[] toCharArray()</code>: 将字符串转换为字符数组。</li><li><code>byte[] getBytes()</code>: 将字符串转换为字节数组。</li><li><code>int parseInt(String str)</code>: 将字符串解析为整数。</li></ul></li><li><p>字符串比较：</p><ul><li><code>boolean equals(Object obj)</code>: 检查字符串是否与指定对象相等。</li><li><code>boolean equalsIgnoreCase(String anotherString)</code>: 检查字符串是否与指定字符串相等，忽略大小写。</li><li><code>int compareTo(String anotherString)</code>: 按字典顺序比较两个字符串。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> str.length();<br>        System.out.println(<span class="hljs-string">&quot;Length: &quot;</span> + length);  <span class="hljs-comment">// 13</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">concatStr</span> <span class="hljs-operator">=</span> str.concat(<span class="hljs-string">&quot; Welcome!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Concatenated String: &quot;</span> + concatStr);  <span class="hljs-comment">// Hello, World! Welcome!</span><br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">charAtIndex</span> <span class="hljs-operator">=</span> str.charAt(<span class="hljs-number">4</span>);<br>        System.out.println(<span class="hljs-string">&quot;Character at index 4: &quot;</span> + charAtIndex);  <span class="hljs-comment">// o</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">subString</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">7</span>);<br>        System.out.println(<span class="hljs-string">&quot;Substring from index 7: &quot;</span> + subString);  <span class="hljs-comment">// World!</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">indexOf</span> <span class="hljs-operator">=</span> str.indexOf(<span class="hljs-string">&quot;o&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;First index of &#x27;o&#x27;: &quot;</span> + indexOf);  <span class="hljs-comment">// 4</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">replacedStr</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Replaced String: &quot;</span> + replacedStr);  <span class="hljs-comment">// Hellx, Wxrld!</span><br><br>        String[] splitArray = str.split(<span class="hljs-string">&quot;,&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Split String:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String s : splitArray) &#123;<br>            System.out.println(s);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Output:</span><br><span class="hljs-comment">        Split String:</span><br><span class="hljs-comment">        Hello</span><br><span class="hljs-comment">         World!</span><br><span class="hljs-comment">        */</span><br><br>        <span class="hljs-type">char</span>[] charArray = str.toCharArray();<br>        System.out.println(<span class="hljs-string">&quot;Character Array:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : charArray) &#123;<br>            System.out.println(c);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        Output:</span><br><span class="hljs-comment">        Character Array:</span><br><span class="hljs-comment">        H</span><br><span class="hljs-comment">        e</span><br><span class="hljs-comment">        l</span><br><span class="hljs-comment">        l</span><br><span class="hljs-comment">        o</span><br><span class="hljs-comment">        ,</span><br><span class="hljs-comment">         </span><br><span class="hljs-comment">        W</span><br><span class="hljs-comment"></span><br></code></pre></td></tr></table></figure><h4 id="stringBuffer"><a href="#stringBuffer" class="headerlink" title="stringBuffer"></a>stringBuffer</h4><p>在Java中，<code>StringBuffer</code>类是一个<strong>可变的字符串类</strong>，用于处理可变字符串。与<code>String</code>类不同，<code>StringBuffer</code>类的内容可以修改。<code>StringBuffer</code>类提供了许多方法来对字符串进行修改和操作。</p><p>以下是<code>StringBuffer</code>类的一些常用方法：</p><ol><li><p>创建<code>StringBuffer</code>对象：</p><ul><li><code>StringBuffer sb = new StringBuffer();</code>：创建一个空的<code>StringBuffer</code>对象。</li><li><code>StringBuffer sb = new StringBuffer(&quot;Hello&quot;);</code>：使用指定的字符串创建一个<code>StringBuffer</code>对象。</li></ul></li><li><p>追加和插入操作：</p><ul><li><code>StringBuffer append(String str)</code>：在当前字符串的末尾追加指定的字符串。</li><li><code>StringBuffer insert(int offset, String str)</code>：在指定的偏移量位置插入指定的字符串。</li></ul></li><li><p>删除操作：</p><ul><li><code>StringBuffer delete(int start, int end)</code>：删除指定索引范围内的字符。</li><li><code>StringBuffer deleteCharAt(int index)</code>：删除指定索引位置的字符。</li></ul></li><li><p>修改操作：</p><ul><li><code>void setCharAt(int index, char ch)</code>：将指定索引位置的字符设置为给定字符。</li><li><code>void replace(int start, int end, String str)</code>：将指定索引范围内的字符替换为给定字符串。</li></ul></li><li><p>反转字符串：</p><ul><li><code>StringBuffer reverse()</code>：反转当前字符串。</li></ul></li><li><p>获取字符串长度：</p><ul><li><code>int length()</code>：返回当前字符串的长度。</li></ul></li><li><p>转换为字符串：</p><ul><li><code>String toString()</code>：将当前字符串缓冲区转换为<code>String</code>对象。</li></ul></li></ol><p>下面是一个示例代码，演示了如何使用<code>StringBuffer</code>类的一些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBufferExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><br>        sb.append(<span class="hljs-string">&quot;, World!&quot;</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello, World!</span><br><br>        sb.insert(<span class="hljs-number">5</span>, <span class="hljs-string">&quot; Java&quot;</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello Java, World!</span><br><br>        sb.delete(<span class="hljs-number">5</span>, <span class="hljs-number">9</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello, World!</span><br><br>        sb.setCharAt(<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;J&#x27;</span>);<br>        System.out.println(sb.toString());  <span class="hljs-comment">// Hello, Jorld!</span><br><br>        sb.reverse();<br>        System.out.println(sb.toString());  <span class="hljs-comment">// !dlroJ ,olleH</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> sb.length();<br>        System.out.println(<span class="hljs-string">&quot;Length: &quot;</span> + length);  <span class="hljs-comment">// 13</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们首先创建了一个<code>StringBuffer</code>对象<code>sb</code>，并使用其方法进行追加、插入、删除、修改和反转操作。最后，我们获取了字符串的长度并输出结果。</p><p>需要注意的是，<code>StringBuffer</code>类是线程安全的，适用于多线程环境。如果在单线程环境下使用，建议使用效率更高但线程不安全的<code>StringBuilder</code>类。</p><h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">private</span> String name;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        name = myName; <br>        id = myid;<br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123; <br>        System.out.println(name+<span class="hljs-string">&quot;正在吃&quot;</span>); <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(name+<span class="hljs-string">&quot;正在睡&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">introduction</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;大家好！我是&quot;</span>         + id + <span class="hljs-string">&quot;号&quot;</span> + name + <span class="hljs-string">&quot;.&quot;</span>); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Penguin</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        <span class="hljs-built_in">super</span>(myName, myid); <br>        <span class="hljs-comment">//可以用super()通过父类的公有方法（public 方法）来访问和设置 private 成员</span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Java 不支持多继承，但支持多重继承。</p></li><li><p>子类拥有父类非 private 的属性、方法。</p></li><li><p><strong>extends</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123; <br>    <span class="hljs-keyword">private</span> String name;   <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id; <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String myName, <span class="hljs-type">int</span> myid)</span> &#123; <br>        <span class="hljs-comment">//初始化属性值</span><br>    &#125; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//吃东西方法的具体实现  &#125; </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//睡觉方法的具体实现  &#125; </span><br>&#125; <br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>  <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Animal</span>&#123; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>implements</strong></li></ul><p>使用 implements 关键字可以<strong>变相</strong>的使java具有<strong>多继承</strong>的特性，使用范围为类继承接口的情况，可以<strong>同时继承多个接口</strong>（接口跟接口之间采用逗号分隔）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>super 和 this</strong><ul><li><strong>super</strong>关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</li><li><strong>this</strong>关键字：指向自己的引用。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;animal : eat&quot;</span>);<br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;dog : eat&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatTest</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.eat();   <span class="hljs-comment">// this 调用自己的方法</span><br>    <span class="hljs-built_in">super</span>.eat();  <span class="hljs-comment">// super 调用父类方法</span><br>  &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>    a.eat();<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    d.eatTest();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>final</strong></p><ul><li>使用 final 关键字声明类，就是把类定义定义为<strong>最终类</strong>，<strong>不能被继承</strong></li><li>或者用于<strong>修饰方法</strong>，该方法<strong>不能被子类重写</strong></li></ul></li><li><p><strong>构造器</strong></p><ul><li>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。</li><li>如果父类的构造器<strong>带有参数</strong>，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</li><li>如果父类构造器<strong>没有参数</strong>，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会<strong>自动调用父类的无参构造器</strong>。</li></ul></li></ul><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>在Java中，方法的重写是指子类定义了一个与其父类中方法<strong>签名相同</strong>（<strong>方法名、参数列表、返回类型相同</strong>）的方法。<strong>重写（Override）发生在继承关系中</strong>，子类通过<strong>重写父类的方法</strong>来提供自己的实现。这样做的主要目的是为了在子类中修改或扩展父类的行为。</p><p>以下是方法重写的基本规则：</p><ol><li><p><strong>方法签名：</strong> 重写的方法与父类方法具有相同的方法签名，包括方法名、参数列表和返回类型。</p></li><li><p><strong>访问修饰符：</strong> 重写的方法的访问修饰符不能比父类中被重写的方法的访问修饰符更严格。例如，如果父类中的方法是<code>public</code>，那么子类中的重写方法也必须是<code>public</code>。</p></li><li><p><strong>返回类型：</strong> 重写的方法的返回类型必须与被重写方法的返回类型相同或是其子类。</p></li><li><p><strong>抛出异常：</strong> 如果被重写的方法在父类中声明了异常，那么子类中重写的方法的声明异常不能超出父类方法声明的异常。子类可以不抛出异常或者只抛出父类方法声明的异常的子类。</p></li></ol><p>下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal makes a sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-comment">// 子类重写父类方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 子类可以新增其他方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fetch</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog fetches a ball&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        animal.makeSound();  <span class="hljs-comment">// 调用的是Dog类的makeSound()方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Dog</code> 类继承了 <code>Animal</code> 类，并重写了 <code>makeSound</code> 方法。在 <code>Main</code> 类中，创建了一个 <code>Dog</code> 对象，并通过 <code>Animal</code> 类型的引用调用了 <code>makeSound</code> 方法。这样的调用会执行 <code>Dog</code> 类中重写的方法，而不是 <code>Animal</code> 类中的原始方法。这就是多态的一种体现。</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>方法的<strong>重载（Overloading）</strong>是指在一个类中可以定义多个方法，这些方法具有<strong>相同的名字</strong>但具有<strong>不同的参数列表</strong>。在方法重载中，方法名相同，但<strong>参数类型、参数个数或者参数顺序不同</strong>。</p><p>重载的目的是提高代码的灵活性和可读性，使得开发者可以用一致的方式来命名不同版本的同一种操作。</p><p>以下是方法重载的基本规则：</p><ol><li>方法名必须相同。</li><li>参数列表必须不同，包括参数类型、参数个数或者参数顺序。</li><li>返回类型可以相同也可以不同。</li><li>可以有不同的访问修饰符。</li><li>重载方法可以声明新的或更广泛的检查异常。</li></ol><p>下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-comment">// 两个整数相加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-comment">// 三个整数相加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b + c;<br>    &#125;<br><br>    <span class="hljs-comment">// 两个浮点数相加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-comment">// 字符串连接</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">concatenate</span><span class="hljs-params">(String str1, String str2)</span> &#123;<br>        <span class="hljs-keyword">return</span> str1 + str2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Calculator</code> 类定义了多个名为 <code>add</code> 的方法，它们的参数列表分别为两个整数、三个整数和两个浮点数。这就是方法的重载。同样，还有一个 <code>concatenate</code> 方法，用于字符串连接，也是方法重载的一种形式。</p><p>调用这些方法时，编译器会根据实际参数的数量和类型来确定调用哪个版本的方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);          <span class="hljs-comment">// 调用两个整数相加的方法</span><br><span class="hljs-type">int</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>);      <span class="hljs-comment">// 调用三个整数相加的方法</span><br><span class="hljs-type">double</span> <span class="hljs-variable">result3</span> <span class="hljs-operator">=</span> calculator.add(<span class="hljs-number">5.5</span>, <span class="hljs-number">10.5</span>);   <span class="hljs-comment">// 调用两个浮点数相加的方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result4</span> <span class="hljs-operator">=</span> calculator.concatenate(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot; World&quot;</span>); <span class="hljs-comment">// 调用字符串连接的方法</span><br></code></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p><p>多态就是同一个接口，使用不同的实例而执行不同操作</p><ul><li><p><strong>必要条件</strong></p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<strong>Parent p &#x3D; new Child();</strong></li></ul></li><li><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，<strong>再去调用子类的同名方法</strong>。</p></li><li><p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在Java中，抽象类（Abstract Class）是一种特殊的类，<strong>它不能被实例化</strong>，用于提供其他类的共同抽象和部分实现，所以抽象类<strong>必须被继承，才能被使用</strong>。抽象类可以包含抽象方法和非抽象方法。</p><p>关键点和特征：</p><ol><li><p><strong>关键字 <code>abstract</code>：</strong> 抽象类使用关键字 <code>abstract</code> 声明。在抽象类中可以包含抽象方法和非抽象方法。抽象方法是没有具体实现的方法，需要在<strong>具体的子类中被实现</strong>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal sleeps&quot;</span>);  <span class="hljs-comment">// 非抽象方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>不能实例化：</strong> 由于抽象类包含抽象方法，不能被直接实例化。可以通过<strong>继承抽象类并提供抽象方法的实现来创建具体的子类</strong>。</p></li><li><p><strong>继承和实现：</strong> 子类继承自抽象类，可以选择性地实现抽象方法。如果子类是非抽象类，它必须提供所有抽象方法的具体实现；如果子类也是抽象类，可以选择性地实现抽象方法，或者继续将它标记为抽象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>可以有构造方法：</strong> 抽象类可以有构造方法，用于初始化抽象类的成员变量或执行其他初始化操作。子类在实例化时，会先调用父类的构造方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-type">int</span> age;<br><br>    Animal(<span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeSound</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>可以包含成员变量和非抽象方法：</strong> 除了抽象方法外，抽象类可以包含成员变量、非抽象方法、静态方法等。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-type">int</span> sides;<br><br>    Shape(<span class="hljs-type">int</span> sides) &#123;<br>        <span class="hljs-built_in">this</span>.sides = sides;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayInfo</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a shape with &quot;</span> + sides + <span class="hljs-string">&quot; sides.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateArea</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>抽象类用于建模一些通用的特征和行为，并要求具体的子类提供实际的实现。在继承层次结构中，抽象类为多态性提供了基础。</p><ul><li>\1. 抽象类不能被实例化(初学者很容易犯的错)，<strong>如果被实例化，就会报错</strong>，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>\2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>\3. 抽象类中的抽象方法只是声明，不包含方法体，就是<strong>不给出方法的具体实现</strong>也就是方法的具体功能。</li><li>\4. <strong>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</strong>。</li><li>\5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li><strong>修改属性的可见性</strong>来限制对属性的访问（一般限制为<strong>private</strong>）</li><li>对每个值属性提供对外的<strong>公共方法</strong>访问，也就是创建一对赋取值方法，用于<strong>对私有属性的访问</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 文件名: EncapTest.java */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncapTest</span>&#123;<br> <br>   <span class="hljs-keyword">private</span> String name;<br>   <span class="hljs-keyword">private</span> String idNum;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> age;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> name;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIdNum</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-keyword">return</span> idNum;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">( <span class="hljs-type">int</span> newAge)</span>&#123;<br>      age = newAge;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String newName)</span>&#123;<br>      name = newName;<br>   &#125;<br> <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setIdNum</span><span class="hljs-params">( String newId)</span>&#123;<br>      idNum = newId;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在Java中，接口（Interface）是一种抽象类型，用于定义一组抽象方法的集合，而不包含具体的实现。接口提供了一种将类与类之间以及类与接口之间进行关联的机制，支持多继承和规范化的设计。</p><p>以下是Java接口的主要特点和用法：</p><ol><li><p><strong>定义接口：</strong> 使用 <code>interface</code> 关键字来声明接口。接口中的方法<strong>默认是抽象的，不包含方法体</strong>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>实现接口：</strong> 通过 <code>implements</code> 关键字，<strong>一个类可以实现一个或多个接口</strong>。<strong>实现接口的类必须提供接口中所有抽象方法的具体实现</strong>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing MyInterface&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>多继承：</strong> 一个类可以实现多个接口，从而达到<strong>多继承</strong>的效果。这是Java中实现多继承的一种方式。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceB</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceA</span>, InterfaceB &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing InterfaceA&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing InterfaceB&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>接口的默认方法和静态方法：</strong> Java 8 引入了接口的默认方法和静态方法，使得接口可以包含具体的方法实现。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 抽象方法</span><br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Default method in interface&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static method in interface&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在实现类中，<strong>可以选择性地重写抽象方法</strong>，并可以直接使用默认方法和静态方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Implementing MyInterface&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 不重写 defaultMethod，使用默认实现</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        myObject.myMethod();<br>        myObject.defaultMethod();<br>        MyInterface.staticMethod();<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>接口的继承：</strong> 一个接口可以继承另一个接口，通过 <strong><code>extends</code></strong> 关键字。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InterfaceA</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在Java中，枚举（Enum）是一种特殊的数据类型，用于定义包含固定常量值的有限集合。枚举类型在Java中是一种引用数据类型，它可以包含字段、方法和构造方法。</p><p>以下是Java中枚举的基本用法和特点：</p><ol><li><p><strong>定义枚举：</strong> 使用 <code>enum</code> 关键字来定义枚举类型。枚举中的每个值都是枚举类型的一个实例。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY<br>&#125;<br></code></pre></td></tr></table></figure><p> 在上面的例子中，<code>Day</code> 枚举包含七个实例，分别代表星期的每一天。</p></li><li><p><strong>枚举常量：</strong> 枚举的每个值被称为枚举常量。在上面的例子中，<code>SUNDAY</code>、<code>MONDAY</code> 等就是枚举常量。</p></li><li><p><strong>访问枚举常量：</strong> 枚举常量可以通过枚举类型的名称访问。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">today</span> <span class="hljs-operator">=</span> Day.MONDAY;<br></code></pre></td></tr></table></figure></li><li><p><strong>枚举可以有字段、方法和构造方法：</strong> 与普通类一样，枚举可以包含字段、方法和构造方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    SUNDAY(<span class="hljs-string">&quot;Sun&quot;</span>), MONDAY(<span class="hljs-string">&quot;Mon&quot;</span>), TUESDAY(<span class="hljs-string">&quot;Tue&quot;</span>), WEDNESDAY(<span class="hljs-string">&quot;Wed&quot;</span>),<br>    THURSDAY(<span class="hljs-string">&quot;Thu&quot;</span>), FRIDAY(<span class="hljs-string">&quot;Fri&quot;</span>), SATURDAY(<span class="hljs-string">&quot;Sat&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String abbreviation;<br><br>    Day(String abbreviation) &#123;<br>        <span class="hljs-built_in">this</span>.abbreviation = abbreviation;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAbbreviation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> abbreviation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在这个例子中，<code>Day</code> 枚举包含了一个字段 <code>abbreviation</code>，一个构造方法和一个获取缩写的方法。</p></li><li><p><strong>枚举的比较：</strong> 枚举常量之间可以使用 <code>==</code> 运算符进行比较。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">day1</span> <span class="hljs-operator">=</span> Day.MONDAY;<br><span class="hljs-type">Day</span> <span class="hljs-variable">day2</span> <span class="hljs-operator">=</span> Day.MONDAY;<br><br><span class="hljs-keyword">if</span> (day1 == day2) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Both are the same day&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>switch语句和枚举：</strong> 枚举类型特别适合在 <code>switch</code> 语句中使用，因为它可以列举所有可能的情况。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Day</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> Day.MONDAY;<br><br><span class="hljs-keyword">switch</span> (day) &#123;<br>    <span class="hljs-keyword">case</span> MONDAY:<br>        System.out.println(<span class="hljs-string">&quot;It&#x27;s Monday&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> TUESDAY:<br>        System.out.println(<span class="hljs-string">&quot;It&#x27;s Tuesday&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// 其他情况...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型（Generics）是Java语言中的一个重要特性，它允许<strong>在类、接口和方法的定义中使用一个或多个类型参数</strong>，以实现代码的重用和类型安全性。</p><p>通过使用泛型，可以编写通用的代码，可以在不指定具体类型的情况下定义类、接口或方法。这使得代码可以<strong>适用于不同类型的数据</strong>，提高了代码的灵活性和可重用性。</p><p>泛型的主要目的是在<strong>编译时执行类型检查，以避免在运行时出现类型转换错误</strong>。它提供了类型安全性，可以在编译时捕获和修复类型错误，而不是在运行时抛出异常。</p><p>使用泛型的常见场景包括：</p><ol><li><p><strong>泛型类（Generic Class）</strong>：定义一个类时，可以使用泛型来表示其中的一个或多个类型参数。例如，<code>ArrayList&lt;T&gt;</code> 是一个泛型类，可以在创建对象时指定具体的类型参数，如 <code>ArrayList&lt;String&gt;</code>。</p></li><li><p><strong>泛型接口（Generic Interface）</strong>：类似于泛型类，泛型接口允许在接口中使用类型参数。例如，<code>List&lt;T&gt;</code> 是一个泛型接口，可以在实现接口时指定具体的类型参数。</p></li><li><p><strong>泛型方法（Generic Method）</strong>：在方法的定义中使用泛型类型参数。这允许方法在调用时接受不同类型的参数，并且可以在方法内部使用泛型类型进行操作。例如，<code>&lt;T&gt; T getFirst(List&lt;T&gt; list)</code> 是一个泛型方法，可以返回列表中的第一个元素，并且可以适用于不同类型的列表。</p></li></ol><p>泛型的好处包括：</p><ol><li><p><strong>类型安全性</strong>：泛型提供了编译时的类型检查，可以在编译时捕获类型错误，避免在运行时出现类型转换错误。</p></li><li><p><strong>代码重用</strong>：通过使用泛型，可以编写通用的代码，可以适用于不同类型的数据，提高了代码的灵活性和可重用性。</p></li><li><p><strong>代码简洁性</strong>：使用泛型可以减少手动的类型转换代码，使代码更加简洁和易读。</p></li></ol><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>一个包内的类可以互相访问，即它们之间的访问级别是包级别（默认级别）。在Java中，默认情况下，如果没有明确指定访问修饰符，类、方法和变量的访问级别就是包级别。</p><p>这意味着同一包内的类可以相互访问彼此的包级别成员。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 com.example.myapp 包中的 MyClass.java 文件</span><br><span class="hljs-keyword">package</span> com.example.myapp;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-comment">// 包级别的成员变量</span><br>    <span class="hljs-type">int</span> packageLevelVariable;<br><br>    <span class="hljs-comment">// 包级别的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">packageLevelMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 可以访问同一包内的其他类的包级别成员</span><br>        <span class="hljs-type">AnotherClass</span> <span class="hljs-variable">anotherClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnotherClass</span>();<br>        anotherClass.anotherClassMethod();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 com.example.myapp 包中的 AnotherClass.java 文件</span><br><span class="hljs-keyword">package</span> com.example.myapp;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;<br>    <span class="hljs-comment">// 包级别的成员变量</span><br>    <span class="hljs-type">int</span> anotherClassVariable;<br><br>    <span class="hljs-comment">// 包级别的方法</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">anotherClassMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 可以访问同一包内的其他类的包级别成员</span><br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        System.out.println(myClass.packageLevelVariable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>MyClass</code>和<code>AnotherClass</code>都位于<code>com.example.myapp</code>包内，因此它们可以访问对方的包级别成员。</p><h2 id="Java数据结构"><a href="#Java数据结构" class="headerlink" title="Java数据结构"></a>Java数据结构</h2><p>Java提供了丰富的数据结构和集合类库，这些类库位于<code>java.util</code>包下。以下是Java中一些常用的数据结构和集合：</p><ol><li><p><strong>ArrayList：</strong> 动态数组，可以根据需要动态增长或缩小的数组。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br>ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>list.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>LinkedList：</strong> 双向链表，支持快速的插入和删除操作。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br>LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>linkedList.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>HashMap：</strong> 键值对的散列表实现，提供快速的查找和插入。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><br>HashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>HashSet：</strong> 基于HashMap的集合，不允许重复元素。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><br>HashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>set.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>set.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>TreeMap：</strong> 基于红黑树的有序映射，按照键的自然顺序或自定义顺序排序。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br>TreeMap&lt;String, Integer&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>treeMap.put(<span class="hljs-string">&quot;Key 1&quot;</span>, <span class="hljs-number">1</span>);<br>treeMap.put(<span class="hljs-string">&quot;Key 2&quot;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>TreeSet：</strong> 基于TreeMap的有序集合，不允许重复元素。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br>TreeSet&lt;String&gt; treeSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>treeSet.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>treeSet.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>Queue接口和LinkedList：</strong> 队列的实现，通常用于先进先出（FIFO）的场景。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br>Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>queue.add(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>queue.add(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>Stack：</strong> 栈的实现，通常用于后进先出（LIFO）的场景。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br>Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>stack.push(<span class="hljs-string">&quot;Item 1&quot;</span>);<br>stack.push(<span class="hljs-string">&quot;Item 2&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><strong>PriorityQueue：</strong> 优先队列，基于堆实现，可以按照元素的优先级进行排序。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br>PriorityQueue&lt;Integer&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>priorityQueue.add(<span class="hljs-number">3</span>);<br>priorityQueue.add(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p>Java集合框架提供了一套强大且灵活的数据结构和算法，用于存储、检索、操作和处理集合数据。这个框架包含了一系列的接口、实现类和算法，主要位于<code>java.util</code>包中。以下是Java集合框架的主要部分：</p><ul><li><strong>接口（Interfaces）：</strong></li></ul><ol><li><strong>Collection接口：</strong> 是集合框架的根接口，表示<strong>一组对象的集合</strong>。<code>List</code>、<code>Set</code> 和 <code>Queue</code> 都继承自 <code>Collection</code> 接口。</li></ol><ul><li><code>List</code>：有序的集合，允许重复元素。常用实现类有 <code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code>。<ul><li><code>Set</code>：不允许重复元素的集合。常用实现类有 <code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code>。</li><li><code>Queue</code>：代表一组元素的队列，通常用于实现先进先出（FIFO）的数据结构。常用实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。</li></ul></li></ul><ol start="2"><li><strong>Map接口：</strong> 表示<strong>键值对的集合</strong>，每个键都映射到一个值。常用实现类有 <code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>。</li></ol><ul><li><strong>实现类（Classes）：</strong></li></ul><ol><li><p><strong>List接口的实现类：</strong></p><ul><li><code>ArrayList</code>：动态数组实现，支持随机访问，适用于快速查找和遍历。</li><li><code>LinkedList</code>：双向链表实现，支持快速插入和删除，适用于频繁操作集合元素的场景。</li><li><code>Vector</code>：类似于 <code>ArrayList</code>，但是是线程安全的。</li></ul></li><li><p><strong>Set接口的实现类：</strong></p><ul><li><code>HashSet</code>：基于哈希表实现，不保证顺序。</li><li><code>LinkedHashSet</code>：基于哈希表和链表实现，按照元素插入顺序保证顺序。</li><li><code>TreeSet</code>：基于红黑树实现，按照元素的自然顺序或自定义顺序排序。</li></ul></li><li><p><strong>Queue接口的实现类：</strong></p><ul><li><code>LinkedList</code>：实现了 <code>Queue</code> 接口，可用于实现队列。</li></ul></li><li><p><strong>Map接口的实现类：</strong></p><ul><li><code>HashMap</code>：基于哈希表实现，键值对无序。</li><li><code>LinkedHashMap</code>：基于哈希表和链表实现，按照键值对插入顺序保证顺序。</li><li><code>TreeMap</code>：基于红黑树实现，按照键的自然顺序或自定义顺序排序。</li></ul></li><li><p><strong>其他常用类：</strong></p><ul><li><code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code> 等都实现了 <code>Set</code> 接口。</li><li><code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code> 等都实现了 <code>Map</code> 接口。</li></ul></li></ol><ul><li><p><strong>工具类（Utilities）：</strong></p><ul><li><strong>Collections类：</strong> 提供了一系列静态方法，用于对集合进行操作和算法处理，如排序、反转、洗牌等。</li><li><strong>Arrays类：</strong> 提供了一系列静态方法，用于操作数组，如排序、二分查找等。</li></ul></li><li><p><strong>并发集合（Concurrent Collections）：</strong></p><ul><li><code>ConcurrentHashMap</code>：线程安全的哈希表实现。</li><li><code>CopyOnWriteArrayList</code>：线程安全的动态数组实现，适用于读多写少的场景。</li><li><code>CopyOnWriteArraySet</code>：线程安全的集合，基于 <code>CopyOnWriteArrayList</code> 实现。</li></ul></li></ul><h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><p>在Java中，线程相关的操作和指令主要涉及到以下方面：</p><ol><li><p><strong>创建线程：</strong></p><ul><li><p>使用 <code>Thread</code> 类或实现 <code>Runnable</code> 接口创建线程。</p></li><li><p>例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>线程调度和控制：</strong></p><ul><li><code>Thread.sleep(long millis)</code>：使当前线程休眠指定的毫秒数。</li><li><code>Thread.yield()</code>：暂停当前正在执行的线程，允许其他线程执行。</li><li><code>join()</code>：等待一个线程终止。</li><li><code>interrupt()</code>：中断线程的执行。</li></ul></li><li><p><strong>同步和互斥：</strong></p><ul><li><code>synchronized</code> 关键字：用于同步代码块或方法，确保在同一时刻只有一个线程可以访问。</li><li><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>：在对象上进行等待和唤醒其他线程的操作，通常与<code>synchronized</code>一起使用。</li></ul></li><li><p><strong>线程状态控制：</strong></p><ul><li><code>getState()</code>：获取线程的状态。</li><li><code>isAlive()</code>：判断线程是否处于活动状态。</li></ul></li><li><p><strong>并发集合和工具类：</strong></p></li></ol><ul><li><code>java.util.concurrent</code> 包提供了一些并发集合和工具类，如 <code>ConcurrentHashMap</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code> 等，用于更方便地进行多线程编程。</li></ul><ol start="6"><li><strong>线程池：</strong></li></ol><ul><li><code>ExecutorService</code> 和 <code>ThreadPoolExecutor</code> 等类用于管理线程池，提高线程的复用性和效率。</li></ul><ol start="7"><li><strong>原子操作和CAS（Compare and Swap）：</strong></li></ol><ul><li><code>java.util.concurrent.atomic</code> 包提供了一系列原子操作类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等，用于在多线程环境中执行原子操作。</li></ul><ol start="8"><li><p><strong>并行流：</strong></p><ul><li>Java 8 引入的并行流框架允许在多个线程上同时处理流的元素。</li></ul></li></ol><p>这些指令和类库提供了Java中进行多线程编程的基本工具和机制。在编写多线程代码时，要注意线程安全性、死锁和性能等问题，以确保程序的正确性和效率。</p><p>这几个方法的具体用法如下：</p><ol><li><p><strong>Thread.sleep(long millis)：</strong></p><ul><li><p>使当前线程休眠指定的毫秒数，进入阻塞状态。</p></li><li><p>用法示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 休眠1秒</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Thread.yield()：</strong></p><ul><li><p>暂停当前正在执行的线程，允许其他线程执行。</p></li><li><p><code>yield</code> 是一个静态方法，通过调用 <code>Thread.yield()</code> 可以提示调度器当前线程愿意让出CPU资源。</p></li><li><p>用法示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// 暂停当前线程，让出CPU资源</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>join()：</strong></p><ul><li><p>等待一个线程终止，即等待被调用 <code>join</code> 方法的线程执行完毕。</p></li><li><p>用法示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 线程执行的逻辑</span><br>&#125;);<br>thread.start();<br><span class="hljs-keyword">try</span> &#123;<br>    thread.join(); <span class="hljs-comment">// 主线程等待 thread 线程执行完毕</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>interrupt()：</strong></p><ul><li><p>中断线程的执行，给线程发送中断信号。</p></li><li><p>被中断的线程需要通过检查 <code>Thread.interrupted()</code> 或 <code>isInterrupted()</code> 方法来判断是否被中断，并做相应处理。</p></li><li><p>用法示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>        <span class="hljs-comment">// 线程执行的逻辑</span><br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;线程被中断&quot;</span>);<br>&#125;);<br>myThread.start();<br><br><span class="hljs-comment">// 在其他地方中断线程</span><br>myThread.interrupt();<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>一些关键字和方法主要用于实现线程之间的协调和同步，确保多个线程能够安全地共享资源。以下是它们的具体用法：</p><ol><li><p><strong>synchronized 关键字：</strong></p><ul><li><p>用于同步代码块或方法，确保在同一时刻只有一个线程可以访问被 synchronized 修饰的代码块或方法。</p></li><li><p>对象级别的同步：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 同步的代码块或方法</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>代码块级别的同步：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">someMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>        <span class="hljs-comment">// 同步的代码块</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>wait()、notify()、notifyAll()：</strong></p><ul><li><p>这些方法通常与 synchronized 一起使用，用于实现线程之间的协调和通信。</p></li><li><p><code>wait()</code>：使当前线程进入等待状态，并释放对象锁，直到其他线程调用相同对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法唤醒它。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lockObject.wait(); <span class="hljs-comment">// 等待其他线程唤醒</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>notify()</code>：唤醒在相同对象上等待的一个线程。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    lockObject.notify(); <span class="hljs-comment">// 唤醒一个等待线程</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>notifyAll()</code>：唤醒在相同对象上等待的所有线程。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lockObject) &#123;<br>    lockObject.notifyAll(); <span class="hljs-comment">// 唤醒所有等待线程</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><p>这些机制可以帮助线程之间进行协同工作，避免竞争条件和确保资源的正确共享。需要注意的是，使用 wait()、notify()、notifyAll() 时，必须在同步块或同步方法中调用，否则会抛出 <code>IllegalMonitorStateException</code> 异常。</p><h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I&#x2F;O"></a>Java I&#x2F;O</h2><p>在Java中，流（Stream）是用于处理输入和输出（I&#x2F;O）操作的重要概念。流主要分为输入流和输出流，它们分别用于从外部数据源读取数据和将数据写入到外部目标。</p><p>以下是Java流的一些关键概念和总结：</p><ol><li><p><strong>输入流和输出流：</strong></p><ul><li><strong>输入流（InputStream）：</strong> 用于从外部数据源（例如文件、网络、内存等）读取数据。</li><li><strong>输出流（OutputStream）：</strong> 用于向外部目标（例如文件、网络、内存等）写入数据。</li></ul></li><li><p><strong>字节流和字符流：</strong></p><ul><li><strong>字节流：</strong> 处理字节数据，主要用于处理二进制文件。例如，<code>FileInputStream</code>和<code>FileOutputStream</code>。</li><li><strong>字符流：</strong> 处理字符数据，适用于文本文件。例如，<code>FileReader</code>和<code>FileWriter</code>。字符流使用了字符集，可以更好地处理文本文件中的字符编码。</li></ul></li><li><p><strong>节点流和包装流：</strong></p><ul><li><strong>节点流：</strong> 直接连接到数据源或目标的流。例如，<code>FileInputStream</code>和<code>FileOutputStream</code>。</li><li><strong>包装流（或处理流）：</strong> 对节点流进行包装，提供额外的功能，如缓冲、压缩、解压等。例如，<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>。</li></ul></li><li><p><strong>字符集和编码：</strong></p><ul><li>字符流使用字符集来处理字符编码，以确保正确的字符转换。</li><li>常见的字符集包括UTF-8、UTF-16、ISO-8859-1等。</li></ul></li><li><p><strong>处理流的装饰器模式：</strong></p><ul><li>处理流通常通过装饰器模式实现。你可以通过组合多个处理流，以获得更丰富的功能。</li></ul></li><li><p><strong>对象流：</strong></p><ul><li><code>ObjectInputStream</code>和<code>ObjectOutputStream</code>允许直接读写Java对象。这对于序列化和反序列化对象很有用。</li></ul></li><li><p><strong>标准I&#x2F;O：</strong></p><ul><li><code>System.in</code>、<code>System.out</code>和<code>System.err</code>分别代表标准输入、标准输出和标准错误输出。这些流通常用于从控制台读取输入和输出结果。</li></ul></li><li><p><strong>try-with-resources：</strong></p><ul><li>Java 7引入了<code>try-with-resources</code>语句，使得资源的管理更加简便。可以在<code>try</code>语句中自动关闭实现<code>AutoCloseable</code>接口的资源。</li></ul></li></ol><h2 id="Java错误和异常"><a href="#Java错误和异常" class="headerlink" title="Java错误和异常"></a>Java错误和异常</h2><p>在 Java 中，错误（Errors）和异常（Exceptions）是用于处理程序运行期间出现的问题的机制。它们都是从 <code>Throwable</code> 类派生的，但在处理方式和用途上有所区别。下面是对 Java 错误和异常的总结：</p><ol><li><p><strong>错误（Errors）</strong>：</p><ul><li>错误表示严重的问题，通常是无法恢复的情况，例如虚拟机错误、系统错误、内存溢出等。</li><li>错误由 JVM 抛出，并且一般<strong>不应该被程序捕获和处理</strong>。</li><li><code>Error</code> 类及其子类是用于表示错误的类型，例如 <code>OutOfMemoryError</code>、<code>StackOverflowError</code> 等。</li></ul></li><li><p><strong>异常（Exceptions）</strong>：</p><ul><li>异常是程序在运行过程中遇到的非正常情况，<strong>可以被捕获和处理</strong>，以便程序继续执行。</li><li>异常分为两种类型：<strong>已检查异常</strong>（Checked Exceptions）和<strong>运行时异常</strong>（Unchecked Exceptions）。</li><li>已检查异常是在编译时强制要求处理的异常，例如 <code>IOException</code>、<code>SQLException</code> 等。对于已检查异常，要么在方法中使用 <code>throws</code> 声明抛出，要么使用 <code>try-catch</code> 块进行捕获和处理。</li><li>运行时异常是指那些可以在运行时检测到的异常，不需要在编译时进行处理。例如，<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code> 等。通常情况下，运行时异常是由程序错误导致的，应该尽量避免发生，但并不强制要求捕获和处理。</li></ul></li></ol><p>在处理异常时，可以使用以下几种关键字和机制：</p><ul><li><code>try-catch</code> 块：用于捕获和处理异常。<code>try</code> 块中放置可能抛出异常的代码，而 <code>catch</code> 块用于捕获和处理对应的异常类型。</li><li><code>throws</code> 关键字：用于在方法签名中声明可能抛出的异常类型，将异常传递给调用者处理。</li><li><code>finally</code> 块：在 <code>try-catch</code> 块之后使用，用于执行无论是否发生异常都需要执行的代码块，例如资源的释放。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础知识</title>
    <link href="/2024/01/28/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/01/28/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="初识Linux"><a href="#初识Linux" class="headerlink" title="初识Linux"></a>初识Linux</h1><p>🍾 基础知识笔记一篇~ 加入联创的第0期新人任务就是安装并使用archlinux~ 🙋‍包括常用文件操作命令、文件权限、进程等知识点</p><span id="more"></span><h2 id="常用文件操作命令"><a href="#常用文件操作命令" class="headerlink" title="常用文件操作命令"></a>常用文件操作命令</h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a><strong>cd</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 目录<br></code></pre></td></tr></table></figure><ul><li>切换用户当前工作目录</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span>    <span class="hljs-comment"># 进入用户主目录；</span><br><span class="hljs-keyword">cd</span> /  <span class="hljs-comment"># 进入根目录</span><br><span class="hljs-keyword">cd</span> ~  <span class="hljs-comment"># 进入用户主目录；</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span>  <span class="hljs-comment"># 返回上级目录（若当前目录为“/“，则执行完后还在“/&quot;；&quot;..&quot;为上级目录的意思）；</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">../..</span>  <span class="hljs-comment"># 返回上两级目录；</span><br></code></pre></td></tr></table></figure><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a><strong>ls</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> 选项 目录<br></code></pre></td></tr></table></figure><ul><li><code>ls</code>就是list的缩写，用来显示目标列表</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-a: 显示所有文件，包括隐藏文件</span><br><span class="hljs-deletion">-l: 详细信息显示</span><br><span class="hljs-deletion">-h: 人性化显示，文件大小以B、K、M显示</span><br><span class="hljs-deletion">-i: 显示Linux对于每个文件的id</span><br><span class="hljs-deletion">-t: 按时间信息排序</span><br><span class="hljs-deletion">-d: 显示目录属性</span><br></code></pre></td></tr></table></figure><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 组合使用多个命令</span><br>[root<span class="hljs-symbol">@VM</span><span class="hljs-number">-0</span><span class="hljs-number">-5</span>-centos redis<span class="hljs-number">-6.2</span><span class="hljs-number">.4</span>]<span class="hljs-meta"># ls -alhit</span><br></code></pre></td></tr></table></figure><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><strong>mkdir</strong></h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir 选项 目录<br></code></pre></td></tr></table></figure><ul><li>用来创建目录</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-m: 建立目录的同时设置目录的权限</span><br><span class="hljs-deletion">-p: 若所要建立目录的上层目录目前尚未建立，则会一并建立上层目录</span><br></code></pre></td></tr></table></figure><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">rmdir 选项 目录<br></code></pre></td></tr></table></figure><ul><li>删除空目录</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">-<span class="hljs-selector-tag">p</span>：删除指定目录后，若该目录的上层目录已变成空目录，则将其一并删除；<br></code></pre></td></tr></table></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> 选项 文件<br></code></pre></td></tr></table></figure><ul><li>创建新的空文件</li></ul><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> 选项 文件<br></code></pre></td></tr></table></figure><ul><li>删除文件或目录</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f：强制删除，没有提示是否确认删除</span><br><span class="hljs-deletion">-r：递归删除，在删除目录时使用</span><br><span class="hljs-deletion">-i：删除已有文件或目录之前先询问用户</span><br></code></pre></td></tr></table></figure><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">cp</span> 选项 原文件或目录 目标文件或目录<br></code></pre></td></tr></table></figure><ul><li>将原文件或目录复制到目标文件或目录中</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-r 递归复制，用于复制目录</span><br><span class="hljs-deletion">-p 保留原有文件属性</span><br></code></pre></td></tr></table></figure><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> 原文件或目录 目标文件或目录<br></code></pre></td></tr></table></figure><ul><li>移动文件或者重命名</li></ul><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> 选项 文件<br></code></pre></td></tr></table></figure><ul><li>显示文件内容</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-n 显示行号</span><br></code></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">more</span> 文件名<br></code></pre></td></tr></table></figure><ul><li>分页显示文件内容</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">运行命令进入查看页面后，可以进行如下操作：<br><br>空格 或 f：向下翻页<br><span class="hljs-selector-tag">b</span>：向上翻页<br>Enter：换行<br><span class="hljs-selector-tag">q</span>或<span class="hljs-selector-tag">Q</span>：退出<br></code></pre></td></tr></table></figure><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> 选项 文件名<br></code></pre></td></tr></table></figure><ul><li>显示文件前几行，默认显示前10行</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-n：指定显示行数</span><br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">find <span class="hljs-selector-attr">[path]</span> <span class="hljs-selector-attr">[expression]</span><br></code></pre></td></tr></table></figure><p><strong>常用的expression:</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">-name pattern：按文件名查找，支持使用通配符 * 和 ?。<br>-<span class="hljs-keyword">type</span> <span class="hljs-keyword">type</span>：按文件类型查找，可以是 f（普通文件）、d（目录）、l（符号链接）等。<br>-size [+-]size[cwbkMG]：按文件大小查找，支持使用 + 或 - 表示大于或小于指定大小，单位可以是 c（字节）、w（字数）、b（块数）、k（KB）、M（MB）或 G（GB）。<br>-mtime days：按修改时间查找，支持使用 + 或 - 表示在指定天数前或后，days 是一个整数表示天数。<br>-<span class="hljs-keyword">user</span> <span class="hljs-title">username</span>：按文件所有者查找。<br>-<span class="hljs-keyword">group</span> <span class="hljs-title">groupname</span>：按文件所属组查找<br></code></pre></td></tr></table></figure><h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li>读取（r）： 允许查看文件内容，显示目录列表</li><li>写入（w）： 允许修改文件内容，允许在目录中新建、删除、移动文件或者子目录</li><li>可执行（x）： 允许运行程序，切换目录</li><li>无权限（-）： 没有权限</li></ul><p>在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为 <strong>d</strong> 则是目录</li><li>当为 <strong>-</strong> 则是文件；</li><li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li><li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><p>接下来的字符中，以三个为一组，且均为 <strong>rwx</strong> 的三个参数的组合。其中， <strong>r</strong> 代表可读(read)、 <strong>w</strong> 代表可写(write)、 <strong>x</strong> 代表可执行(execute)。如果用 <strong>-</strong> 字符表示，则没有执行权限</p><p><img src="/img/linux2.jpg" alt="文件权限"></p><h3 id="文件属主与属组"><a href="#文件属主与属组" class="headerlink" title="文件属主与属组"></a>文件属主与属组</h3><ul><li><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p></li><li><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p></li><li><p>文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。</p></li><li><p>Linux系统按<strong>文件所有者</strong>、<strong>文件所有者同组用户</strong>和<strong>其他用户</strong>来规定了不同的文件访问权限。</p></li></ul><h3 id="更改文件属性"><a href="#更改文件属性" class="headerlink" title="更改文件属性"></a>更改文件属性</h3><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><ul><li><strong>更改文件属组</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chgrp</span> [-R] 属组名 文件名<br></code></pre></td></tr></table></figure><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><ul><li><p><strong>change owner 修改所属用户与组</strong></p></li><li><p><strong>更改文件属主，也可以同时更改文件属组</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> [–R] 属主名 文件名<br><span class="hljs-built_in">chown</span> [-R] 属主名：属组名 文件名<br></code></pre></td></tr></table></figure><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><ul><li><p><strong>change mode 修改用户的权限</strong></p></li><li><p><strong>更改文件9个属性</strong></p></li></ul><p>各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [-R] xyz 文件或目录<br></code></pre></td></tr></table></figure><ul><li><strong>xyz</strong> : 就是刚刚提到的数字类型的权限属性，为 <strong>rwx</strong> 属性数值的相加。</li><li><strong>-R</strong> : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更</li></ul><h2 id="Linux进程"><a href="#Linux进程" class="headerlink" title="Linux进程"></a>Linux进程</h2><p>**进程(process)**是指正在执行的程序；是程序正在运行的一个实例。它由程序指令，和从文件、其它程序中读取的数据或系统用户的输入组成</p><h3 id="进程的类型"><a href="#进程的类型" class="headerlink" title="进程的类型"></a>进程的类型</h3><ul><li><strong>前台进程</strong>（也称为<strong>交互式进程</strong>） - 这些进程由终端会话初始化和控制。换句话说，需要有一个连接到系统中的用户来启动这样的进程；它们不是作为系统功能&#x2F;服务的一部分自动启动。</li><li><strong>后台进程</strong>（也称为<strong>非交互式&#x2F;自动进程</strong>） - 这些进程没有连接到终端；它们不需要任何用户输入。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2024/01/28/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2024/01/28/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="flex布局-全面且简洁"><a href="#flex布局-全面且简洁" class="headerlink" title="flex布局 | 全面且简洁"></a>flex布局 | 全面且简洁</h2><p>💡常用但常忘的知识点 🤔 小小总结一下吧</p><span id="more"></span><h3 id="flex模型说明"><a href="#flex模型说明" class="headerlink" title="flex模型说明"></a>flex模型说明</h3><p><img src="/img/flex_terms.png" alt="flex模型说明"></p><ul><li><strong>主轴</strong>（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 <strong>main start</strong> 和 <strong>main end</strong>。</li><li><strong>交叉轴</strong>（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 <strong>cross start</strong> 和 <strong>cross end</strong>。</li><li>设置了 <code>display: flex</code> 的<strong>父元素</strong>被称之为 <strong>flex 容器（flex container）。</strong></li><li>在 flex 容器中表现为弹性的盒子的元素被称之为 <strong>flex 项</strong>（<strong>flex item</strong>）</li></ul><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><strong>规定主轴(<code>main axis</code>)的方向</strong></p><ul><li><code>row</code></li><li><code>row-reverse</code></li><li><code>column</code></li><li><code>column-reverse</code></li></ul><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>flex-wrap是CSS中用于<strong>控制Flex容器中的子元素如何换行</strong>的属性。它决定了当子元素在主轴方向上无法一行容纳时是否换行，并且指定了换行的方式。</p><ul><li><p><strong><code>nowrap</code>（默认值）</strong>：子元素不换行，尽量在一行容纳所有子元素。如果子元素的总宽度超过了容器的宽度，子元素可能会被缩小以适应容器。</p></li><li><p><strong><code>wrap</code><strong>：子元素允许换行，当子元素在主轴方向上无法一行容纳时，会</strong>换行显示</strong>。换行后的子元素将会从新的行开始排列。</p></li><li><p>**<code>wrap-reverse</code>**：子元素允许换行，与wrap相似，但换行后的子元素的排列顺序将会反转。</p></li></ul><h3 id="flew-flow"><a href="#flew-flow" class="headerlink" title="flew-flow"></a>flew-flow</h3><p><code>flex-direction</code>和<code>flex-wrap</code>的缩写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row;<br><span class="hljs-attribute">flex-wrap</span>: wrap;<br>//等价于<br><span class="hljs-attribute">flex-flow</span>: row wrap;<br></code></pre></td></tr></table></figure><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>用于指定子元素<strong>在可用空间增加时的扩展比例</strong>。它的值为一个非负整数，默认为 0。</p><ul><li>如果所有的子元素的 flex-grow 值都为 0，它们将不会扩展，宽度将根据它们的内容或固定宽度来确定。</li><li>如果一个子元素的 flex-grow 值大于 0，而其他子元素的值为 0，那么这个子元素将占据剩余的可用空间，其占据空间的比例为 flex-grow 值与其他子元素的和的比例。</li></ul><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>用于指定子元素<strong>在空间不足时的缩小比例</strong>。它的值为一个非负整数，默认为 1。</p><ul><li>如果所有的子元素的 flex-shrink 值都为 1，它们将按比例缩小，以适应容器的可用空间。</li><li>如果一个子元素的 flex-shrink 值为 0，而其他子元素的值为 1，当空间不足时，其他子元素将缩小，而这个子元素将保持其原始大小</li></ul><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>用于指定<strong>子元素在主轴上的初始大小</strong>。它的值可以是一个<strong>长度值（如像素、百分比等）</strong>，或者<strong>关键字 auto</strong>。</p><ul><li>如果设置为一个长度值（如 flex-basis: 100px;），子元素将具有固定的初始大小。</li><li>如果设置为关键字 auto（如 flex-basis: auto;），子元素的大小将根据其内容或固有大小来确定。</li></ul><h3 id="动态尺寸"><a href="#动态尺寸" class="headerlink" title="动态尺寸"></a>动态尺寸</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">article</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">article</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">2</span> <span class="hljs-number">200px</span>;<br>&#125;<br><br>这表示“每个 <span class="hljs-attribute">flex</span> 项将首先给出 <span class="hljs-number">200px</span> 的可用空间，然后，剩余的可用空间将根据分配的比例共享”。<br></code></pre></td></tr></table></figure><h3 id="属性缩写"><a href="#属性缩写" class="headerlink" title="属性缩写"></a>属性缩写</h3><p>当使用flex属性的缩写形式时，可以指定最多三个不同值：<code>flex-grow</code>、<code>flex-shrink</code>和<code>flex-basis</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><br><span class="hljs-selector-class">.flex-item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: red;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="水平和垂直对齐"><a href="#水平和垂直对齐" class="headerlink" title="水平和垂直对齐"></a>水平和垂直对齐</h3><ul><li><p><strong><code>align-items</code></strong> 控制flex项在交叉轴 <code>cross axis</code>上的位置</p><ul><li>默认值是<code>stretch</code></li><li><code>center</code>居中常用</li><li><code>flex-start``flex-end</code>设置对齐开始结束</li><li><code>align-self</code>某个元素覆盖<code>align-items</code></li></ul></li><li><p><strong><code>justify-content</code></strong> 控制flex项在主轴 <code>main axis</code>上的位置</p><ul><li><code>flex-start</code> <code>flex-end</code></li><li><code>center</code></li><li><code>space-around</code>   沿着主轴均匀分布，任意一端留有空间</li><li><code>space-between</code>   沿着主轴均匀分布，两端不会留有空间</li></ul></li></ul><h3 id="flex排序"><a href="#flex排序" class="headerlink" title="flex排序"></a>flex排序</h3><ul><li>flex的默认<code>order</code>是0</li><li><code>order</code>值大的显示顺序更靠后</li><li>可设置负值排在前面</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础知识</title>
    <link href="/2024/01/28/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/01/28/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>笔记详尽版 👊 是2023夏天在by夏令营做的笔记… 原谅是初学者不太清楚的都想cv，内容很多…也是可以凑合当个复习基础知识的小百科全书惹</p><span id="more"></span><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>应用程序接口（Application Programming Interfaces</strong>（<strong>API</strong>）</p><h3 id="浏览器-API"><a href="#浏览器-API" class="headerlink" title="浏览器 API"></a>浏览器 API</h3><p>内建于 web 浏览器中，它们可以将数据从周边计算机环境中筛选出来，还可以做实用的复杂工作。例如：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model"><code>文档对象模型 API（DOM（Document Object Model）API）</code></a> 能通过创建、移除和修改 HTML，为页面动态应用新样式等手段来操作 HTML 和 CSS。比如当某个页面出现了一个弹窗，或者显示了一些新内容（像上文小 demo 中看到那样），这就是 DOM 在运行。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Geolocation"><code>地理位置 API（Geolocation API）</code></a> 获取地理信息。这就是为什么 <a href="https://www.google.cn/maps">谷歌地图</a> 可以找到你的位置，而且标示在地图上。</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API"><code>画布（Canvas）</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API"><code>WebGL</code></a> API 可以创建生动的 2D 和 3D 图像。人们正运用这些 web 技术制作令人惊叹的作品。参见 <a href="https://www.chromeexperiments.com/webgl">Chrome Experiments</a> 以及 <a href="https://webglsamples.org/">webglsamples</a>。</li><li>诸如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement"><code>HTMLMediaElement</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API"><code>WebRTC</code></a> 等 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Audio_and_video_delivery">影音类 API</a> 让你可以利用多媒体做一些非常有趣的事，比如在网页中直接播放音乐和影片，或用自己的网络摄像头获取录像，然后在其他人的电脑上展示（试用简易版 <a href="http://chrisdavidmills.github.io/snapshot/">截图 demo</a> 以理解这个概念）。</li></ul><h3 id="第三方-API"><a href="#第三方-API" class="headerlink" title="第三方 API"></a>第三方 API</h3><p>并没有默认嵌入浏览器中，一般要从网上取得它们的代码和信息。比如：</p><ul><li><a href="https://dev.twitter.com/overview/documentation">Twitter API</a>、<a href="https://open.weibo.com/">新浪微博 API</a> 可以在网站上展示最新推文之类。</li><li><a href="https://developers.google.com/maps/">谷歌地图 API</a>、<a href="https://lbs.amap.com/">高德地图 API</a> 可以在网站嵌入定制的地图等等</li></ul><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="解释代码-vs-编译代码"><a href="#解释代码-vs-编译代码" class="headerlink" title="解释代码 vs 编译代码"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript#%E8%A7%A3%E9%87%8A%E4%BB%A3%E7%A0%81_vs_%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81">解释代码 vs 编译代码</a></h3><p>作为程序员，你或许听说过这两个术语：<strong>解释</strong>（interpret）和 <strong>编译</strong>（compile）。在解释型语言中，代码自上而下运行，且实时返回运行结果。代码在由浏览器执行前，不需要将其转化为其他形式。代码将直接以文本格式（text form）被接收和处理。</p><p>相对的，编译型语言需要先将代码转化（编译）成另一种形式才能运行。比如 C&#x2F;C++ 先被编译成汇编语言，然后才能由计算机运行。程序将以二进制的格式运行，这些二进制内容是由程序源代码产生的。</p><p>JavaScript 是轻量级解释型语言。浏览器接受到 JavaScript 代码，并以代码自身的文本格式运行它。技术上，几乎所有 JavaScript 转换器都运用了一种叫做即时编译（just-in-time compiling）的技术；当 JavaScript 源代码被执行时，它会被编译成二进制的格式，使代码运行速度更快。尽管如此，JavaScript 仍然是一门解释型语言，因为编译过程发生在代码运行中，而非之前。</p><p>两种类型的语言各有优势，这个问题我们暂且不谈。</p><h3 id="服务器端代码-vs-客户端代码"><a href="#服务器端代码-vs-客户端代码" class="headerlink" title="服务器端代码 vs 客户端代码"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%BB%A3%E7%A0%81_vs_%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81">服务器端代码 vs 客户端代码</a></h3><p>你或许还听说过<strong>服务器端（server-side）</strong>和 **客户端（client-side）**代码这两个术语，尤其是在 web 开发时。客户端代码是在用户的电脑上运行的代码，在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示。这就是**客户端 JavaScript**。</p><p>而服务器端代码在服务器上运行，接着运行结果才由浏览器下载并展示出来。流行的服务器端 web 语言包括：PHP、Python、Ruby、ASP.NET 以及…… JavaScript！JavaScript 也可用作服务器端语言，比如现在流行的 Node.js 环境，你可以在我们的 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/Server-side">动态网页 - 服务器端编程</a> 主题中找到更多关于服务器端 JavaScript 的知识。</p><h3 id="动态代码-vs-静态代码"><a href="#动态代码-vs-静态代码" class="headerlink" title="动态代码 vs 静态代码"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/What_is_JavaScript#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81_vs_%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81">动态代码 vs 静态代码</a></h3><p>“<strong>动态</strong>”一词既适用于客户端 JavaScript，又适用于描述服务器端语言。是指通过按需生成新内容来更新 web 页面 &#x2F; 应用，使得不同环境下显示不同内容。服务器端代码会在服务器上动态生成新内容，例如从数据库中提取信息。而客户端 JavaScript 则在用户端浏览器中动态生成新内容，比如说创建一个新的 HTML 表格，用从服务器请求到的数据填充，然后在网页中向用户展示这个表格。两种情况的意义略有不同，但又有所关联，且两者（服务器端和客户端）经常协同作战。</p><p>没有动态更新内容的网页叫做“<strong>静态</strong>”页面<strong>，</strong>所显示的内容不会改变。</p><h2 id="脚本调用策略"><a href="#脚本调用策略" class="headerlink" title="脚本调用策略"></a>脚本调用策略</h2><h3 id="内部脚本"><a href="#内部脚本" class="headerlink" title="内部脚本"></a>内部脚本</h3><p>“内部”示例使用了以下结构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;DOMContentLoaded&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  . . .<br>&#125;);<br></code></pre></td></tr></table></figure><p>这是一个事件监听器，它监听浏览器的 “<code>DOMContentLoaded</code>“ 事件，即 HTML 文档体加载、解释完毕事件。事件触发时将调用 “ <code>. . .</code>“ 处的代码，从而避免了错误发生（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">事件</a> 的概念稍后学习）。</p><h3 id="外部脚本"><a href="#外部脚本" class="headerlink" title="外部脚本"></a>外部脚本</h3><h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><p>“外部”示例中使用了 JavaScript 的一项现代技术（<code>async</code> “异步”属性）来解决这一问题，它告知浏览器在遇到 <code>&lt;script&gt;</code> 元素时不要中断后续 HTML 内容的加载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span> <span class="hljs-attr">async</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述情况下，脚本和 HTML 将一并加载，代码将顺利运行。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vendor/jquery.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/script3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加 <code>defer</code> 属性的脚本将按照在页面中出现的顺序加载，因此第二个示例可确保 <code>jquery.js</code> 必定加载于 <code>script2.js</code> 和 <code>script3.js</code> 之前，同时 <code>script2.js</code> 必定加载于 <code>script3.js</code> 之前。</p><p><strong>脚本调用策略小结：</strong></p><ul><li>如果脚本无需等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li><li>如果脚本需要等待页面解析，且依赖于其他脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li></ul><h2 id="一、Javascript基础要件"><a href="#一、Javascript基础要件" class="headerlink" title="一、Javascript基础要件"></a>一、Javascript基础要件</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>String</p></li><li><p>Number</p></li><li><p>Boolean</p></li><li><p>Array</p></li><li><p>Object</p><p>  对象：JavaScript 里一切皆对象，一切皆可储存在变量里。这一点要牢记于心</p></li></ul><h4 id="var和let"><a href="#var和let" class="headerlink" title="var和let"></a>var和let</h4><p>如果你编写一个声明并初始化变量的多行 JavaScript 程序，你可以在初始化一个变量之后用 <code>var</code> 声明它，它仍然可以工作。</p><p>其次，当你使用 <code>var</code> 时，可以根据需要多次声明相同名称的变量，但是 <code>let</code> 不能。</p><p>出于这些以及其他原因，我们建议您在代码中尽可能多地使用 <code>let</code>，而不是 <code>var</code>.</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="和"><a href="#和" class="headerlink" title="&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;</strong></h4><p>在 JavaScript 中，<code>==</code> 和 <code>===</code> 都是用于比较两个值的操作符，但它们之间有一些重要的区别。</p><ol><li><p><code>==</code>（相等运算符）：它用于比较两个值是否相等，但在进行比较之前会进行类型转换。</p><ul><li>如果比较的两个值类型不同，JavaScript 会尝试将它们转换为相同的类型，然后再进行比较。</li><li>如果比较的两个值都是字符串、数字、布尔值或 null，则会执行常规的相等性检查。</li><li>如果一个值是 <code>undefined</code> 或 <code>null</code>，而另一个值是 <code>null</code> 或 <code>undefined</code>，则它们被视为相等。</li><li>如果比较的两个值都是对象，则比较它们的引用，只有在引用指向同一个对象时才被认为是相等的。</li></ul><p> 以下是一些示例：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">javascriptCopy code5 == <span class="hljs-number">5</span>    <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;5&#x27;</span> == <span class="hljs-number">5</span>  <span class="hljs-comment">// true (进行类型转换后，字符串 &#x27;5&#x27; 变成了数字 5)</span><br><span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>  <span class="hljs-comment">// true</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] == [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]   <span class="hljs-comment">// false (两个数组的引用不同)</span><br></code></pre></td></tr></table></figure></li><li><p><code>===</code>（严格相等运算符）：它用于比较两个值是否完全相等，包括类型和值。</p><ul><li>如果比较的两个值类型不同，它们被视为不相等。</li><li>如果比较的两个值都是字符串、数字、布尔值、null 或 undefined，它们必须具有相同的类型和相同的值才被视为相等。</li><li>如果比较的两个值都是对象或数组，它们必须引用同一个对象才被视为相等。</li></ul><p> 以下是一些示例：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">javascriptCopy code5 === <span class="hljs-number">5</span>    <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;5&#x27;</span> === <span class="hljs-number">5</span>  <span class="hljs-comment">// false (类型不同)</span><br><span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>  <span class="hljs-comment">// false (类型不同)</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] === [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]   <span class="hljs-comment">// false (两个数组的引用不同)</span><br></code></pre></td></tr></table></figure></li></ol><p>总结：</p><ul><li><code>==</code> 运算符在比较之前进行类型转换，可以在某些情况下自动转换类型。</li><li><code>===</code> 运算符进行严格的类型和值比较，要求类型和值都完全相等。</li></ul><p>通常建议使用 <code>===</code> 运算符，因为它可以避免因类型转换而导致的意外结果。只有在特定的情况下，比如明确需要进行类型转换时，才使用 <code>==</code> 运算符。</p><h4 id="运算符-1"><a href="#运算符-1" class="headerlink" title="+运算符"></a>+运算符</h4><p>你也可以使用 <code>+</code> 运算符将文本字符串连接在一起（术语“串联”（<em>concatenation</em>））。尝试依次输入以下几行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;Bingo&#x27;</span>;<br>name;<br><span class="hljs-keyword">const</span> hello = <span class="hljs-string">&#x27; says hello!&#x27;</span>;<br>hello;<br><span class="hljs-keyword">const</span> greeting = name + hello;<br>greeting;<br></code></pre></td></tr></table></figure><table><thead><tr><th><code>**</code></th><th>幂</th><th>取底数的指数次方，即指数所指定的底数相乘。它在 EcmaScript 2016 中首次引入。</th><th><code>5 ** 5</code> (返回 3125，相当于 <code>5 * 5 * 5 * 5 * 5</code> 。)</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h3><h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">displayMessage</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>匿名函数是一种在编程中没有名称标识符的函数。它是一种可以被定义和使用，但没有特定名称的函数。</p><p>在 JavaScript 中，匿名函数可以使用函数表达式或箭头函数语法来创建。</p><ol><li>函数表达式的匿名函数：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myFunction = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码中，<code>myFunction</code> 是一个变量，它引用了一个匿名函数。你可以通过调用 <code>myFunction()</code> 来执行这个函数。</p><ol><li>箭头函数的匿名函数：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myFunction</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上述代码中，<code>myFunction</code> 是一个变量，它引用了一个箭头函数的匿名函数。同样，你可以通过调用 <code>myFunction()</code> 来执行这个函数。</p><p>匿名函数在许多情况下非常有用，特别是当你只需要定义一个函数来作为其他函数的参数或临时执行某些操作时。你可以直接将匿名函数传递给其他函数，或在需要时立即执行它。</p><p>以下是一个示例，展示了如何使用匿名函数作为参数传递给 <code>setTimeout</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>在上述示例中，我们创建了一个匿名函数作为 <code>setTimeout</code> 函数的第一个参数，它将在延迟 1000 毫秒后执行。</p><p>匿名函数的好处之一是可以避免污染全局命名空间，因为它们没有特定的名称。它们可以在需要的地方定义和使用，而无需考虑名称冲突的问题。</p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p><code>() =&gt;</code> 是 JavaScript 中的箭头函数（Arrow Function）的语法表示。</p><p>箭头函数是在 ES6（ECMAScript 2015）中引入的一种新的函数定义方式，它提供了更简洁的语法形式和改变了函数内部的 <code>this</code> 绑定规则。</p><p>箭头函数的基本语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">() =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数可以没有参数，或者带有一个或多个参数。当只有一个参数时，可以省略参数的括号。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">x =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br><br><span class="hljs-comment">// 或</span><br><br>(x, y) =&gt; &#123;<br>  <span class="hljs-comment">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>箭头函数的主要优点是它们的简洁性和对 <code>this</code> 关键字的处理方式。在箭头函数内部，<code>this</code> 的值会继承自外部作用域，而不是在函数被调用时绑定新的值。</p><p>以下是箭头函数的一些示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 没有参数的箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;;<br><span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出: Hello!</span><br><br><span class="hljs-comment">// 带有参数的箭头函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">a, b</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> a * b;<br>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiply</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 输出: 6</span><br><br><span class="hljs-comment">// 箭头函数的简写形式（隐式返回）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">square</span> = x =&gt; x * x;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">square</span>(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 输出: 16</span><br></code></pre></td></tr></table></figure><p>需要注意的是，箭头函数没有自己的 <code>this</code> 值，它会继承外部作用域的 <code>this</code> 值。这意味着箭头函数不适用于需要动态绑定 <code>this</code> 的场景，例如作为对象方法或构造函数。</p><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>btn.<span class="hljs-property">onclick</span> = displayMessage;  注意函数名之后没有括号<br></code></pre></td></tr></table></figure><p>在函数名后面的这个括号叫做“函数调用运算符”（function invocation operator）。你只有在想直接调用函数的地方才这么写。同样要重视的是，匿名函数里面的代码也不是直接运行的，只要代码在函数作用域内。（否则加上括号之后没有按按钮也会显示）</p><h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>     btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>         <span class="hljs-title function_">displayMessage</span>(<span class="hljs-string">&#x27;Woo,great!&#x27;</span>);<br>     &#125;;<br>     <span class="hljs-comment">// 如果我们要在点击事件里面绑定这个新函数，我们不能直接使用（btn.onclick = displayMessage(&#x27;Woo, this is a different message!&#x27;);）前面已经讲过— 我们要把它放在一个匿名函数里面，不然函数会直接调用，而不是按钮点击之后才会调用，这不是我们想要的结果。</span><br>     <span class="hljs-keyword">function</span> <span class="hljs-title function_">displayMessage</span>(<span class="hljs-params">msgText,msgType</span>) &#123;<br>         <span class="hljs-keyword">const</span> html = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>);<br><br>         <span class="hljs-keyword">const</span> panel = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>         panel.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;msgBox&#x27;</span>);<br>         html.<span class="hljs-title function_">appendChild</span>(panel);<br><br>         <span class="hljs-keyword">const</span> msg = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br>         msg.<span class="hljs-property">textContent</span> = msgText;<br>         panel.<span class="hljs-title function_">appendChild</span>(msg);<br><br>         <span class="hljs-keyword">const</span> closeBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>         closeBtn.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;x&#x27;</span>;<br>         panel.<span class="hljs-title function_">appendChild</span>(closeBtn);<br><br>         closeBtn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>             panel.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(panel);<br>         &#125;<br>         <br>         <span class="hljs-keyword">if</span> (msgType === <span class="hljs-string">&#x27;warning&#x27;</span>) &#123;<br>             msg.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(icons/warning.png)&#x27;</span>;<br>             panel.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msgType === <span class="hljs-string">&#x27;chat&#x27;</span>) &#123;<br>             msg.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundImage</span> = <span class="hljs-string">&#x27;url(icons/chat.png)&#x27;</span>;<br>             panel.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;aqua&#x27;</span>;<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>             msg.<span class="hljs-property">style</span>.<span class="hljs-property">paddingLeft</span> = <span class="hljs-string">&#x27;20px&#x27;</span>;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><h3 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h3><p>侦听事件发生的结构称为<strong>事件监听器</strong>（Event Listener），响应事件触发而运行的代码块被称为<strong>事件处理器</strong>（Event Handler）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;html&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;别戳我，我怕疼。&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>将事件与元素绑定有许多方法。在这里选用了 <html> 元素，然后调用了它的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener"><code>addEventListener()</code></a> 方法，将事件名称（<code>&#39;click&#39;</code>）以及其回调函数（当事件发生时，调用该函数）传入该函数中作为调用参数。</p><p>刚刚我们传递给 <code>addEventListener()</code> 的函数被称为<em><strong>匿名函数</strong></em>，因为它没有名字。匿名函数还有另一种我们称之为<em><strong>箭头函数</strong></em>的写法，箭头函数使用 <code>() =&gt;</code> 代替 <code>function ()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;html&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;别戳我，我怕疼。&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以下是一些常见的事件类型：</p><ul><li>鼠标事件：如点击（click）、双击（dblclick）、鼠标移动（mousemove）等。</li><li>键盘事件：如按键按下（keydown）、按键松开（keyup）等。</li><li>表单事件：如提交表单（submit）、输入变化（input）等。</li><li>文档加载事件：如文档加载完成（DOMContentLoaded）等。</li><li>窗口事件：如窗口大小改变（resize）、窗口关闭（beforeunload）等。</li></ul><p>每个事件都有其对应的事件对象，并且事件对象的属性和方法可能会根据事件类型的不同而有所不同。</p><p>因此，当你编写事件处理函数时，你可以通过访问 <code>event</code> 对象来获取有关事件的信息，无论是鼠标点击还是其他类型的事件。这样，你就可以根据事件的类型和目标元素来执行相应的操作。</p><h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h4><p><code>addEventListener</code> 是 JavaScript 中用于<strong>添加事件监听器</strong>的方法。它允许你为特定的事件类型注册一个回调函数，以便在事件发生时执行相应的操作。</p><p><code>addEventListener</code> 的语法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">target.<span class="hljs-title function_">addEventListener</span>(type, listener[, options]);<br></code></pre></td></tr></table></figure><ul><li><code>target</code>：要添加事件监听器的目标元素。</li><li><code>type</code>：要监听的事件类型，如 “click”、”keydown”、”mouseover” 等。</li><li><code>listener</code>：要执行的回调函数，也称为事件处理函数。当指定的事件类型发生时，该函数将被调用。</li><li><code>options</code>（可选）：一个包含附加选项的对象，用于指定有关事件监听的更多详细信息，例如 <code>capture</code>（是否在捕获阶段触发）、<code>once</code>（是否只触发一次）等。</li></ul><p>以下是一个简单的示例，演示如何使用 <code>addEventListener</code> 添加事件监听器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button id=<span class="hljs-string">&quot;myButton&quot;</span>&gt;<span class="hljs-title class_">Click</span> me&lt;/button&gt;<br><span class="hljs-keyword">var</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myButton&quot;</span>);<br><br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button clicked!&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上述示例中，我们首先使用 <code>document.getElementById</code> 方法获取具有 id “myButton” 的按钮元素，并将其存储在变量 <code>button</code> 中。</p><p>然后，我们使用 <code>addEventListener</code> 方法为按钮添加一个 “click” 事件监听器。在这个示例中，匿名函数作为事件处理函数传递给 <code>addEventListener</code>。当按钮被点击时，匿名函数将被调用，输出 “Button clicked!” 到控制台。</p><p>通过使用 <code>addEventListener</code>，你可以为目标元素添加多个不同类型的事件监听器，并在事件发生时执行相应的操作。这是处理交互和用户操作的关键技术之一。</p><h4 id="removeEventListener"><a href="#removeEventListener" class="headerlink" title="removeEventListener()"></a>removeEventListener()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, changeBackground);<br></code></pre></td></tr></table></figure><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>有时候在事件处理函数内部，你可能会看到一个固定指定名称的参数，例如 <code>event</code>、<code>evt</code> 或 <code>e</code>。这被称为<strong>事件对象</strong>，它被自动传递给事件处理函数，以提供额外的功能和信息。例如，让我们稍稍重写一遍我们的随机颜色示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">random</span>(<span class="hljs-params">number</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (number + <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bgChange</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">const</span> rndCol = <span class="hljs-string">`rgb(<span class="hljs-subst">$&#123;random(<span class="hljs-number">255</span>)&#125;</span>, <span class="hljs-subst">$&#123;random(<span class="hljs-number">255</span>)&#125;</span>, <span class="hljs-subst">$&#123;random(<span class="hljs-number">255</span>)&#125;</span>)`</span>;<br>  e.<span class="hljs-property">target</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = rndCol;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>&#125;<br><br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, bgChange);<br></code></pre></td></tr></table></figure><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><ul><li>事件捕获阶段</li><li>处于目标阶段</li><li>事件冒泡阶段</li></ul><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><p>事件从被点击的最里面的元素<strong>冒泡</strong>而出。</p><h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><p>事件不是先在最内层的目标元素上发生，然后在连续较少的嵌套元素上发生，而是先在<em>最小嵌套</em>元素上发生，然后在连续更多的嵌套元素上发生，直到达到目标。</p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>当我们想在用户与大量的子元素中的任何一个互动时运行一些代码时，我们在它们的父元素上设置事件监听器，让发生在它们身上的事件冒泡到它们的父元素上，而不必在每个子元素上单独设置事件监听器。</p><h3 id="循环-Loop"><a href="#循环-Loop" class="headerlink" title="循环 Loop"></a>循环 Loop</h3><h3 id="字符串string"><a href="#字符串string" class="headerlink" title="字符串string"></a>字符串string</h3><h4 id="length"><a href="#length" class="headerlink" title=".length"></a>.length</h4><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf( )"></a>indexOf( )</h4><p>indexOf() 方法<strong>可返回某个指定的字符串值在字符串中首次出现的位置</strong>（索引）。 如果没有找到匹配的字符串则返回-1。</p><h4 id="slice"><a href="#slice" class="headerlink" title="slice(  )"></a>slice(  )</h4><p>slice() 方法可从已有的数组中<strong>返回选定的元素</strong>。</p><p>slice() 方法可<strong>提取字符串的某个部分</strong>，并以新的字符串返回被提取的部分。</p><p><strong>注意：</strong> slice() 方法不会改变原始数组。</p><p>当你知道字符串中的子字符串开始的位置，以及想要结束的字符时，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/slice"><code>slice()</code></a>可以用来提取 它。尝试以下：<strong>（含前不含后）</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">browserType</span>.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>此外，如果您知道要在某个字符之后提取字符串中的所有剩余字符，则不必包含第二个参数，而只需要包含要从中提取的字符位置 字符串中的其余字符。尝试以下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">browserType.slice(<span class="hljs-number">2</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="toLowerCase-toUpperCase"><a href="#toLowerCase-toUpperCase" class="headerlink" title="toLowerCase()   toUpperCase()"></a>toLowerCase()   toUpperCase()</h4><p>字符串并将所有字符分别转换为小写或大写</p><h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>它需要两个参数 - 要被替换下的字符串和要被替换上的字符串。尝试这个例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">browserType.<span class="hljs-built_in">replace</span>(<span class="hljs-string">&#x27;moz&#x27;</span>,<span class="hljs-string">&#x27;van&#x27;</span>);<br></code></pre></td></tr></table></figure><p>注意，在实际程序中，想要真正更新 <code>browserType</code> 变量的值，您需要设置变量的值等于刚才的操作结果；它不会自动更新子串的值。所以事实上你需要这样写：<code>browserType = browserType.replace(&#39;moz&#39;,&#39;van&#39;);</code>。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>您可以将任何类型的元素存储在数组中 - 字符串，数字，对象，另一个变量，甚至另一个数组。您也可以混合和匹配项目类型 - 它们并不都是数字，字符串等。</p><h4 id="字符串与数组之间的转换"><a href="#字符串与数组之间的转换" class="headerlink" title="字符串与数组之间的转换"></a>字符串与数组之间的转换</h4><p><strong>字符串–&gt;数组</strong></p><h5 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h5><p>在其最简单的形式中，这需要一个参数，您要将字符串分隔的字符，并返回分隔符之间的子串，作为数组中的项。</p><p><strong>数组–&gt;字符串</strong></p><h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><h4 id="添加和删除数组项"><a href="#添加和删除数组项" class="headerlink" title="添加和删除数组项"></a>添加和删除数组项</h4><h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><p>要在数组末尾添加或删除一个项目，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/pop"><code>pop()</code></a>。</p><h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><h5 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h5><h2 id="二、Javascript对象介绍"><a href="#二、Javascript对象介绍" class="headerlink" title="二、Javascript对象介绍"></a>二、Javascript对象介绍</h2><h3 id="对象基础"><a href="#对象基础" class="headerlink" title="对象基础"></a>对象基础</h3><h4 id="点表示法"><a href="#点表示法" class="headerlink" title="点表示法"></a>点表示法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">person[<span class="hljs-string">&#x27;age&#x27;</span>]<br>person[<span class="hljs-string">&#x27;name&#x27;</span>][<span class="hljs-string">&#x27;first&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="括号表示法"><a href="#括号表示法" class="headerlink" title="括号表示法"></a>括号表示法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">person[<span class="hljs-string">&#x27;age&#x27;</span>]<br>person[<span class="hljs-string">&#x27;name&#x27;</span>][<span class="hljs-string">&#x27;first&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="设置对象成员"><a href="#设置对象成员" class="headerlink" title="设置对象成员"></a>设置对象成员</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">person.<span class="hljs-property">age</span> = <span class="hljs-number">45</span><br>person[<span class="hljs-string">&#x27;name&#x27;</span>][<span class="hljs-string">&#x27;last&#x27;</span>] = <span class="hljs-string">&#x27;Cratchit&#x27;</span><br><br>person[<span class="hljs-string">&#x27;eyes&#x27;</span>] = <span class="hljs-string">&#x27;hazel&#x27;</span><br>person.<span class="hljs-property">farewell</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Bye everybody!&quot;</span>) &#125;<br><br><span class="hljs-keyword">var</span> myDataName = nameInput.<span class="hljs-property">value</span><br><span class="hljs-keyword">var</span> myDataValue = nameValue.<span class="hljs-property">value</span><br>person[myDataName] = myDataValue<br><br></code></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person1 = &#123;<br>  name : <span class="hljs-string">&#x27;Chris&#x27;</span>,<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;.&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> person2 = &#123;<br>  name : <span class="hljs-string">&#x27;Brian&#x27;</span>,<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;.&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h3><h4 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h4><p>JavaScript 中所有的对象都有一个内置属性，称为它的 <strong>prototype</strong>（原型）。它本身是一个对象，故原型对象也会有它自己的原型，逐渐构成了<strong>原型链</strong>。原型链终止于拥有 <code>null</code> 作为其原型的对象上。</p><p>访问对象原型的标准方法是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf()</code></a></p><p>有个对象叫 <code>Object.prototype</code>，它是最基础的原型，所有对象默认都拥有它。<code>Object.prototype</code> 的原型是 <code>null</code>，所以它位于原型链的终点</p><p>在 JavaScript 中，构造函数是一种特殊的函数，用于创建对象实例。通过使用 <code>new</code> 关键字调用构造函数，可以创建一个新的对象，这个对象会自动与构造函数的原型建立关联。</p><p>每个构造函数都有一个 <code>prototype</code> 属性，它是一个对象，也被称为构造函数的原型对象。构造函数的原型对象是用于存储可以被该构造函数创建的所有实例共享的属性和方法。</p><p>当你创建一个对象实例时，它会自动关联到构造函数的原型对象。这意味着对象实例可以访问构造函数原型对象上定义的属性和方法。</p><p>通过原型链的机制，对象实例可以沿着原型链向上查找属性和方法，直到找到或者到达原型链的顶端。</p><p>构造函数和原型对象的关系可以总结如下：</p><ol><li>构造函数用于创建对象实例。</li><li>构造函数的 <code>prototype</code> 属性指向该构造函数的原型对象。</li><li>原型对象中存储了可以被构造函数创建的所有实例共享的属性和方法。</li><li>对象实例通过原型链可以访问构造函数原型对象上定义的属性和方法。</li></ol><p>通过构造函数和原型对象的结合使用，可以实现对象的创建、共享属性和方法的定义，以及对象之间的继承关系。</p><p>请注意，每个构造函数和原型对象都是独立的，它们可以创建不同的对象实例，并且每个实例都有自己的属性。但是，它们共享原型对象上的方法和属性，这样可以实现代码的重用和节省内存。</p><p><img src="/img/js1.png" alt="对象原型"></p><p><strong>原型 <code>prototype</code> 和 <code>__proto__</code></strong></p><ul><li><p>每个对象都有一个<code>__proto__</code>属性，并且指向它的<code>prototype</code>原型对象</p></li><li><p>每个<a href="https://www.zhihu.com/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2235790971%22%7D">构造函数</a>都有一个<code>prototype</code>原型对象</p></li><li><ul><li><code>prototype</code>原型对象里的<code>constructor</code>指向构造函数本身</li></ul></li></ul><p><strong>原型链</strong></p><p>每个对象都有一个<code>__proto__</code>，它指向它的<code>prototype</code>原型对象，而<code>prototype</code>原型对象又具有一个自己的<code>prototype</code>原型对象，就这样层层往上直到一个对象的原型<code>prototype</code>为<code>null</code></p><p>这个查询的路径就是<code>原型链</code></p><h4 id="JavaScript-中的继承"><a href="#JavaScript-中的继承" class="headerlink" title="JavaScript 中的继承"></a><strong>JavaScript 中的继承</strong></h4><ul><li>属性继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span> (name, age) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>&#125;<br><br><span class="hljs-comment">// 方法定义在构造函数的原型上</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Teacher</span> (name, age, subject) &#123;<br>    <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name, age)<br>    <span class="hljs-comment">//属性的继承是通过在一个类内执行另外一个类的构造函数，通过call指定this为当前执行环境，这样就可以得到另外一个类的所有属性。</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subject</span> = subject<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Teacher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-title class_">Teacher</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Teacher</span><br></code></pre></td></tr></table></figure><h4 id="属性遮蔽"><a href="#属性遮蔽" class="headerlink" title="属性遮蔽"></a>属性遮蔽</h4><p>当该对象不具备这个属性时，才会检查原型</p><h4 id="设置原型"><a href="#设置原型" class="headerlink" title="设置原型"></a>设置原型</h4><p><code>Object.create()</code> 方法创建一个新的对象，并允许你指定一个将被<strong>用作新对象原型</strong>的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> personPrototype = &#123;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hello!&quot;</span>);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> carl = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(personPrototype);<br>carl.<span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// hello!</span><br><br>这里我们创建了一个 personPrototype 对象，它有一个 <span class="hljs-title function_">greet</span>() 方法。然后我们使用 <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>() 来创建一个以 personPrototype 为原型的新对象。现在我们可以在新对象上调用 <span class="hljs-title function_">greet</span>()，而原型提供了它的实现<br></code></pre></td></tr></table></figure><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> personPrototype = &#123;<br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我的名字是 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>！`</span>);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, personPrototype);<br><span class="hljs-comment">// 或</span><br><span class="hljs-comment">// Person.prototype.greet = personPrototype.greet;</span><br><br></code></pre></td></tr></table></figure><p>这里我们：</p><ul><li>创建了一个 <code>personPrototype</code> 对象，它具有 <code>greet()</code> 方法</li><li>创建了一个 <code>Person()</code> 构造函数，它初始化了要创建人物对象的名字</li></ul><p>然后我们使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 将 <code>personPrototype</code> 中定义的方法绑定到 <code>Person</code> 函数的 <code>prototype</code> 属性上。</p><p>在这段代码之后，使用 <code>Person()</code> 创建的对象将获得 <code>Person.prototype</code> 作为其原型，其中自动包含 <code>greet</code> 方法。</p><h4 id="自有属性"><a href="#自有属性" class="headerlink" title="自有属性"></a>自有属性</h4><p><strong>方法是在原型上定义的</strong>，<strong>但数据属性是在构造函数中定义的</strong></p><p>直接在对象中定义的属性，如这里的<code>name</code>，被称为<strong>自有属性</strong>，你可以使用静态方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn"><code>Object.hasOwn()</code></a> 检查一个属性是否是自有属性：</p><h3 id="面向对象编程OOP"><a href="#面向对象编程OOP" class="headerlink" title="面向对象编程OOP"></a>面向对象编程OOP</h3><p>面向对象编程将一个系统抽象为许多对象的集合，每一个对象代表了这个系统的特定方面。对象包括函数（方法）和数据。一个对象可以向其他部分的代码提供一个公共接口，而其他部分的代码可以通过公共接口执行该对象的特定操作，系统的其他部分不需要关心对象内部是如何完成任务的，这样保持了对象自己内部状态的私有性。</p><h4 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h4><p>类并不做任何事情，类只是一种用于创建具体对象的模板。<code>Professor</code> 类可以创建一个具体的教授，我们称这样创建出来的具体教授为 <code>Professor</code> 类的<strong>实例</strong>。由类创建实例的过程是由一个特别的函数——<strong>构造函数</strong>所完成的。开发人员将类所需要的值传入构造函数，构造函数即可根据传入的值初始化实例的内部状态。</p><p>通常来说，需要将构造函数作为类定义的一部分明确声明，并且构造函数通常具有和类名相同的函数名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Professor</span><br>    properties<br>        name<br>        teaches<br>    constructor<br>        <span class="hljs-title class_">Professor</span>(name, teaches)<br>    methods<br>        <span class="hljs-title function_">grade</span>(paper)<br>        <span class="hljs-title function_">introduceSelf</span>()<br></code></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>    properties<br>        name<br>    constructor<br>        <span class="hljs-title class_">Person</span>(name)<br>    methods<br>        <span class="hljs-title function_">introduceSelf</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Professor</span> : <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span><br>    properties<br>        teaches<br>    constructor<br>        <span class="hljs-title class_">Professor</span>(name, teaches)<br>    methods<br>        <span class="hljs-title function_">grade</span>(paper)<br>        <span class="hljs-title function_">introduceSelf</span>()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span><br>    properties<br>        year<br>    constructor<br>        <span class="hljs-title class_">Student</span>(name, year)<br>    methods<br>        <span class="hljs-title function_">introduceSelf</span>()<br></code></pre></td></tr></table></figure><p>在这种情况下，我们称 <code>Person</code> 类是 <code>Professor</code> 类和 <code>Student</code> 类的<strong>超类</strong>（superclass）或<strong>父类</strong>（parent class）。反之，我们称 <code>Professor</code> 类和 <code>Student</code> 类是 <code>Person</code> 类的<strong>子类</strong>（subclass 或 child class）</p><p>当一个方法拥有相同的函数名，但是在不同的类中可以具有不同的实现时，我们称这一特性为<strong>多态</strong>（polymorphism）。当一个方法在子类中替换了父类中的实现时，我们称之为子类<strong>重写&#x2F;重载</strong>（override）了父类中的实现。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>当其他部分的代码想要执行对象的某些操作时，可以借助对象向外部提供的接口完成操作，借此，对象保持了自身的内部状态不会被外部代码随意修改。也就是说，对象的内部状态保持了私有性，而外部代码只能通过对象所提供的接口访问和修改对象的内部状态，不能直接访问和修改对象的内部状态。保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这些特性称之为<strong>封装</strong>（encapsulation）。</p><p>在许多面向对象编程语言中，我们可以使用 <code>private</code> 关键字标记对象的私有部分，也就是外部代码无法直接访问的部分。如果一个属性在被标记为 <code>private</code> 的情况下，外部代码依旧尝试访问该属性，那么通常来说，计算机会抛出一个错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span><br>    properties<br>       year<br>    constructor<br>        <span class="hljs-title class_">Student</span>(name, year)<br>    methods<br>       <span class="hljs-title function_">introduceSelf</span>()<br>       <span class="hljs-title function_">canStudyArchery</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> &gt; <span class="hljs-number">1</span> &#125;<br>           <br><span class="hljs-keyword">if</span> (student.<span class="hljs-title function_">canStudyArchery</span>()) &#123;<br>  <span class="hljs-comment">// 允许学生选修弓箭课课</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span><br>    properties<br>       private year<br>    constructor<br>        <span class="hljs-title class_">Student</span>(name, year)<br>    methods<br>       <span class="hljs-title function_">introduceSelf</span>()<br>       <span class="hljs-title function_">canStudyArchery</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year</span> &gt; <span class="hljs-number">1</span> &#125;<br><br>student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;Weber&#x27;</span>, <span class="hljs-number">1</span>)<br>student.<span class="hljs-property">year</span> <span class="hljs-comment">// 错误：&#x27;year&#x27;是学生类的私有属性</span><br></code></pre></td></tr></table></figure><h4 id="OOP与JavaScript"><a href="#OOP与JavaScript" class="headerlink" title="OOP与JavaScript"></a>OOP与JavaScript</h4><ul><li><strong>构造函数</strong>：在 JavaScript 中，构造函数可以实现类的定义，帮助我们在一个地方描述类的“形状”，包括定义类的方法。不过，原型也可以用于实现类的定义。例如，如果一个方法定义于构造函数的 <code>prototype</code> 属性中，那么所有由该构造函数创造出来的对象都可以通过原型使用该方法，而我们也不再需要将它定义在构造函数中。</li><li><strong>原型链</strong>：原型链很自然地实现了继承特性。例如，如果我们由 <code>Person</code> 原型构造了一个 <code>Student</code> 类，那么我们可以继承 <code>Person</code> 类的 <code>name</code> 属性，重写 <code>introduceSelf()</code> 方法。</li></ul><p><strong>类和对象</strong></p><p>对象通常是由类创造出来的实例。由此，定义类的方式（定义类的语法）和实例化对象的方式（构造函数）也是不同的。</p><p>而在 JavaScript 中，我们经常会使用函数或对象字面量创建对象，也就是说，JavaScript 可以在没有特定的类定义的情况下创建对象。相对于基于类的面向对象编程来说，这种方式更为轻量，帮助我们更为方便地使用对象。</p><p><strong>原型链和继承</strong></p><p>在继承方式下，当一个子类完成继承时，由该子类所创建的对象既具有其子类中单独定义的属性，又具有其父类中定义的属性（以及父类的父类，依此类推）。而在原型链中，每一个层级都代表了一个不同的对象，不同的对象之间通过 <code>__proto__</code> 属性链接起来。原型链的行为并不太像是继承，而更像是<strong>委派</strong>（delegation）。委派同样是对象中的一种编程模式。当我们要求对象执行某项任务时，在委派模式下，对象可以自己执行该项任务，或者要求另一个对象（委派的对象）以其自己的方式执行这项任务。在许多方面，相对于继承来说，委派可以更为灵活地在许多对象之间建立联系（例如，委派模式可以在程序运行时改变、甚至完全替换委派对象）。</p><h3 id="JavaScript中的类"><a href="#JavaScript中的类" class="headerlink" title="JavaScript中的类"></a>JavaScript中的类</h3><h4 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>  name;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br><br>  <span class="hljs-title function_">introduceSelf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi! I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>  &#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">const</span> giles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Giles&#x27;</span>);<br><br>giles.<span class="hljs-title function_">introduceSelf</span>(); <span class="hljs-comment">// Hi! I&#x27;m Giles</span><br><br></code></pre></td></tr></table></figure><p><strong>省略构造函数</strong></p><p>如果你不需要任何特殊的初始化内容，你可以省略构造函数，默认的构造函数会被自动生成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;zzzzzzz&#x27;</span>);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">const</span> spot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br><br>spot.<span class="hljs-title function_">sleep</span>(); <span class="hljs-comment">// &#x27;zzzzzzz&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Professor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br><br>  teaches;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, teaches</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">teaches</span> = teaches;<br>  &#125;<br><br>  <span class="hljs-title function_">introduceSelf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, and I will be your <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.teaches&#125;</span> professor.`</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">grade</span>(<span class="hljs-params">paper</span>) &#123;<br>    <span class="hljs-keyword">const</span> grade = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (<span class="hljs-number">5</span> - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(grade);<br>  &#125;<br><br>&#125;<br><br> 如果子类有任何自己的初始化内容需要完成，它也必须先使用 <span class="hljs-variable language_">super</span>() 来调用父类的构造函数，并传递父类构造函数期望的任何参数。<br></code></pre></td></tr></table></figure><h4 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br><br>  #year;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, year</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name);<br>    <span class="hljs-variable language_">this</span>.#year = year;<br>  &#125;<br><br><br>  <span class="hljs-title function_">introduceSelf</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hi! I&#x27;m <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>, and I&#x27;m in year <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.#year&#125;</span>.`</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">canStudyArchery</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#year &gt; <span class="hljs-number">1</span>;<br>  &#125;<br><br>&#125;<br>私有数据属性必须在类的声明中声明，而且其名称需以 # 开头。<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><br>  <span class="hljs-title function_">somePublicMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">somePrivateMethod</span>();<br>  &#125;<br><br>  #<span class="hljs-title function_">somePrivateMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;You called me?&#x27;</span>);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">const</span> myExample = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>();<br><br>myExample.<span class="hljs-title function_">somePublicMethod</span>(); <span class="hljs-comment">// &#x27;You called me?&#x27;</span><br><br>myExample.#<span class="hljs-title function_">somePrivateMethod</span>(); <span class="hljs-comment">// SyntaxError</span><br><br>与私有数据属性一样，你也可以声明私有方法。而且名称也是以 # 开头，只能在类自己的方法中调用<br></code></pre></td></tr></table></figure><h3 id="使用JSON"><a href="#使用JSON" class="headerlink" title="使用JSON"></a>使用JSON</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/JSON">JSON</a> 是一种按照 JavaScript 对象语法的<strong>数据格式</strong></p><p>JSON 可以作为一个对象或者字符串存在，前者用于解读 JSON 中的数据，后者用于通过网络传输 JSON 数据。这不是一个大事件——JavaScript 提供一个全局的 可访问的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON">JSON</a> 对象来对这两种数据进行转换。</p><p>一个 JSON 对象可以被储存在它自己的文件中，这基本上就是一个文本文件，扩展名为 <code>.json</code>，还有 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/MIME_type">MIME type</a> 用于 <code>application/json</code>.</p><h4 id="JSON结构"><a href="#JSON结构" class="headerlink" title="JSON结构"></a>JSON结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;squadName&quot;</span> : <span class="hljs-string">&quot;Super hero squad&quot;</span>,<br>  <span class="hljs-string">&quot;homeTown&quot;</span> : <span class="hljs-string">&quot;Metro City&quot;</span>,<br>  <span class="hljs-string">&quot;formed&quot;</span> : <span class="hljs-number">2016</span>,<br>  <span class="hljs-string">&quot;secretBase&quot;</span> : <span class="hljs-string">&quot;Super tower&quot;</span>,<br>  <span class="hljs-string">&quot;active&quot;</span> : <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;members&quot;</span> : [<br>    &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Molecule Man&quot;</span>,<br>      <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">29</span>,<br>      <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Dan Jukes&quot;</span>,<br>      <span class="hljs-string">&quot;powers&quot;</span> : [<br>        <span class="hljs-string">&quot;Radiation resistance&quot;</span>,<br>        <span class="hljs-string">&quot;Turning tiny&quot;</span>,<br>        <span class="hljs-string">&quot;Radiation blast&quot;</span><br>      ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Madame Uppercut&quot;</span>,<br>      <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">39</span>,<br>      <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Jane Wilson&quot;</span>,<br>      <span class="hljs-string">&quot;powers&quot;</span> : [<br>        <span class="hljs-string">&quot;Million tonne punch&quot;</span>,<br>        <span class="hljs-string">&quot;Damage resistance&quot;</span>,<br>        <span class="hljs-string">&quot;Superhuman reflexes&quot;</span><br>      ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Eternal Flame&quot;</span>,<br>      <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">1000000</span>,<br>      <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Unknown&quot;</span>,<br>      <span class="hljs-string">&quot;powers&quot;</span> : [<br>        <span class="hljs-string">&quot;Immortality&quot;</span>,<br>        <span class="hljs-string">&quot;Heat Immunity&quot;</span>,<br>        <span class="hljs-string">&quot;Inferno&quot;</span>,<br>        <span class="hljs-string">&quot;Teleportation&quot;</span>,<br>        <span class="hljs-string">&quot;Interdimensional travel&quot;</span><br>      ]<br>    &#125;<br>  ]<br>&#125;<br><br>superHeroes[<span class="hljs-string">&quot;members&quot;</span>][<span class="hljs-number">1</span>][<span class="hljs-string">&quot;powers&quot;</span>][<span class="hljs-number">2</span>]<br><br></code></pre></td></tr></table></figure><h4 id="JSON数组"><a href="#JSON数组" class="headerlink" title="JSON数组"></a>JSON数组</h4><p>数组对象也是一种合法的 JSON 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Molecule Man&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">29</span>,<br>    <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Dan Jukes&quot;</span>,<br>    <span class="hljs-string">&quot;powers&quot;</span> : [<br>      <span class="hljs-string">&quot;Radiation resistance&quot;</span>,<br>      <span class="hljs-string">&quot;Turning tiny&quot;</span>,<br>      <span class="hljs-string">&quot;Radiation blast&quot;</span><br>    ]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;Madame Uppercut&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">39</span>,<br>    <span class="hljs-string">&quot;secretIdentity&quot;</span> : <span class="hljs-string">&quot;Jane Wilson&quot;</span>,<br>    <span class="hljs-string">&quot;powers&quot;</span> : [<br>      <span class="hljs-string">&quot;Million tonne punch&quot;</span>,<br>      <span class="hljs-string">&quot;Damage resistance&quot;</span>,<br>      <span class="hljs-string">&quot;Superhuman reflexes&quot;</span><br>    ]<br>  &#125;<br>]<br>上面是完全合法的 <span class="hljs-title class_">JSON</span>。您只需要通过数组索引就可以访问数组元素，如 [<span class="hljs-number">0</span>][<span class="hljs-string">&quot;powers&quot;</span>][<span class="hljs-number">0</span>]。<br></code></pre></td></tr></table></figure><h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/JSON#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">其他注意事项</a></h4><ul><li>JSON 是一种<strong>纯数据格式</strong>，它<strong>只包含属性</strong>，<strong>没有方法</strong>。</li><li>JSON 要求在字符串和属性名称周围<strong>使用双引号</strong>。<strong>单引号无效</strong>。</li><li>甚至一个错位的逗号或分号就可以导致 JSON 文件出错。您应该小心的检查您想使用的数据 (虽然计算机生成的 JSON 很少出错，只要生成程序正常工作)。您可以通过像 <a href="http://jsonlint.com/">JSONLint</a> 的应用程序来检验 JSON。</li><li>JSON 可以将任何标准合法的 JSON 数据格式化保存，不只是数组和对象。比如，一个单一的字符串或者数字可以是合法的 JSON 对象。虽然不是特别有用处……</li><li>与 JavaScript 代码中对象属性可以不加引号不同，<strong>JSON 中只有带引号的字符串可以用作属性</strong>。</li></ul><h4 id="对象和文本间的转换"><a href="#对象和文本间的转换" class="headerlink" title="对象和文本间的转换"></a>对象和文本间的转换</h4><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>parse()</code></a>: 以文本字符串形式接受 JSON 对象作为参数，并返回相应的对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> jsonStr = <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;city&quot;:&quot;New York&quot;&#125;&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonStr);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出 &quot;John&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出 30</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">city</span>); <span class="hljs-comment">// 输出 &quot;New York&quot;</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>stringify()</code></a>: 接收一个对象作为参数，返回一个对应的 JSON 字符串。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">city</span>: <span class="hljs-string">&quot;New York&quot;</span> &#125;;<br><span class="hljs-keyword">var</span> jsonStr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonStr); <span class="hljs-comment">// 输出 &#x27;&#123;&quot;name&quot;:&quot;John&quot;,&quot;age&quot;:30,&quot;city&quot;:&quot;New York&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>localStorage 存储的数据都是以<strong>字符串的形式存储</strong>的。无论是存储字符串、数字、对象还是数组，它们在存储到 localStorage 时都会被自动转换为字符串。</p><p>当你使用 <code>localStorage.setItem(key, value)</code> 方法设置键值对时，<code>value</code> 会被自动转换为字符串。如果 <code>value</code> 是一个对象或数组，它会被转换为 JSON 字符串表示形式。</p><p>当你使用 <code>localStorage.getItem(key)</code> 方法获取键对应的值时，返回的值始终是一个字符串。如果键不存在，则返回 <code>null</code>。</p><p>为了存储和读取非字符串类型的数据（如对象和数组），通常会使用 <code>JSON.stringify()</code> 和 <code>JSON.parse()</code> 来在存储和检索数据时进行转换。</p><p><code>JSON.stringify()</code> 将数据转换为 JSON 字符串，<code>JSON.parse()</code> 将 JSON 字符串解析为对应的 JavaScript 对象或数组。</p><p><strong>LocalStorage语法</strong></p><p><code>localStorage</code>是JavaScript提供的一种在客户端浏览器中存储数据的机制。它可以用于在浏览器会话之间持久保存数据，即使用户关闭浏览器或重新启动电脑，数据也将保留。</p><p><code>localStorage</code>使用简单，以下是其常见的语法和用法：</p><ol><li><strong>设置数据：</strong> 使用<code>localStorage.setItem(key, value)</code>方法来设置数据，其中<code>key</code>是要保存的数据的名称，<code>value</code>是要保存的数据的值。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>获取数据：</strong> 使用<code>localStorage.getItem(key)</code>方法来获取存储在<code>localStorage</code>中的数据。传入要获取的数据的名称<code>key</code>，它将返回对应的值。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> username = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(username); <span class="hljs-comment">// 输出：John</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>移除数据：</strong> 使用<code>localStorage.removeItem(key)</code>方法来从<code>localStorage</code>中移除指定的数据。传入要移除的数据的名称<code>key</code>即可。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>);<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>清空数据：</strong> 使用<code>localStorage.clear()</code>方法可以将<code>localStorage</code>中的所有数据清空。这将删除所有保存的数据，所以要谨慎使用。例如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><p>需要注意的是，存储在<code>localStorage</code>中的数据以键值对的形式存在，其中键和值都必须是字符串。如果要存储非字符串类型的数据（如对象或数组），可以使用<code>JSON.stringify()</code>将其转换为字符串进行存储，并在需要时使用<code>JSON.parse()</code>将其转换回原始类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">30</span><br>&#125;;<br><br><span class="hljs-comment">// 存储对象</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(user));<br><br><span class="hljs-comment">// 获取对象</span><br><span class="hljs-keyword">const</span> storedUser = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;user&#x27;</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(storedUser.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出：John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(storedUser.<span class="hljs-property">age</span>); <span class="hljs-comment">// 输出：30</span><br></code></pre></td></tr></table></figure><p>请注意，<code>localStorage</code>只能存储有限的数据量（通常为几MB），具体取决于浏览器和用户的设置。因此，不应将大量数据存储在<code>localStorage</code>中，以免影响性能和用户体验。</p><h2 id="三、异步JavaScript"><a href="#三、异步JavaScript" class="headerlink" title="三、异步JavaScript"></a>三、异步JavaScript</h2><h3 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h3><p>在编程中，选择使用异步或同步操作取决于特定的需求和场景。</p><p>异步操作通常用于处理耗时的任务、网络请求、文件读写等操作。它们<strong>不会阻塞程序的执行</strong>，而是通过<strong>回调函数</strong>、<strong>Promise</strong>、<strong>async&#x2F;await</strong> 等机制来处理结果或执行后续操作。异步操作可以提高程序的<strong>并发性和响应性</strong>，使得程序能够同时处理多个任务。</p><p>然而，在某些情况下，同步操作可能更加合适。同步操作会阻塞程序的执行，直到操作完成并返回结果。同步操作通常用于需要<strong>确保顺序执行</strong>、<strong>依赖前一步操作结果的情况</strong>，或者需要在操作完成之前暂停程序执行的场景。</p><p>选择异步还是同步操作取决于你的需求和程序的特点。在处理复杂的任务、并发操作、用户交互等场景下，异步操作通常更加合适。而在简单的、线性执行的任务中，同步操作可能更加简单和直观。重要的是理解两者的差异，并根据具体情况做出合适的选择。</p><p>当涉及到网络请求时，异步操作非常常见。例如，当你需要从服务器获取数据时，使用异步操作可以避免阻塞程序的执行。你可以发起一个异步的网络请求，继续执行其他任务，而无需等待服务器的响应。一旦服务器返回响应，你可以通过回调函数、Promise 或 async&#x2F;await 来处理返回的数据。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用异步操作发送 GET 请求</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理返回的数据</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理错误</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>  &#125;);<br><br><span class="hljs-comment">// 继续执行其他任务，不需要等待服务器响应</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;继续执行其他任务...&#x27;</span>);<br></code></pre></td></tr></table></figure><p>另一个例子是处理耗时的任务，如图像处理、文件读写等。使用异步操作可以在任务执行期间允许程序继续执行其他操作，提高程序的并发性和响应性。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 异步读取文件</span><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;);<br><br><span class="hljs-comment">// 继续执行其他任务，不需要等待文件读取完成</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;继续执行其他任务...&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在某些情况下，同步操作更加合适。例如，当需要确保顺序执行或依赖前一步操作的结果时，同步操作可以提供简单的控制流程。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 同步读取文件</span><br><span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br><br><span class="hljs-comment">// 在文件读取完成之前，不会执行下面的代码</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;继续执行其他任务...&#x27;</span>);<br></code></pre></td></tr></table></figure><p>需要注意的是，在使用同步操作时，如果操作耗时较长或阻塞了程序的执行，可能会导致程序在此期间无法响应其他任务或用户操作。因此，同步操作应谨慎使用，以避免阻塞程序的执行。</p><p>JavaScript中大部分是同步执行的 异步的有：</p><p>使用 <strong>setTimeout，AJAX 请求、定时器、事件监听</strong>等。这些方法都可以让程序在执行到某个异步操作时继续执行后面的代码，而不需要等待异步操作完成。</p><p>除了异步操作外，还有一些语句或操作可以改变程序的执行流程，例如条件语句（<code>if</code>、<code>switch</code>）、循环语句（<code>for</code>、<code>while</code>）、函数调用等。通过合理使用这些语句和操作，可以控制代码的执行顺序和跳过特定的语句。</p><p>需要注意的是，在 JavaScript 中，异步操作是一种常见的编程模式，可以提高程序的性能和用户体验。通过合理地使用异步操作，可以避免阻塞程序执行，提高程序的响应能力。</p><p><a href="https://www.freecodecamp.org/chinese/news/asynchronous-javascript-explained/">异步javascript简介</a></p><h3 id="使用Promise"><a href="#使用Promise" class="headerlink" title="使用Promise"></a>使用Promise</h3><p><strong>Promise</strong> 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。在 Promise 返回给调用者的时候，操作往往还没有完成，但 Promise 对象可以让我们操作最终完成时对其进行处理（无论成功还是失败）。</p><ul><li><code>new Promise</code>: 这是创建一个新的 Promise 对象的关键字。</li><li><code>(resolve, reject) =&gt; &#123; ... &#125;</code>: 这是一个箭头函数，它是 Promise 构造函数的参数。在这个箭头函数中，你可以定义异步操作的逻辑，同时也要决定何时将 Promise 标记为已解决（resolve）或拒绝（reject）。</li><li><code>&#123; ... &#125;</code>: 这是箭头函数的函数体，你可以在这里编写异步操作的逻辑。比如，在异步操作成功时调用 <code>resolve</code>，在异步操作失败时调用 <code>reject</code>。</li><li><code>resolve</code>: 这是一个函数，用于将 Promise 标记为已解决状态。它的参数将作为 Promise 的解决值。例如，<code>resolve(&#39;Success&#39;)</code> 将 Promise 解决为字符串 ‘Success’。</li><li><code>reject</code>: 这是一个函数，用于将 Promise 标记为拒绝状态。它的参数将作为 Promise 的拒绝原因。例如，<code>reject(&#39;Error&#39;)</code> 将 Promise 拒绝，并将字符串 ‘Error’ 作为拒绝原因。</li></ul><p>所以，整个代码块的意义是：创建一个新的 Promise 对象，它有两个内置函数 <code>resolve</code> 和 <code>reject</code>，用于在异步操作成功或失败时标记 Promise 的状态。在这个 Promise 内部，你可以执行异步操作，当操作完成时，调用 <code>resolve</code> 标记为成功，或者在操作失败时调用 <code>reject</code> 标记为失败。</p><p>这种方式让你能够更好地处理异步操作的结果，并且能够更好地控制代码的执行流程。</p><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>当我们浏览网页时，经常会看到一些无需刷新整个页面就能获取数据或更新页面内容的情况。这就是通过 Ajax 实现的。Ajax（Asynchronous JavaScript and XML）是一种用于在网页中进行异步通信的技术。</p><p>在传统的网页中，要获取新的数据或更新页面内容，通常需要刷新整个页面。但是，使用 Ajax 技术，我们可以在后台向服务器发送请求，获取数据并将其插入到当前页面的特定部分，而不需要刷新整个页面。这使得网页更加流畅、快速，并提供了更好的用户体验。</p><p>Ajax 的重要性体现在以下几个方面：</p><ol><li><p><strong>实时性：</strong> Ajax 允许网页与服务器之间进行异步通信，使得数据的获取和更新可以在后台进行，而不需要刷新整个页面。这使得网页能够以实时或接近实时的方式展示数据的变化，例如实时聊天、动态加载内容等。</p></li><li><p><strong>交互性：</strong> Ajax 技术可以通过与服务器进行交互，实现更多的用户交互功能。例如，在一个表单中输入数据后，可以使用 Ajax 将数据发送到服务器进行验证，然后根据服务器的响应动态地更新页面，而无需刷新整个页面。</p></li><li><p><strong>性能优化：</strong> 通过使用 Ajax，可以减少对服务器的请求次数，仅获取需要更新的数据，而不是整个页面的内容。这减轻了服务器的负担，并减少了网络带宽的消耗，从而提高了网页的性能和加载速度。</p></li><li><p><strong>无缝集成：</strong> Ajax 可以与其他前端技术（如JavaScript、HTML、CSS）无缝集成，使得开发者可以更加灵活地处理网页的各种操作和交互。它可以与现有的网页技术和框架结合使用，为开发者提供更多的选择和自由度。</p></li></ol><p>总而言之，Ajax 技术通过在后台进行异步通信，使网页能够以实时、动态和交互性强的方式与服务器进行数据交换，从而提升了用户体验、性能和功能的灵活性。</p><h2 id="四、Node-js"><a href="#四、Node-js" class="headerlink" title="四、Node.js"></a>四、Node.js</h2><h3 id="node运行程序"><a href="#node运行程序" class="headerlink" title="node运行程序"></a>node运行程序</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">C:\Workspace&gt;<span class="hljs-keyword">node</span> D:<span class="hljs-title">\desktop</span>\try\guidance\<span class="hljs-keyword">node</span><span class="hljs-title">,js</span>\<span class="hljs-number">01</span>-hello.js<br><br>运行文件<br></code></pre></td></tr></table></figure><h3 id="node交互环境和直接运行的区别"><a href="#node交互环境和直接运行的区别" class="headerlink" title="node交互环境和直接运行的区别"></a>node交互环境和直接运行的区别</h3><p>在命令行模式运行<code>.js</code>文件和在Node交互式环境下直接运行JavaScript代码有所不同。Node交互式环境会把每一行JavaScript代码的结果自动打印出来，但是，直接运行JavaScript文件却不会。直接运行JavaScript文件，想要输出结果，必须自己用<code>console.log()</code>打印出来</p><p>直接输入<code>node</code>进入交互模式，相当于启动了Node解释器，但是等待你一行一行地输入源代码，每输入一行就执行一行。</p><p>直接运行<code>node hello.js</code>文件相当于启动了Node解释器，然后一次性把<code>hello.js</code>文件的源代码给执行了，你是没有机会以交互的方式输入源代码的。</p><h3 id="使用严格模式"><a href="#使用严格模式" class="headerlink" title="使用严格模式"></a>使用严格模式</h3><p>如果在JavaScript文件开头写上<code>&#39;use strict&#39;;</code>，那么Node在执行该JavaScript时将使用严格模式。但是，在服务器环境下，如果有很多JavaScript文件，每个文件都写上<code>&#39;use strict&#39;;</code>很麻烦。我们可以给Nodejs传递一个参数，让Node直接为所有js文件开启严格模式：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">--use_strict</span> ×××.js<br></code></pre></td></tr></table></figure><p>后续代码，如无特殊说明，我们都会直接给Node传递<code>--use_strict</code>参数来开启严格模式。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>要在模块中对外输出变量，用：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">module.exports</span> = variable<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>输出的变量可以是任意对象、函数、数组等等。</p><p>要引入其他模块输出的对象，用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">var foo</span> = require(<span class="hljs-string">&#x27;other_module&#x27;</span>);<br></code></pre></td></tr></table></figure><p>引入的对象具体是什么，取决于引入模块输出的对象。</p><p>JavaScript是一种函数式编程语言，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p><p><strong>导出多个函数</strong> <strong>变量</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">///file1</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">function1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 函数1的逻辑</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">function2</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 函数2的逻辑</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> variable1 = <span class="hljs-string">&quot;变量1&quot;</span>;<br><span class="hljs-keyword">const</span> variable2 = <span class="hljs-string">&quot;变量2&quot;</span>;<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  function1,<br>  function2,<br>  variable1,<br>  variable2<br>&#125;;<br><br><span class="hljs-comment">///file2</span><br><span class="hljs-keyword">const</span> exportedFunctions = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./file1&#x27;</span>);<br><br>exportedFunctions.<span class="hljs-title function_">function1</span>(); <span class="hljs-comment">// 调用导出的函数1</span><br>exportedFunctions.<span class="hljs-title function_">function2</span>(); <span class="hljs-comment">// 调用导出的函数2</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(exportedFunctions.<span class="hljs-property">variable1</span>); <span class="hljs-comment">// 访问导出的变量1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(exportedFunctions.<span class="hljs-property">variable2</span>); <span class="hljs-comment">// 访问导出的变量2</span><br><br></code></pre></td></tr></table></figure><h3 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h3><h4 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h4><p>Node.js内置的<code>fs</code>模块就是文件系统模块，负责读写文件。</p><p><strong>异步读文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;sample.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>    &#125;<br>&#125;);<br><br><br>异步读取时，传入的回调函数接收两个参数，当正常读取时，err参数为<span class="hljs-literal">null</span>，data参数为读取到的<span class="hljs-title class_">String</span>。当读取发生错误时，err参数代表一个错误对象，data为<span class="hljs-literal">undefined</span>。这也是<span class="hljs-title class_">Node</span>.<span class="hljs-property">js</span>标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们还会经常编写这种回调函数。<br><br>由于err是否为<span class="hljs-literal">null</span>就是判断是否出错的标志，所以通常的判断逻辑总是：<br><span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-comment">// 出错了</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 正常</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">如果我们要读取的文件不是文本文件，而是二进制文件.下面的例子演示了如何读取一个图片文件<br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;sample.png&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">length</span> + <span class="hljs-string">&#x27; bytes&#x27;</span>);<br>    &#125;<br>&#125;);<br><br>当读取二进制文件时，不传入文件编码时，回调函数的data参数将返回一个<span class="hljs-title class_">Buffer</span>对象。在<span class="hljs-title class_">Node</span>.<span class="hljs-property">js</span>中，<span class="hljs-title class_">Buffer</span>对象就是一个包含零个或任意个字节的数组（注意和<span class="hljs-title class_">Array</span>不同）。<br><br><span class="hljs-title class_">Buffer</span>对象可以和<span class="hljs-title class_">String</span>作转换，例如，把一个<span class="hljs-title class_">Buffer</span>对象转换成<span class="hljs-title class_">String</span><br><span class="hljs-comment">// Buffer -&gt; String</span><br><span class="hljs-keyword">var</span> text = data.<span class="hljs-title function_">toString</span>(<span class="hljs-string">&#x27;utf-8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text);<br><br>或者把一个<span class="hljs-title class_">String</span>转换成<span class="hljs-title class_">Buffer</span>：<br><br><span class="hljs-comment">// String -&gt; Buffer</span><br><span class="hljs-keyword">var</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(text, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf);<br></code></pre></td></tr></table></figure><p><strong>同步读文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js">除了标准的异步读取模式外，fs也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个<span class="hljs-title class_">Sync</span>后缀，并且不接收回调函数，函数直接返回结果。<br><br>用fs模块同步读取一个文本文件的代码如下：<br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">var</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;sample.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br><br>如果同步读取文件发生错误，则需要用<span class="hljs-keyword">try</span>...<span class="hljs-keyword">catch</span>捕获该错误：<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;sample.txt&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-comment">// 出错了</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>写文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">将数据写入文件是通过fs.<span class="hljs-title function_">writeFile</span>()实现的：<br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;Hello, Node.js&#x27;</span>;<br>fs.<span class="hljs-title function_">writeFile</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>, data, <span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ok.&#x27;</span>);<br>    &#125;<br>&#125;);<br><br><br>和<span class="hljs-title function_">readFile</span>()类似，<span class="hljs-title function_">writeFile</span>()也有一个同步方法，叫<span class="hljs-title function_">writeFileSync</span>()：<br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;Hello, Node.js&#x27;</span>;<br>fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;output.txt&#x27;</span>, data);<br></code></pre></td></tr></table></figure><p><strong>stat</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">如果我们要获取文件大小，创建时间等信息，可以使用fs.<span class="hljs-title function_">stat</span>()，它返回一个<span class="hljs-title class_">Stat</span>对象，能告诉我们文件或目录的详细信息：<br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.<span class="hljs-title function_">stat</span>(<span class="hljs-string">&#x27;sample.txt&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">err, stat</span>) &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 是否是文件:</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isFile: &#x27;</span> + stat.<span class="hljs-title function_">isFile</span>());<br>        <span class="hljs-comment">// 是否是目录:</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isDirectory: &#x27;</span> + stat.<span class="hljs-title function_">isDirectory</span>());<br>        <span class="hljs-keyword">if</span> (stat.<span class="hljs-title function_">isFile</span>()) &#123;<br>            <span class="hljs-comment">// 文件大小:</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;size: &#x27;</span> + stat.<span class="hljs-property">size</span>);<br>            <span class="hljs-comment">// 创建时间, Date对象:</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;birth time: &#x27;</span> + stat.<span class="hljs-property">birthtime</span>);<br>            <span class="hljs-comment">// 修改时间, Date对象:</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;modified time: &#x27;</span> + stat.<span class="hljs-property">mtime</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="六、一些其他的points"><a href="#六、一些其他的points" class="headerlink" title="六、一些其他的points"></a>六、一些其他的points</h2><h4 id="一些-DOM-对象方法"><a href="#一些-DOM-对象方法" class="headerlink" title="一些 DOM 对象方法"></a>一些 DOM 对象方法</h4><p>这里提供一些您将在本教程中学到的常用方法：</p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getElementById()</td><td align="left">返回带有指定 ID 的元素。</td></tr><tr><td align="left">getElementsByTagName()</td><td align="left">返回包含带有指定标签名称的所有元素的节点列表（集合&#x2F;节点数组）。</td></tr><tr><td align="left">getElementsByClassName()</td><td align="left">返回包含带有指定类名的所有元素的节点列表。</td></tr><tr><td align="left">appendChild()</td><td align="left">把新的子节点添加到指定节点。</td></tr><tr><td align="left">removeChild()</td><td align="left">删除子节点。</td></tr><tr><td align="left">replaceChild()</td><td align="left">替换子节点。</td></tr><tr><td align="left">insertBefore()</td><td align="left">在指定的子节点前面插入新的子节点。</td></tr><tr><td align="left">createAttribute()</td><td align="left">创建属性节点。</td></tr><tr><td align="left">createElement()</td><td align="left">创建元素节点。</td></tr><tr><td align="left">createTextNode()</td><td align="left">创建文本节点。</td></tr><tr><td align="left">getAttribute()</td><td align="left">返回指定的属性值。</td></tr><tr><td align="left">setAttribute()</td><td align="left">把指定属性设置或修改为指定的值。</td></tr></tbody></table><h4 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h4><p><code>classList</code> 是 JavaScript 中用于操作元素的类列表的属性，它提供了一组方法来添加、移除、切换和检查类名。</p><p><code>classList</code> 属性是一个只读属性，返回一个 <code>DOMTokenList</code> 对象。<code>DOMTokenList</code> 是一个类数组对象，它包含了元素的类名作为字符串。</p><p>以下是一些常用的 <code>classList</code> 方法：</p><ul><li><code>add(className)</code>：向元素的类列表中添加一个或多个类名。</li><li><code>remove(className)</code>：从元素的类列表中移除一个或多个类名。</li><li><code>toggle(className)</code>：如果类名存在，则从元素的类列表中移除它；如果类名不存在，则向元素的类列表中添加它。</li><li><code>contains(className)</code>：检查元素的类列表中是否包含指定的类名，返回布尔值。</li></ul><p>以下是一个示例，演示如何使用 <code>classList</code> 操作元素的类列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">&quot;myElement&quot;</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;<span class="hljs-title class_">Hello</span>&lt;/div&gt;<br><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;myElement&quot;</span>);<br><br><span class="hljs-comment">// 添加类名</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;highlight&quot;</span>);<br><br><span class="hljs-comment">// 移除类名</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;box&quot;</span>);<br><br><span class="hljs-comment">// 切换类名</span><br>element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&quot;active&quot;</span>);<br><br><span class="hljs-comment">// 检查是否包含类名</span><br><span class="hljs-keyword">var</span> hasClass = element.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&quot;highlight&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hasClass); <span class="hljs-comment">// 输出: true</span><br></code></pre></td></tr></table></figure><p>在上述示例中，我们首先通过 <code>document.getElementById</code> 方法获取具有 id “myElement” 的 <code>&lt;div&gt;</code> 元素，并将其存储在变量 <code>element</code> 中。</p><p>然后，我们使用 <code>classList</code> 的方法来添加、移除、切换和检查类名。在示例中，我们添加了 “highlight” 类名，移除了 “box” 类名，切换了 “active” 类名，并检查了是否包含 “highlight” 类名。</p><p>通过使用 <code>classList</code>，你可以方便地操作元素的类列表，添加或移除类名，实现样式的动态变化和交互效果。</p><h4 id="stopPropagation"><a href="#stopPropagation" class="headerlink" title="stopPropagation()"></a>stopPropagation()</h4><p>当在一个事件处理器中调用时，可以防止事件向任何其他元素传递。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">在这个示例中，我们的页面包含一个视频，最初它为隐藏状态；还有一个标记为“显示视频”的按钮。我们希望有如下交互：<br><br>当用户单击“显示视频”按钮时，显示包含视频的盒子，但不要开始播放视频。<br>当用户在视频上单击时，开始播放视频。<br>当用户单击盒子内视频以外的任何区域时，隐藏盒子。<br><br><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;button&quot;</span>);<br><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;div&quot;</span>);<br><span class="hljs-keyword">const</span> video = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;video&quot;</span>);<br><br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&quot;hidden&quot;</span>));<br><br>video.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.<span class="hljs-title function_">stopPropagation</span>();<br>  video.<span class="hljs-title function_">play</span>();<br>&#125;);<br><br>box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> box.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;hidden&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="this-1"><a href="#this-1" class="headerlink" title="this"></a>this</h4><p>在 JavaScript 中，<code>this</code> 关键字用于引用当前执行代码的上下文。它的值取决于函数的调用方式。</p><p>在事件处理程序中，<code>this</code> 指向触发事件的元素，也就是<strong>绑定了事件监听器的元素</strong>。因此，在 <code>handleDelete</code> 函数中，<code>this</code> 就是指向 <code>destroyButton</code> 元素。</p><p>所以，当你在 <code>destroyButton</code> 的点击事件处理程序中使用 <code>this</code>，它就代表了当前点击的 <code>destroyButton</code> 元素本身。</p><p>值得注意的是，如果你在箭头函数中使用 <code>this</code>，它将捕获外层的上下文，而不是绑定到触发事件的元素。因此，在使用箭头函数时，可能需要使用其他方式来访问触发事件的元素。</p><p><code>this</code> 和 <code>event.target</code> 都与事件处理相关，但它们表示不同的东西。</p><ul><li><code>this</code> 是当前执行代码的上下文，指向绑定了事件监听器的元素。在事件处理程序中，<code>this</code> 引用触发事件的元素。</li><li><code>event.target</code> 是事件对象中的属性，表示触发事件的目标元素。它是事件冒泡过程中的当前目标，即接收事件的元素。</li></ul><p>区别在于，<code>this</code> 是绑定事件监听器的元素，而 <code>event.target</code> 是触发事件的元素。</p><p>举个例子来说明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// 输出绑定事件监听器的元素</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">target</span>); <span class="hljs-comment">// 输出触发事件的元素</span><br>&#125;<br><br><span class="hljs-keyword">var</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;button&#x27;</span>);<br>button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleClick);<br></code></pre></td></tr></table></figure><p>在上面的代码中，当按钮被点击时，<code>handleClick</code> 函数被调用。在函数中，<code>this</code> 指向按钮元素，而 <code>event.target</code> 指向触发点击事件的元素，可能是按钮自身或其内部的子元素。</p><p>总结来说，<code>this</code> 引用绑定事件监听器的元素，而 <code>event.target</code> 引用触发事件的元素。</p><h4 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h4><h5 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h5><p><code>call</code> 方法是 JavaScript 中函数对象的一个方法，它允许你在指定的作用域中调用一个函数，并且可以指定函数执行时的上下文对象（即 <code>this</code> 值）和参数列表。</p><p><code>call</code> 方法的语法如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">function</span>.<span class="hljs-keyword">call</span>(thisArg, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>function</code> 是要调用的函数对象。</li><li><code>thisArg</code> 是函数执行时的上下文对象，即在函数内部可以通过 <code>this</code> 关键字访问的对象。</li><li><code>arg1</code>, <code>arg2</code>, … 是传递给函数的参数列表。</li></ul><p>当调用 <code>call</code> 方法时，它会立即执行函数，并将指定的上下文对象绑定到函数内部的 <code>this</code>。这样，函数内部可以通过 <code>this</code> 访问该上下文对象的属性和方法。</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call#using_call_to_invoke_a_function_and_specifying_the_this_value">Using call() to invoke a function and specifying the this value</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">animal</span>, <span class="hljs-string">&quot;typically sleep between&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">sleepDuration</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">animal</span>: <span class="hljs-string">&quot;cats&quot;</span>,<br>  <span class="hljs-attr">sleepDuration</span>: <span class="hljs-string">&quot;12 and 16 hours&quot;</span>,<br>&#125;;<br><br>greet.<span class="hljs-title function_">call</span>(obj); <span class="hljs-comment">// cats typically sleep between 12 and 16 hours</span><br><br></code></pre></td></tr></table></figure><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call#using_call_to_invoke_a_function_without_specifying_the_first_argument">Using call() to invoke a function without specifying the first argument</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">globalThis.<span class="hljs-property">globProp</span> = <span class="hljs-string">&quot;Wisen&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">display</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`globProp value is <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.globProp&#125;</span>`</span>);<br>&#125;<br><br>display.<span class="hljs-title function_">call</span>(); <span class="hljs-comment">// Logs &quot;globProp value is Wisen&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h5><p><code>Object.create()</code> 是 JavaScript 中用于创建一个新对象，并将新对象的原型设置为指定的原型对象的方法。它的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proto, [propertiesObject])<br></code></pre></td></tr></table></figure><p>其中，<code>proto</code> 是新对象的原型对象，它可以是任何对象或 <code>null</code>。<code>propertiesObject</code> 是一个可选参数，用于定义新对象的可枚举属性。</p><p><code>Object.create()</code> 的作用是创建一个新对象，该对象的原型链将继承自指定的原型对象。新对象将拥有原型对象的属性和方法，并且可以在新对象上添加或覆盖属性。</p><p>下面是一些示例用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个原型为 null 的新对象</span><br><span class="hljs-keyword">var</span> obj1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">// 创建一个原型为 Object.prototype 的新对象</span><br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-comment">// 创建一个原型为自定义对象的新对象</span><br><span class="hljs-keyword">var</span> parent = &#123;<br>  <span class="hljs-attr">greeting</span>: <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">greeting</span>); <span class="hljs-comment">// 输出: Hello</span><br><br><span class="hljs-comment">// 在创建对象时指定属性</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, &#123;<br>  <span class="hljs-attr">name</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">age</span>: &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>通过使用 <code>Object.create()</code>，你可以基于现有对象创建新对象，并将新对象与现有对象建立原型链继承关系。这种继承方式非常灵活，允许你创建具有特定属性和方法的对象，并在原型链上共享通用的属性和方法。</p><p>总之括号里的是原型，新创建的可以继承原型的属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Shape</span>(<span class="hljs-params">x, y, velX, velY, exists</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velX</span> = velX;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">velY</span> = velY;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exists</span> = exists;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Ball</span>(<span class="hljs-params">x, y, velX, velY, exists, color, size</span>) &#123;<br>    <span class="hljs-title class_">Shape</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,x, y, velX, velY, exists);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = size;<br>&#125;<br><br><span class="hljs-title class_">Ball</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Shape</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-title class_">Ball</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Ball</span>;<br><br><br><br><span class="hljs-string">`Shape.call(this, x, y, velX, velY, exists)`</span> 是为了在 <span class="hljs-string">`Ball`</span> 构造函数中调用父构造函数 <span class="hljs-string">`Shape`</span>，并将当前实例作为上下文（<span class="hljs-string">`this`</span>）传递给父构造函数。这样做的目的是为了在创建 <span class="hljs-string">`Ball`</span> 实例时，将父构造函数 <span class="hljs-string">`Shape`</span> 中的属性初始化到 <span class="hljs-string">`Ball`</span> 实例中。<br><br>然而，这只是初始化实例的属性，并没有涉及到原型对象的继承。通过 <span class="hljs-string">`Shape.call(this, x, y, velX, velY, exists)`</span>，我们只是将属性赋值给当前实例，并没有实现原型链上的继承关系。<br><br>所以，需要使用 <span class="hljs-string">`Object.create(Shape.prototype)`</span> 来设置子构造器 <span class="hljs-string">`Ball`</span> 的原型对象，以确保 <span class="hljs-string">`Ball`</span> 实例可以继承父构造器 <span class="hljs-string">`Shape`</span> 原型对象中的方法和属性。<br>同时，为了确保子构造器的原型对象的 constructor 属性指向正确的构造函数，需要执行 <span class="hljs-title class_">Ball</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Ball</span> 这句代码，将 constructor 属性重置为子构造器 <span class="hljs-title class_">Ball</span>。<br><br>这样做的目的是为了保持对象的完整性和一致性。在继承关系中，通过正确设置原型和构造函数，可以确保对象在实例化和调用方法时具有正确的行为和标识。<br><br>综上所述，这两步是必要的，一步是为了属性的初始化，另一步是为了实现原型链上的继承。<br></code></pre></td></tr></table></figure><h4 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类 伪元素"></a>伪类 伪元素</h4><p>伪类（Pseudo-classes）是用于选择元素的特定状态或状态变化的关键词。它们以<code>:</code>开头，如<code>:hover</code>、<code>:active</code>、<code>:focus</code>等。伪类选择器应用于元素的特定状态。</p><p>伪元素（Pseudo-elements）则是在文档树中创建的虚拟元素，用于在选定元素的内容前、后或内部插入特定样式。伪元素以<code>::</code>开头，如<code>::before</code>、<code>::after</code>等。伪元素可以在元素的内容前后插入内容，并且可以通过 CSS 设置其样式。</p><p>总结一下：</p><ul><li><code>:</code>用于伪类，用于选中元素的特定状态。</li><li><code>::</code>用于伪元素，用于在选定元素的内容前、后或内部插入生成的内容。</li></ul><p>需要注意的是，根据不同的 CSS 规范版本和浏览器支持，某些伪元素可能也可以使用单个冒号（<code>:</code>）作为前缀。因此，在实际使用中，请查阅相关规范并检查浏览器兼容性。</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p><code>forEach</code>是数组的一个方法，用于遍历数组中的每个元素并执行指定的操作。以下是使用<code>forEach</code>的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>];<br><br>fruits.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">fruit</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruit);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上述代码会输出：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apple</span><br><span class="hljs-attribute">banana</span><br><span class="hljs-attribute">orange</span><br></code></pre></td></tr></table></figure><p>在<code>forEach</code>方法中，我们传递了一个回调函数作为参数，该回调函数将在每个数组元素上被调用。回调函数接受当前迭代的元素作为参数（在示例中是<code>fruit</code>），我们可以在回调函数中对元素进行处理。</p><p>如果需要使用箭头函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fruits.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fruit</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruit);<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意：<code>forEach</code>方法只能用于数组，不能用于类似对象等其他数据结构。</p><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>在编程中，<code>map()</code>是一种常用的函数或方法，用于处理数组或类似结构（如列表）的元素，并返回一个新的数组，其中包含根据指定的转换规则对原始数组中的每个元素进行处理后的结果。</p><p><code>map()</code>方法的基本语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> newArray = originalArray.<span class="hljs-title function_">map</span>(callbackFunction);<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>originalArray</code> 是要处理的原始数组。</li><li><code>callbackFunction</code> 是一个回调函数，用于指定如何对原始数组中的每个元素进行处理。回调函数接收三个参数：<ol><li><code>currentValue</code>：当前正在处理的元素的值。</li><li><code>index</code>：当前正在处理的元素的索引（可选）。</li><li><code>array</code>：原始数组（可选）。</li></ol></li></ul><p><code>map()</code>方法会依次遍历原始数组的每个元素，并将每个元素传递给回调函数进行处理。回调函数返回的值将被添加到新的数组中，最终形成一个新的数组。原始数组保持不变，而新数组包含了根据回调函数处理后的元素。</p><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// 使用map()方法将数组中的每个元素乘以2，并创建新的数组</span><br><span class="hljs-keyword">const</span> doubledNumbers = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> num * <span class="hljs-number">2</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubledNumbers); <span class="hljs-comment">// Output: [2, 4, 6, 8, 10]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>map()</code>方法将<code>numbers</code>数组中的每个元素乘以2，并将处理后的结果放入新的数组<code>doubledNumbers</code>。原始数组<code>numbers</code>保持不变。</p><p><code>map()</code>方法对于需要处理数组中的每个元素，并且生成一个新的数组的情况非常有用，比如进行转换、格式化或提取数据等操作。</p><h4 id="querySelector和getElementsBy…"><a href="#querySelector和getElementsBy…" class="headerlink" title="querySelector和getElementsBy…"></a>querySelector和getElementsBy…</h4><p><code>querySelector</code> 和 <code>getElementsBy</code> 系列方法都用于在文档中查找元素，但它们返回的结果有一些区别。</p><ol><li><p><strong>返回类型</strong>：</p><ul><li><code>querySelector</code> <strong>返回匹配的第一个元素</strong>，如果没有匹配的元素，则返回 <code>null</code>。</li><li><code>getElementsBy</code> 系列方法<strong>返回一个类数组对象</strong>，称为 HTMLCollection 或 NodeList（具体取决于方法），其中包含匹配的所有元素。</li></ul></li><li><p><strong>查找范围</strong>：</p><ul><li><code>querySelector</code> 在整个文档中查找匹配的元素。</li><li><code>getElementsBy</code> 系列方法在指定的元素集合（如 <code>document</code>、特定元素或特定节点列表）中查找匹配的元素。</li></ul></li><li><p><strong>使用灵活性</strong>：</p><ul><li><code>querySelector</code> 支持更灵活的选择器语法，可以使用类似 CSS 选择器的语法来选择元素。例如，<code>.class</code>、<code>#id</code>、<code>element</code> 等。</li><li><code>getElementsBy</code> 系列方法接受的参数是一个简单的标记名称（例如 <code>&#39;div&#39;</code>）或类名（例如 <code>&#39;className&#39;</code>），不支持复杂的选择器语法。</li></ul></li><li><p><strong>实时性</strong>：</p><ul><li><code>querySelector</code> 返回的是一个静态的结果。即使文档发生更改，它也不会自动更新匹配的元素。</li><li><code>getElementsBy</code> 系列方法返回的是一个动态的结果。如果文档发生更改，它会自动更新匹配的元素。</li></ul></li></ol><p>综上所述，<code>querySelector</code> 提供了更强大和灵活的选择器功能，并且更适合于单个元素的选择。而 <code>getElementsBy</code> 系列方法适合于在指定的元素集合中查找匹配的元素。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是即便外部函数已经不存在，也可以获取作用域链上变量的函数。</p><p><strong>闭包的特性</strong></p><ul><li>即便外部函数不再存在，闭包也可以获取父函数中的变量。</li><li>闭包不可以获取外部函数中的形参&#96;args·。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">buttonProps</span> = (<span class="hljs-params">borderRadius</span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createVariantButtonProps</span> = (<span class="hljs-params">variant, color</span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> newProps = &#123;<br>borderRadius,<br>variant,<br>color<br>&#125;;<br><span class="hljs-keyword">return</span> newProps;<br>&#125;<br><span class="hljs-keyword">return</span> createVariantButtonProps;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>闭包的优点</strong></p><ul><li>可以借助闭包在执行上下文中添加变量。</li><li>可以使用闭包中的变量保存状态，之后使用。</li><li>闭包提供数据封装。</li><li>使用闭包可以删除多余的代码。</li><li>可以使用闭包维护模块化代码。</li></ul><p><strong>闭包的缺点</strong></p><p>过度使用闭包会引发两大问题：</p><ul><li>闭包内声明的变量不能被垃圾回收。</li><li>应用中存在过多的闭包会影响应用运行速度，因为闭包会造成内存中保留重复的代码。</li></ul><h2 id="六、遇到的问题"><a href="#六、遇到的问题" class="headerlink" title="六、遇到的问题"></a>六、遇到的问题</h2><h4 id="事件委托棒棒哒"><a href="#事件委托棒棒哒" class="headerlink" title="事件委托棒棒哒"></a>事件委托棒棒哒</h4><p>比如在自己编写的todoList代码中</p><p>为每个 <li> 元素添加双击事件监听器——这种方法是不行的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> todoListItems = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;.todo-list li&#x27;</span>);<br>todoListItems.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) &#123;<br>  item.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;dblclick&#x27;</span>, startEditing);<br>&#125;);<br></code></pre></td></tr></table></figure><p>将双击事件监听器绑定在父元素上——–正确做法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> todoList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.todo-list&#x27;</span>);<br>todoList.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;dblclick&#x27;</span>, startEditing);<br></code></pre></td></tr></table></figure><p>原因如下：<br>在实现双击编辑功能时，使用事件委托（event delegation）的方式将双击事件监听器绑定在父元素上有以下几个好处：</p><ul><li><p>动态添加的元素也能够受到事件监听器的影响：当你通过 JavaScript 动态地添加新的 <li> 元素时，<strong>这些新元素没有直接绑定事件监听器</strong>。但是，如果你将监听器绑定在它们的父元素上，那么新添加的元素也会受到监听器的影响。这样可以避免在每次添加新元素时都要为它们单独设置事件监听器的麻烦。</p></li><li><p>提高性能和内存效率：将监听器绑定在父元素上可以减少事件监听器的数量。相对于为每个 <li> 元素都绑定监听器，只绑定一个监听器到父元素上可以提高性能和内存效率，特别是在大量元素存在的情况下。</p></li><li><p>方便处理事件委托：事件委托可以让你在父元素上捕获事件，然后根据事件的目标元素（即触发事件的元素）来执行相应的操作。在双击编辑功能的情况下，你可以通过检查事件的目标元素是否为 <label> 元素，来确定是否触发双击编辑功能。这样，你无需为每个 <li> 元素单独设置双击事件监听器，而是统一在父元素上处理。</p></li></ul><p>综上所述，使用事件委托将事件监听器绑定在父元素上具有更好的灵活性、性能和内存效率，尤其适用于需要处理大量动态添加元素的情况。</p><h4 id="关于”提升”"><a href="#关于”提升”" class="headerlink" title="关于”提升”"></a>关于”提升”</h4><h5 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h5><p>在执行代码之前，JavaScript解释器会进行函数的解析，并将函数定义提升到作用域的顶部。</p><p>函数提升的机制使得函数在定义之前就可以进行调用，这在某些情况下非常方便。然而，尽管函数调用可以在定义之前，但是最佳实践是将函数的调用放在函数定义的后面，以提高代码的可读性和可维护性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数调用</span><br><span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出：Hello!</span><br><br><span class="hljs-comment">// 函数定义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是可行的</p><h5 id="函数表达式提升-×"><a href="#函数表达式提升-×" class="headerlink" title="函数表达式提升 ×"></a>函数表达式提升 ×</h5><p>函数表达式不会被提升。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 抛出错误：sayHello is not a function</span><br><br><span class="hljs-keyword">var</span> sayHello = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello!&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>在这个例子中，由于变量 <code>sayHello</code> 的声明和赋值是通过函数表达式完成的，而非函数声明，所以它不会被提升。因此，在调用函数之前，变量 <code>sayHello</code> 还未被赋值，导致抛出错误。</p><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><p>关于变量提升，JavaScript 会将变量声明提升到作用域的顶部，但不会提升赋值操作。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 输出：undefined</span><br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，变量 <code>x</code> 被提升，但它的值在声明之前是 <code>undefined</code>。因此，当我们尝试在赋值之前输出它时，会得到 <code>undefined</code>。</p><p><strong>总结</strong>：函数声明会被提升，函数表达式和变量赋值操作不会被提升。为了避免潜在的错误和代码可读性问题，建议在使用之前先进行函数声明和变量赋值操作。如果可能，将函数的调用放在函数定义之后，以提高代码的清晰性和可维护性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">以下是错误经历：<br><span class="hljs-keyword">var</span> evilcircle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EvilCircle</span> (<br>......<br>);<br>evilcircle.<span class="hljs-title function_">setControls</span>();<br><span class="hljs-title class_">EvilCircle</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setControls</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>&#125;<br>正确的应该先定义后调用，否则setControls的方法没有赋给<span class="hljs-title class_">EvilCircle</span>的原型<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS运行机制</title>
    <link href="/2024/01/28/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/01/28/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h2><p> 深入剖析底层原理 🤔 本篇笔记涉及进程和线程，JS单线程机制，浏览器机制，宏任务微任务，async&#x2F;await等内容</p><span id="more"></span><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li><strong>什么是进程</strong><ul><li><code>进程</code>是<code>CPU</code>资源分配的最小单位</li><li><code>进程</code>包括运行中的程序和程序所使用到的内存和系统资源</li></ul></li><li><strong>什么是线程</strong><ul><li><code>线程</code>是<code>CPU</code>调度的最小单位</li><li><code>线程</code>是建立在<code>进程</code>基础上的一次程序运行单位 <strong>程序中的一个执行流</strong><ul><li>单线程：一个进程中只有一个执行流</li><li>多线程：一个进程中有多个执行流</li></ul></li></ul></li><li><strong>进程和线程的区别</strong><ul><li>进程是<strong>操作系统分配资源的最小单位</strong>，线程是<strong>程序执行的最小单位</strong></li><li><strong>一个进程由一个或多个线程组成</strong>，线程可以理解为是一个进程中代码的不同执行路线</li><li>进程之间相互独立，但同一进程下的各个线程间<strong>共享</strong>程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)</li><li>调度和切换：线程上下文切换比进程上下文切换要<strong>快得多</strong></li></ul></li><li><strong>多进程和多线程</strong><ul><li><strong>多进程</strong>：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态</li><li><strong>多线程</strong>：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</li></ul></li></ul><h3 id="JS的单线程机制"><a href="#JS的单线程机制" class="headerlink" title="JS的单线程机制"></a>JS的单线程机制</h3><ul><li>脚本语言 与用户互动 操作DOM</li><li>不是单线程会有同步问题</li></ul><hr><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><strong>浏览器是多进程的</strong></p><h4 id="浏览器包含的进程"><a href="#浏览器包含的进程" class="headerlink" title="浏览器包含的进程"></a>浏览器包含的进程</h4><ul><li><strong>Browser进程</strong><ul><li>浏览器的<strong>主进程</strong>(负责协调、主控)，该进程只有一个</li><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li><strong>第三方插件进程</strong><ul><li>每种类型的插件对应一个进程，当使用该插件时才创建</li></ul></li><li><strong>GPU进程</strong><ul><li>该进程也只有一个，用于<strong>3D绘制</strong>等等</li></ul></li><li><strong>渲染进程(重)</strong><ul><li>即通常所说的浏览器内核(<strong>Renderer进程</strong>，内部是多线程)</li><li>每个Tab页面都有一个渲染进程，互不影响</li><li>主要作用为<strong>页面渲染，脚本执行，事件处理</strong>等</li></ul></li></ul><hr><h4 id="渲染进程Renderer"><a href="#渲染进程Renderer" class="headerlink" title="渲染进程Renderer"></a>渲染进程Renderer</h4><h5 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h5><ul><li>负责渲染浏览器界面，<strong>解析HTML，CSS</strong>，<strong>构建DOM树和RenderObject树</strong>，<strong>布局和绘制</strong>等<ul><li>解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree</li><li>解析css，生成CSSOM(CSS规则树)</li><li>把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)</li></ul></li><li>当我们修改了一些元素的颜色或者背景色，页面就会<strong>重绘(Repaint)</strong></li><li>当我们修改元素的尺寸，页面就会<strong>回流(Reflow)</strong></li><li>当页面需要Repaing和Reflow时GUI线程执行，绘制页面</li><li>回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免Reflow和Repaint</li><li><strong>GUI渲染线程与JS引擎线程是互斥的</strong><ul><li>当JS引擎执行时GUI线程会被挂起(相当于被冻结了)</li><li>GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</li></ul></li></ul><h5 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a>JS引擎线程</h5><ul><li>JS引擎线程就是<strong>JS内核</strong>，负责处理Javascript脚本程序(例如V8引擎)</li><li>JS引擎线程负责<strong>解析Javascript脚本，运行代码</strong></li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理<ul><li>浏览器同时只能有一个JS引擎线程在运行JS程序，所以<strong>js是单线程运行的</strong></li><li>一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序</li></ul></li><li>GUI渲染线程与JS引擎线程是<strong>互斥</strong>的，js引擎线程会阻塞GUI渲染线程<ul><li>就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)</li><li>例如浏览器渲染的时候遇到<code>&lt;script&gt;</code>标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况</li></ul></li></ul><h5 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h5><ul><li><strong>属于浏览器</strong>而不是JS引擎，用来<strong>控制事件循环</strong>，并且<strong>管理着一个事件队列(task queue)</strong></li><li>当js执行碰到<strong>事件绑定</strong>和一些<strong>异步操作</strong>(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程<strong>将对应的事件添加到对应的线程中</strong>(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的<strong>回调操作添加到事件队列</strong>，等待js引擎线程空闲时来处理。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理</li></ul><h5 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h5><ul><li><code>setInterval</code>与<code>setTimeout</code>所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的(因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)</li><li><strong>通过单独线程来计时并触发定时</strong>(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程</li><li>W3C在HTML标准中规定，规定要求<code>setTimeout</code>中低于4ms的时间间隔算为4ms</li></ul><h5 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h5><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行</li><li>简单说就是当执行到一个http异步请求时，就把<strong>异步请求事件添加到异步请求线程</strong>，等收到响应(准确来说应该是http状态变化)，再把<strong>回调函数添加到事件队列</strong>，等待js引擎线程来执行</li></ul><hr><h4 id="事件循环Event-Loop"><a href="#事件循环Event-Loop" class="headerlink" title="事件循环Event Loop"></a>事件循环Event Loop</h4><ul><li>js分为<strong>同步任务</strong>和<strong>异步任务</strong></li><li>同步任务都在主线程 ，形成一个<strong>执行栈</strong></li><li>事件触发线程管理着一个<strong>任务队列</strong>， 异步任务有结果之后放一个事件回调</li><li>执行栈执行完毕后，读取任务队列添加到执行栈中开始执行</li></ul><p>JS引擎线程只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的<strong>事件循环(Event Loop)</strong></p><blockquote><p>总之就是 js线程控制执行着执行栈中的任务</p><p>事件触发线程控制着任务队列, js有空的时候才执行任务队列里面的</p><p>定时器触发线程是单独一个线程用来计时,到时间之后添加到任务队列里面等待</p><p>异步http请求线程是单独一个线程请求资源,请求成功之后添加到任务队列里面等待</p></blockquote><p><strong>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</strong></p><p>事件循环的基本流程如下：</p><ul><li>执行<strong>同步代码</strong>，将Promise对象的<code>executor</code>函数立即执行。</li><li>如果<code>executor</code>中包含异步操作（比如<code>setTimeout</code>），它们会被放入宏任务队列。</li><li>当执行栈为空时，JavaScript会检查微任务队列，<strong>执行微任务</strong>。微任务包括Promise的回调。then</li><li>接着，JavaScript会检查宏任务队列，<strong>执行宏任务</strong>。宏任务包括<code>setTimeout</code>等。</li></ul><hr><h3 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务&amp;微任务"></a>宏任务&amp;微任务</h3><h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p><strong>macrotask</strong> (<strong>task</strong>)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">宏任务 <span class="hljs-punctuation">-&gt;</span> GUI渲染 <span class="hljs-punctuation">-&gt;</span> 宏任务 <span class="hljs-punctuation">-&gt;</span> GUI ...<br></code></pre></td></tr></table></figure><ul><li><strong>常见的宏任务</strong><ul><li>主代码块</li><li>setTimeout</li><li>setInterval</li><li>setImmediate ()-Node</li><li>requestAnimationFrame ()-浏览器</li></ul></li></ul><h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p><strong>microtask</strong>(<strong>jobs</strong>)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">宏任务 <span class="hljs-punctuation">-&gt;</span> 微任务 <span class="hljs-punctuation">-&gt;</span> GUI渲染 <span class="hljs-punctuation">-&gt;</span> 宏任务 <span class="hljs-punctuation">-&gt;</span> ...<br></code></pre></td></tr></table></figure><ul><li>常见微任务<ul><li>process.nextTick ()-Node</li><li>Promise.then()</li><li>catch</li><li>finally</li><li>Object.observe</li><li>MutationObserver</li></ul></li></ul><h4 id="简单区分"><a href="#简单区分" class="headerlink" title="简单区分"></a>简单区分</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:black&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:red&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:blue&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:pink&#x27;</span>;<br><br><span class="hljs-comment">//页面直接变成pink 因为这是一次宏任务 都结束后才渲染</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:blue&#x27;</span>;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:black&#x27;</span><br>&#125;,<span class="hljs-number">200</span>)<br><br><span class="hljs-comment">//先blue再马上black 属于两次宏任务 之间有渲染</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:blue&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span> = <span class="hljs-string">&#x27;background:pink&#x27;</span><br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">//输出 1 3 2 then是异步执行</span><br><span class="hljs-comment">//直接变成pink因为宏任务执行后执行Promise.then微任务 之后再渲染</span><br></code></pre></td></tr></table></figure><blockquote><p>首先执行一个宏任务，执行结束后判断是否存在微任务</p><p>有微任务先执行所有的微任务，再渲染，没有微任务则直接渲染</p><p>然后再接着执行下一个宏任务</p></blockquote><ul><li>执行顺序<ul><li>执行当前宏任务的<strong>同步代码</strong></li><li>执行当前宏任务中的<strong>所有微任务</strong></li><li>执行<strong>下一个宏任务</strong></li></ul></li></ul><hr><h3 id="关于Promise"><a href="#关于Promise" class="headerlink" title="关于Promise"></a>关于Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">//输出 1 3 2 </span><br><span class="hljs-comment">//new Promise()是一个构造函数 同步任务</span><br><span class="hljs-comment">//.then()是一个异步微任务</span><br></code></pre></td></tr></table></figure><p><img src="/img/timer.png" alt="定时器情况"></p><h3 id="关于async-await"><a href="#关于async-await" class="headerlink" title="关于async&#x2F;await"></a>关于async&#x2F;await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-title function_">test</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">//输出 1 2 3 4</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// timer1</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;<br><br><span class="hljs-title function_">test</span>();<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// timer2</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// timer3</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)<br>  &#125;, <span class="hljs-number">100</span>)<br>  <span class="hljs-title function_">resolve</span>()<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// timer4</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">7</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">8</span>)<br><br><span class="hljs-comment">// 1 4 8 7 3 6 5 2</span><br></code></pre></td></tr></table></figure><h4 id="某道学长的面试题"><a href="#某道学长的面试题" class="headerlink" title="某道学长的面试题"></a>某道学长的面试题</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>);<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">B</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">222</span>); <span class="hljs-comment">//这里可能需要注意一下，是放入微任务队列</span><br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">333</span>);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">444</span>);<br><span class="hljs-title function_">A</span>();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">555</span>);<br>&#125;,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">666</span>);<br>  <span class="hljs-title function_">resolve</span>(<span class="hljs-number">777</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reason);<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">888</span>);<br><br><span class="hljs-comment">//444 111 333 666 888 222 777 555</span><br></code></pre></td></tr></table></figure><ul><li>当<code>await</code>关键字遇到一个<code>Promise</code>时，它会将<strong>后续的代码</strong>（在这种情况下是打印222）<strong>放入微任务队列</strong>，以便在<code>Promise</code>解析为已完成状态后执行。</li><li>微任务队列是一个异步任务队列，其中的任务会在主事件循环之前执行。这确保了<code>await</code>后面的代码可以尽快执行，而不会被其他任务阻塞。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>底层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何写好prompt</title>
    <link href="/2024/01/28/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BDprompt/"/>
    <url>/2024/01/28/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BDprompt/</url>
    
    <content type="html"><![CDATA[<h1 id="设计prompt的小tips"><a href="#设计prompt的小tips" class="headerlink" title="设计prompt的小tips"></a>设计prompt的小tips</h1><p>💡如何写好prompt获取更优质的回答呢？（本文总结于openai官网教程）</p><span id="more"></span><h3 id="01-写出清晰的指令"><a href="#01-写出清晰的指令" class="headerlink" title="01 写出清晰的指令"></a>01 写出清晰的指令</h3><ul><li>尽可能详细的描述，完整的上下文</li><li>让模型充当某种角色</li><li>使用分隔符清晰划分输入</li><li>指定完成任务需要的步骤</li><li>提供例子 few-shot</li><li>指定输出的长度</li></ul><h3 id="02-提供参考文本"><a href="#02-提供参考文本" class="headerlink" title="02 提供参考文本"></a>02 提供参考文本</h3><ul><li>模型使用参考文本作答</li><li>模型引用参考文本作答</li></ul><h3 id="03-复杂任务拆分成子任务"><a href="#03-复杂任务拆分成子任务" class="headerlink" title="03 复杂任务拆分成子任务"></a>03 复杂任务拆分成子任务</h3><ul><li>使用意图分类</li><li>总结或过滤先前对话</li><li>分段递归总结长文档</li></ul><h3 id="04-给模型时间思考-CoT"><a href="#04-给模型时间思考-CoT" class="headerlink" title="04 给模型时间思考 CoT"></a>04 给模型时间思考 CoT</h3><ul><li>首先让大模型自己解决问题，不要直接判断是否正确</li><li>内心独白增强模型推理过程，多次和api通讯</li><li>询问模型在之前内容是否遗漏某些内容</li></ul><h3 id="05-使用外部工具"><a href="#05-使用外部工具" class="headerlink" title="05 使用外部工具"></a>05 使用外部工具</h3><ul><li>使用基于嵌入的搜索，实现高效知识检索</li><li>执行代码进行更准确的计算，或者调用外部API</li><li>给模型提供特定功能</li></ul><h3 id="06-系统测试变更"><a href="#06-系统测试变更" class="headerlink" title="06 系统测试变更"></a>06 系统测试变更</h3><p>编写程序判断优化系统是否有效 for开发者</p><p><img src="/img/prompt1.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>大模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Welcome to JerryCC&#39;s world!</title>
    <link href="/2024/01/20/Introduction/"/>
    <url>/2024/01/20/Introduction/</url>
    
    <content type="html"><![CDATA[<p> 大家好 ❤ </p><p> 欢迎光临我的小世界 🌼</p><span id="more"></span><p>终于搭建自己的博客啦~ 欢迎大家常来玩啊~</p><h3 id="about-me"><a href="#about-me" class="headerlink" title="about me"></a>about me</h3><p>🦋    <strong>mbti</strong> : <strong>INFP</strong> </p><p>😊    <strong>hobbies</strong> ：<strong>dancing</strong>💃    <strong>sleeping</strong>💤    <strong>eating</strong>😋</p><p>💡<strong>dreams</strong> :  <strong>freedom</strong></p><p>🔑    <strong>github</strong> : <strong><a href="https://github.com/JerryC66">https://github.com/JerryC66</a></strong></p><p>📧<strong>email</strong> : <strong><a href="mailto:&#x31;&#x33;&#53;&#52;&#x35;&#x32;&#48;&#57;&#54;&#x31;&#x36;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;">&#x31;&#x33;&#53;&#52;&#x35;&#x32;&#48;&#57;&#54;&#x31;&#x36;&#x40;&#x31;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;</a></strong> </p><p><img src="/img/test1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
